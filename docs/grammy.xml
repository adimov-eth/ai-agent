This file is a merged representation of a subset of the documentation, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been compressed (code blocks are separated by ⋮---- delimiter), security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: site/docs/**
- Files matching these patterns are excluded: site/docs/es/**, site/docs/ru/**, site/docs/zh/**, site/docs/uk/**, site/docs/id/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
site/
  docs/
    .vitepress/
      components/
        LanguagePopup.vue
        NavBar.vue
        NavBarExtra.vue
        NavScreen.vue
        NotFound.vue
        ThankYou.vue
      configs/
        algolia/
          crawler.js
          index.ts
        locales/
          en.ts
          es.ts
          id.ts
          index.ts
          ru.ts
          uk.ts
          zh.ts
      plugins/
        better-line-breaks/
          plugins.ts
          shared.ts
        current-versions/
          .gitignore
          build-index.ts
          modules.json
          plugins.ts
        index.ts
        markdown.ts
      shared/
        syntaxes/
          env.tmLanguage.json
          plaintext.tmLanguage.json
        vars.ts
      theme/
        layout/
          HomeHeroInfo.vue
          Layout.vue
        style/
          _custom-block.scss
          _fonts.scss
          _normalize.scss
          _selection.scss
          _table.scss
          _vars.scss
          index.scss
        index.ts
      config.ts
    advanced/
      business.md
      deployment.md
      flood.md
      middleware.md
      proxy.md
      README.md
      reliability.md
      scaling.md
      structuring.md
      transformers.md
    demo/
      examples.md
      README.md
    guide/
      api.md
      basics.md
      commands.md
      context.md
      deployment-types.md
      errors.md
      files.md
      filter-queries.md
      games.md
      getting-started.md
      introduction.md
      middleware.md
      reactions.md
      README.md
    hosting/
      cloudflare-workers-nodejs.md
      cloudflare-workers.md
      comparison.md
      deno-deploy.md
      firebase.md
      fly.md
      heroku.md
      supabase.md
      vercel.md
      vps.md
      zeabur-deno.md
      zeabur-nodejs.md
    plugins/
      auto-retry.md
      autoquote.md
      chat-members.md
      commands.md
      console-time.md
      conversations.md
      emoji.md
      entity-parser.md
      files.md
      fluent.md
      guide.md
      hydrate.md
      i18n.md
      inline-query.md
      keyboard.md
      media-group.md
      menu.md
      middlewares.md
      parse-mode.md
      ratelimiter.md
      README.md
      router.md
      runner.md
      session.md
      stateless-question.md
      transformer-throttler.md
    public/
      icons/
        beach.svg
        palette.svg
        rocket.svg
      images/
        grammY.svg
        Y.svg
    resources/
      about.md
      comparison.md
      faq.md
    404.md
    README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="site/docs/.vitepress/components/LanguagePopup.vue">
<script lang="ts" setup>
import { reactive, computed } from "vue";
const languages: Record<string, string> = {
  es: "Spanish",
  id: "Indonesian",
  zh: "Chinese",
  uk: "Ukrainian",
  ru: "Russian"
};
const popup = reactive({
  enabled: localStorage.getItem("disable_language_bar") == null,
});
const availableLanguage = navigator.languages.find((l) => l in languages);
const language = computed<string | null>(() =>
  popup.enabled && availableLanguage !== undefined
    ? languages[availableLanguage]
    : null
);
function disable() {
  popup.enabled = false;
  localStorage.setItem("disable_language_bar", "");
}
</script>
<template>
  <div v-if="language" class="container">
    <div class="bar">
      <div class="content">
            <a v-bind:href="`/${availableLanguage}/`">The documentation is available in {{ language }}.</a>
          <button @click="disable">
            <svg viewBox="0 0 10 10" height="11" fill="currentColor">
              <path fill-rule="evenodd"
                d="M.11.11a.375.375 0 0 1 .53 0l4.235 4.235L9.11.11a.375.375 0 0 1 .53.53L5.405 4.875 9.64 9.11a.375.375 0 0 1-.53.53L4.875 5.405.64 9.64a.375.375 0 0 1-.53-.53l4.235-4.235L.11.64a.375.375 0 0 1 0-.53Z"
                clip-rule="evenodd" />
          </svg>
        </button>
      </div>
    </div>
  </div>
</template>
⋮----
<a v-bind:href="`/${availableLanguage}/`">The documentation is available in {{ language }}.</a>
⋮----
<style scoped>
.container {
  position: fixed;
  top: 60px;
  right: 0;
  z-index: 19;
  width: 100%;
  display: flex;
}
.bar {
  width: 100%;
  height: 100%;
  margin: 0 auto;
  padding: 0.5rem;
  text-align: center;
}
.content {
  height: 100%;
  padding: 10px;
  border-radius: 4px;
  background-color: var(--vp-custom-block-tip-bg);
  opacity: 0.95;
  border: 1px solid var(--vp-custom-block-tip-border);
  display: inline-flex;
  gap: 0.5rem;
  justify-content: space-between;
}
button {
  padding: 0;
  margin: 0;
  padding: 1px;
  border: none;
  cursor: pointer;
  border-radius: 100%;
  justify-content: center;
  background-color: transparent;
}
button:hover {
  opacity: 0.75;
}
</style>
</file>

<file path="site/docs/.vitepress/components/NavBar.vue">
<script lang="ts" setup>
import { useWindowScroll } from '@vueuse/core'
import { useData } from 'vitepress';
import { useSidebar } from 'vitepress/theme';
import { ref, watchPostEffect } from 'vue'
import VPNavBarAppearance from 'vitepress/dist/client/theme-default/components/VPNavBarAppearance.vue'
import VPNavBarExtra from 'vitepress/dist/client/theme-default/components/VPNavBarExtra.vue'
import VPNavBarHamburger from 'vitepress/dist/client/theme-default/components/VPNavBarHamburger.vue'
import VPNavBarMenu from 'vitepress/dist/client/theme-default/components/VPNavBarMenu.vue'
import VPNavBarSearch from 'vitepress/dist/client/theme-default/components/VPNavBarSearch.vue'
import VPNavBarSocialLinks from 'vitepress/dist/client/theme-default/components/VPNavBarSocialLinks.vue'
import VPNavBarTitle from 'vitepress/dist/client/theme-default/components/VPNavBarTitle.vue'
import VPNavBarTranslations from 'vitepress/dist/client/theme-default/components/VPNavBarTranslations.vue'
defineProps<{
  isScreenOpen: boolean
}>()
defineEmits<{
  (e: 'toggle-screen'): void
}>()
const { y } = useWindowScroll()
const { hasSidebar } = useSidebar()
const { frontmatter } = useData()
const classes = ref<Record<string, boolean>>({})
let showTranslation: boolean;
watchPostEffect(() => {
  classes.value = {
    'has-sidebar': hasSidebar.value,
    'home': frontmatter.value.layout === 'home',
    'top': y.value === 0,
  }
  showTranslation = frontmatter.value.translation ?? true;
})
</script>
<template>
  <div class="VPNavBar" :class="classes">
    <div class="wrapper">
      <div class="container">
        <div class="title">
          <VPNavBarTitle>
            <template #nav-bar-title-before><slot name="nav-bar-title-before" /></template>
            <template #nav-bar-title-after><slot name="nav-bar-title-after" /></template>
          </VPNavBarTitle>
        </div>
        <div class="content">
          <div class="content-body">
            <slot name="nav-bar-content-before" />
            <VPNavBarSearch class="search" />
            <VPNavBarMenu class="menu" />
            <VPNavBarTranslations class="translations" v-if="showTranslation"/>
            <VPNavBarAppearance class="appearance" />
            <VPNavBarSocialLinks class="social-links" />
            <VPNavBarExtra class="extra" />
            <slot name="nav-bar-content-after" />
            <VPNavBarHamburger class="hamburger" :active="isScreenOpen" @click="$emit('toggle-screen')" />
          </div>
        </div>
      </div>
    </div>
    <div class="divider">
      <div class="divider-line" />
    </div>
  </div>
</template>
⋮----
<template #nav-bar-title-before><slot name="nav-bar-title-before" /></template>
<template #nav-bar-title-after><slot name="nav-bar-title-after" /></template>
⋮----
<style scoped>
.VPNavBar {
  position: relative;
  height: var(--vp-nav-height);
  pointer-events: none;
  white-space: nowrap;
  transition: background-color 0.5s;
}
.VPNavBar:not(.home) {
  background-color: var(--vp-nav-bg-color);
}
@media (min-width: 960px) {
  .VPNavBar:not(.home) {
    background-color: transparent;
  }
  .VPNavBar:not(.has-sidebar):not(.home.top) {
    background-color: var(--vp-nav-bg-color);
  }
}
.wrapper {
  padding: 0 8px 0 24px;
}
@media (min-width: 768px) {
  .wrapper {
    padding: 0 32px;
  }
}
@media (min-width: 960px) {
  .VPNavBar.has-sidebar .wrapper {
    padding: 0;
  }
}
.container {
  display: flex;
  justify-content: space-between;
  margin: 0 auto;
  max-width: calc(var(--vp-layout-max-width) - 64px);
  height: var(--vp-nav-height);
  pointer-events: none;
}
.container > .title,
.container > .content {
  pointer-events: none;
}
.container :deep(*) {
  pointer-events: auto;
}
@media (min-width: 960px) {
  .VPNavBar.has-sidebar .container {
    max-width: 100%;
  }
}
.title {
  flex-shrink: 0;
  height: calc(var(--vp-nav-height) - 1px);
  transition: background-color 0.5s;
}
@media (min-width: 960px) {
  .VPNavBar.has-sidebar .title {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2;
    padding: 0 32px;
    width: var(--vp-sidebar-width);
    height: var(--vp-nav-height);
    background-color: transparent;
  }
}
@media (min-width: 1440px) {
  .VPNavBar.has-sidebar .title {
    padding-left: max(32px, calc((100% - (var(--vp-layout-max-width) - 64px)) / 2));
    width: calc((100% - (var(--vp-layout-max-width) - 64px)) / 2 + var(--vp-sidebar-width) - 32px);
  }
}
.content {
  flex-grow: 1;
}
@media (min-width: 960px) {
  .VPNavBar.has-sidebar .content {
    position: relative;
    z-index: 1;
    padding-right: 32px;
    padding-left: var(--vp-sidebar-width);
  }
}
@media (min-width: 1440px) {
  .VPNavBar.has-sidebar .content {
    padding-right: calc((100vw - var(--vp-layout-max-width)) / 2 + 32px);
    padding-left: calc((100vw - var(--vp-layout-max-width)) / 2 + var(--vp-sidebar-width));
  }
}
.content-body {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  height: var(--vp-nav-height);
  transition: background-color 0.5s;
}
@media (min-width: 960px) {
  .VPNavBar:not(.home.top) .content-body {
    position: relative;
    background-color: var(--vp-nav-bg-color);
  }
  .VPNavBar:not(.has-sidebar):not(.home.top) .content-body {
    background-color: transparent;
  }
}
@media (max-width: 767px) {
  .content-body {
    column-gap: 0.5rem;
  }
}
.menu + .translations::before,
.menu + .appearance::before,
.menu + .social-links::before,
.translations + .appearance::before,
.appearance + .social-links::before {
  margin-right: 8px;
  margin-left: 8px;
  width: 1px;
  height: 24px;
  background-color: var(--vp-c-divider);
  content: "";
}
.menu + .appearance::before,
.translations + .appearance::before {
  margin-right: 16px;
}
.appearance + .social-links::before {
  margin-left: 16px;
}
.social-links {
  margin-right: -8px;
}
.divider {
  width: 100%;
  height: 1px;
}
@media (min-width: 960px) {
  .VPNavBar.has-sidebar .divider {
    padding-left: var(--vp-sidebar-width);
  }
}
@media (min-width: 1440px) {
  .VPNavBar.has-sidebar .divider {
    padding-left: calc((100vw - var(--vp-layout-max-width)) / 2 + var(--vp-sidebar-width));
  }
}
.divider-line {
  width: 100%;
  height: 1px;
  transition: background-color 0.5s;
}
.VPNavBar:not(.home) .divider-line {
  background-color: var(--vp-c-gutter);
}
@media (min-width: 960px) {
  .VPNavBar:not(.home.top) .divider-line {
    background-color: var(--vp-c-gutter);
  }
  .VPNavBar:not(.has-sidebar):not(.home.top) .divider {
    background-color: var(--vp-c-gutter);
  }
}
</style>
</file>

<file path="site/docs/.vitepress/components/NavBarExtra.vue">
<script lang="ts" setup>
import { computed, watchPostEffect } from 'vue'
import VPFlyout from 'vitepress/dist/client/theme-default/components/VPFlyout.vue'
import VPMenuLink from 'vitepress/dist/client/theme-default/components/VPMenuLink.vue'
import VPSwitchAppearance from 'vitepress/dist/client/theme-default/components/VPSwitchAppearance.vue'
import VPSocialLinks from 'vitepress/dist/client/theme-default/components/VPSocialLinks.vue'
import { useData } from 'vitepress'
import { useLangs } from 'vitepress/dist/client/theme-default/composables/langs.js'
const { site, theme, frontmatter } = useData()
const { localeLinks, currentLang } = useLangs({ correspondingLink: true })
const hasExtraContent = computed(
  () =>
    (localeLinks.value.length && currentLang.value.label) ||
    site.value.appearance ||
    theme.value.socialLinks
)
let showTranslation: boolean;
watchPostEffect(() => {
  showTranslation = frontmatter.value.translation ?? true;
})
</script>
<template>
  <VPFlyout v-if="hasExtraContent" class="VPNavBarExtra" label="extra navigation">
    <div v-if="showTranslation && localeLinks.length && currentLang.label" class="group translations">
      <p class="trans-title">{{ currentLang.label }}</p>
      <template v-for="locale in localeLinks" :key="locale.link">
        <VPMenuLink :item="locale" />
      </template>
    </div>
    <div v-if="site.appearance && site.appearance !== 'force-dark'" class="group">
      <div class="item appearance">
        <p class="label">
          {{ theme.darkModeSwitchLabel || 'Appearance' }}
        </p>
        <div class="appearance-action">
          <VPSwitchAppearance />
        </div>
      </div>
    </div>
    <div v-if="theme.socialLinks" class="group">
      <div class="item social-links">
        <VPSocialLinks class="social-links-list" :links="theme.socialLinks" />
      </div>
    </div>
  </VPFlyout>
</template>
⋮----
<p class="trans-title">{{ currentLang.label }}</p>
<template v-for="locale in localeLinks" :key="locale.link">
        <VPMenuLink :item="locale" />
      </template>
⋮----
{{ theme.darkModeSwitchLabel || 'Appearance' }}
⋮----
<style scoped>
.VPNavBarExtra {
  display: none;
  margin-right: -12px;
}
@media (min-width: 768px) {
  .VPNavBarExtra {
    display: block;
  }
}
@media (min-width: 1280px) {
  .VPNavBarExtra {
    display: none;
  }
}
.trans-title {
  padding: 0 24px 0 12px;
  line-height: 32px;
  font-size: 14px;
  font-weight: 700;
  color: var(--vp-c-text-1);
}
.item.appearance,
.item.social-links {
  display: flex;
  align-items: center;
  padding: 0 12px;
}
.item.appearance {
  min-width: 176px;
}
.appearance-action {
  margin-right: -2px;
}
.social-links-list {
  margin: -4px -8px;
}
</style>
</file>

<file path="site/docs/.vitepress/components/NavScreen.vue">
<script setup lang="ts">
import { useScrollLock } from '@vueuse/core'
import { inBrowser, useData } from 'vitepress'
import { ref, watchPostEffect } from 'vue'
import VPNavScreenAppearance from 'vitepress/dist/client/theme-default/components/VPNavScreenAppearance.vue'
import VPNavScreenMenu from 'vitepress/dist/client/theme-default/components/VPNavScreenMenu.vue'
import VPNavScreenSocialLinks from 'vitepress/dist/client/theme-default/components/VPNavScreenSocialLinks.vue'
import VPNavScreenTranslations from 'vitepress/dist/client/theme-default/components/VPNavScreenTranslations.vue'
defineProps<{
  open: boolean
}>()
const screen = ref<HTMLElement | null>(null)
const isLocked = useScrollLock(inBrowser ? document.body : null)
const { frontmatter } = useData();
let showTranslation: boolean;
watchPostEffect(() => {
  showTranslation = frontmatter.value.translation ?? true;
})
</script>
<template>
  <transition
    name="fade"
    @enter="isLocked = true"
    @after-leave="isLocked = false"
  >
    <div v-if="open" class="VPNavScreen" ref="screen" id="VPNavScreen">
      <div class="container">
        <slot name="nav-screen-content-before" />
        <VPNavScreenMenu class="menu" />
        <VPNavScreenTranslations class="translations" v-if="showTranslation"/>
        <VPNavScreenAppearance class="appearance" />
        <VPNavScreenSocialLinks class="social-links" />
        <slot name="nav-screen-content-after" />
      </div>
    </div>
  </transition>
</template>
<style scoped>
.VPNavScreen {
  position: fixed;
  top: calc(var(--vp-nav-height) + var(--vp-layout-top-height, 0px) + 1px);
  right: 0;
  bottom: 0;
  left: 0;
  padding: 0 32px;
  width: 100%;
  background-color: var(--vp-nav-screen-bg-color);
  overflow-y: auto;
  transition: background-color 0.5s;
  pointer-events: auto;
}
.VPNavScreen.fade-enter-active,
.VPNavScreen.fade-leave-active {
  transition: opacity 0.25s;
}
.VPNavScreen.fade-enter-active .container,
.VPNavScreen.fade-leave-active .container {
  transition: transform 0.25s ease;
}
.VPNavScreen.fade-enter-from,
.VPNavScreen.fade-leave-to {
  opacity: 0;
}
.VPNavScreen.fade-enter-from .container,
.VPNavScreen.fade-leave-to .container {
  transform: translateY(-8px);
}
@media (min-width: 768px) {
  .VPNavScreen {
    display: none;
  }
}
.container {
  margin: 0 auto;
  padding: 24px 0 96px;
  max-width: 288px;
}
.menu + .translations,
.menu + .appearance,
.translations + .appearance {
  margin-top: 24px;
}
.menu + .social-links {
  margin-top: 16px;
}
.appearance + .social-links {
  margin-top: 16px;
}
</style>
</file>

<file path="site/docs/.vitepress/components/NotFound.vue">
<script setup lang="ts">
import { ref, onMounted } from "vue"
import { withBase, useData } from "vitepress"
import { useLangs } from "vitepress/dist/client/theme-default/composables/langs.js"
const { site, theme } = useData()
const { localeLinks } = useLangs({ removeCurrent: false })
const root = ref('/')
onMounted(() => {
  const path = window.location.pathname
    .replace(site.value.base, '')
    .replace(/(^.*?\/).*$/, '/$1')
  if (localeLinks.value.length) {
    root.value =
    localeLinks.value.find(({ link }) => link.startsWith(path))?.link ||
    localeLinks.value[0].link
  }
})
function splitNewLine(str: string): string[] {
  const parts = str.split(/(?<!\\)\n/g);
  return parts.map(part => part.replace(/\\n/g, '\\n'));
}
const randomIndex = Math.floor(Math.random() * theme.value.notFound?.messages.length);
const message = theme.value.notFound?.messages[randomIndex];
const msgParts = splitNewLine(message);
</script>
<template>
  <div class="NotFound">
    <p class="code">{{ theme.notFound?.code ?? '404' }}</p>
    <ClientOnly>
      <h1 class="title">{{ theme.notFound?.title ?? 'PAGE NOT FOUND' }}</h1>
      <div class="divider" />
      <blockquote class="quote">
        <p v-for="msg in msgParts" :key="msg">{{ msg }}</p>
      </blockquote>
      <div class="action">
        <a
          class="link"
          :href="withBase(root)"
          :aria-label="theme.notFound?.linkLabel ?? 'go to home'"
        >
          {{ theme.notFound?.linkText ?? 'Take me home' }}
        </a>
      </div>
    </ClientOnly>
  </div>
</template>
⋮----
<p class="code">{{ theme.notFound?.code ?? '404' }}</p>
⋮----
<h1 class="title">{{ theme.notFound?.title ?? 'PAGE NOT FOUND' }}</h1>
⋮----
<p v-for="msg in msgParts" :key="msg">{{ msg }}</p>
⋮----
{{ theme.notFound?.linkText ?? 'Take me home' }}
⋮----
<style scoped>
.NotFound {
  padding: 64px 24px 96px;
  text-align: center;
}
@media (min-width: 768px) {
  .NotFound {
    padding: 96px 32px 168px;
  }
}
.code {
  line-height: 64px;
  font-size: 64px;
  font-weight: 600;
}
.title {
  padding-top: 12px;
  letter-spacing: 2px;
  line-height: 20px;
  font-size: 20px;
  font-weight: 700;
}
.divider {
  margin: 24px auto 18px;
  width: 64px;
  height: 1px;
  background-color: var(--vp-c-divider);
}
.quote {
  margin: 0 auto;
  font-size: 14px;
  font-weight: 500;
  color: var(--vp-c-text-2);
}
.action {
  padding-top: 20px;
}
.link {
  display: inline-block;
  border: 1px solid var(--vp-c-brand-1);
  border-radius: 16px;
  padding: 3px 16px;
  font-size: 14px;
  font-weight: 500;
  color: var(--vp-c-brand-1);
  transition:
    border-color 0.25s,
    color 0.25s;
}
.link:hover {
  border-color: var(--vp-c-brand-2);
  color: var(--vp-c-brand-2);
}
</style>
</file>

<file path="site/docs/.vitepress/components/ThankYou.vue">
<script lang="ts" setup>
import { reactive } from "vue";
const props = defineProps<{ s: [string, string, string, string] }>();
const contributor = reactive({
  login: "",
  href: "",
  name: "",
  photo: "",
  identicon: "",
  show: false,
});
/**
 * Returns a pseudo-random number between 0 and len which is seeded by the
 * current date.
 */
async function pseudoRandom255(len: number): Promise<number> {
  const enc = new TextEncoder();
  const today = new Date();
  const key = await window.crypto.subtle.importKey(
    "raw",
    enc.encode("grammy.dev"),
    { name: "HMAC", hash: { name: "SHA-512" } },
    false,
    ["sign"],
  );
  const signature = await window.crypto.subtle.sign(
    "HMAC",
    key,
    enc.encode(today.toUTCString()),
  );
  const arr = new Uint8Array(signature);
  const res = arr.reduce((x, y) => x ^ y);
  return Math.floor((res * len) / 255);
}
function getDay() {
  return Math.floor(Date.now() / 86400);
}
async function load() {
  const day = getDay();
  let cachedContributor: Record<string, string | number> = {};
  const item = localStorage.getItem("contributor");
  if (item) {
    try {
      cachedContributor = JSON.parse(item);
    } catch (_err) {
    }
  }
  if (
    typeof cachedContributor.day === "number" &&
    cachedContributor.day == day &&
    typeof cachedContributor.login === "string" &&
    typeof cachedContributor.href === "string" &&
    typeof cachedContributor.name === "string" &&
    typeof cachedContributor.photo === "string" &&
    typeof cachedContributor.identicon === "string" &&
    typeof cachedContributor.show === "boolean"
  ) {
    contributor.login = cachedContributor.login;
    contributor.href = cachedContributor.href;
    contributor.name = cachedContributor.name;
    contributor.photo = cachedContributor.photo;
    contributor.identicon = cachedContributor.identicon;
    contributor.show = cachedContributor.show;
    return;
  }
  try {
    const res = await fetch("https://raw.githubusercontent.com/grammyjs/grammY/main/.all-contributorsrc");
    if (!res.ok) { throw res }
    const { contributors } = await res.json();
    const selectToday = await pseudoRandom255(contributors.length);
    const contributor_ = contributors[selectToday];
    const parts = contributor_.avatar_url.split('/');
    const userIdWithParams = parts[parts.length - 1];
    const userId = userIdWithParams.split('?')[0];
    try {
      const res = await fetch(`https://api.github.com/user/${userId}`);
      if (!res.ok) { throw res }
      const { login, name, avatar_url, html_url } = await res.json();
      contributor.login = login;
      contributor.href = html_url;
      contributor.name = name ?? login;
      contributor.photo = avatar_url + "&size=64";
    } catch (error) {
      contributor.login = contributor_.login;
      contributor.href = `https://github.com/${contributor_.login}`;
      contributor.name = contributor_.name ?? contributor_.login;
      contributor.photo = contributor_.avatar_url + "&size=64";
    }
    try {
      const res = await fetch(`https://identicons.github.com/${contributor.login}.png`);
      if (!res.ok) { throw res }
      contributor.identicon = `https://identicons.github.com/${contributor.login}.png`
    } catch (error) {
      contributor.identicon = `https://api.dicebear.com/7.x/identicon/png?seed=${contributor.login}&size=48&scale=80&backgroundColor=f0f0f0`
    }
    contributor.show = true;
    localStorage.setItem(
      "contributor",
      JSON.stringify({ ...contributor, day }),
    );
  }
  catch (error) {
    contributor.show = false
  }
}
load();
</script>
<template>
  <div v-if="contributor.show" id="thankyou">
    <div id="avatar-container">
      <img id="identicon" v-bind:src="contributor.identicon" alt="contributor's identicon" width="32" height="32" />
      <img id="github-avatar" v-bind:alt="contributor.login" v-bind:src="contributor.photo" width="32" height="32" />
    </div>
    <p>
      {{ props.s[0] }}
      <a v-bind:href="contributor.href" target="_blank" rel="noreferrer noopener">{{ contributor.name }}</a>{{
        contributor.name.toLowerCase() == "knorpelsenf"
          ? props.s[3] ?? props.s[2]
          : props.s[2]
      }}
    </p>
  </div>
  <div v-else id="thankyou">
    <img src="/images/Y.svg" alt="grammY logo" width="32" height="32" />
  </div>
</template>
⋮----
{{ props.s[0] }}
<a v-bind:href="contributor.href" target="_blank" rel="noreferrer noopener">{{ contributor.name }}</a>{{
⋮----
<style lang="scss">
#thankyou {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.44rem;
  img {
    height: 2rem;
    width: 2rem;
    max-width: none;
    border-radius: 9999px;
  }
  p {
    margin: 0;
    font-size: 0.85rem;
    font-weight: bold;
    a {
      font-weight: bold;
    }
  }
}
#avatar-container,
#identicon {
  position: relative;
}
#github-avatar {
  position: absolute;
  top: 0;
  left: 0;
}
</style>
</file>

<file path="site/docs/.vitepress/configs/algolia/crawler.js">
new Crawler({
⋮----
recordExtractor: ({ helpers, url }) => {
⋮----
const segments = url.pathname.split("/").filter(Boolean);
const [secondToLastSegment, lastSegment] = segments.slice(-2);
⋮----
return helpers.docsearch({
</file>

<file path="site/docs/.vitepress/configs/algolia/index.ts">
import type { DefaultTheme } from "vitepress";
</file>

<file path="site/docs/.vitepress/configs/locales/en.ts">
import type { DocSearchProps } from "node_modules/vitepress/types/docsearch.js";
import type { LocaleConfig } from "vitepress";
import { social } from "../../shared/vars.js";
</file>

<file path="site/docs/.vitepress/configs/locales/es.ts">
import type { DocSearchProps } from "node_modules/vitepress/types/docsearch.js";
import type { LocaleConfig } from "vitepress";
import { social } from "../../shared/vars.js";
</file>

<file path="site/docs/.vitepress/configs/locales/id.ts">
import type { DocSearchProps } from "node_modules/vitepress/types/docsearch.js";
import type { LocaleConfig } from "vitepress";
import { social } from "../../shared/vars.js";
</file>

<file path="site/docs/.vitepress/configs/locales/index.ts">

</file>

<file path="site/docs/.vitepress/configs/locales/ru.ts">
import type { DocSearchProps } from "node_modules/vitepress/types/docsearch.js";
import type { LocaleConfig } from "vitepress";
import { social } from "../../shared/vars.js";
</file>

<file path="site/docs/.vitepress/configs/locales/uk.ts">
import type { DocSearchProps } from "node_modules/vitepress/types/docsearch.js";
import type { LocaleConfig } from "vitepress";
import { social } from "../../shared/vars.js";
</file>

<file path="site/docs/.vitepress/configs/locales/zh.ts">
import type { DocSearchProps } from "node_modules/vitepress/types/docsearch.js";
import type { LocaleConfig } from "vitepress";
import { social } from "../../shared/vars.js";
</file>

<file path="site/docs/.vitepress/plugins/better-line-breaks/plugins.ts">
import { escapeHtml } from "./shared.ts";
import type MarkdownIt from "$types/markdown-it";
export const betterLineBreaks = (md: MarkdownIt) =>
function insertWbrTags(url: string)
</file>

<file path="site/docs/.vitepress/plugins/better-line-breaks/shared.ts">
function replaceUnsafeChar(ch: string)
export function escapeHtml(str: string)
</file>

<file path="site/docs/.vitepress/plugins/current-versions/.gitignore">
index.json
</file>

<file path="site/docs/.vitepress/plugins/current-versions/build-index.ts">
import list from "./modules.json" with { type: "json" };
⋮----
async function redirect(source: string)
</file>

<file path="site/docs/.vitepress/plugins/current-versions/modules.json">
{
  "modules": [
    "grammy",
    "grammy_menu",
    "grammy_runner",
    "grammy_hydrate",
    "grammy_transformer_throttler",
    "grammy_ratelimiter",
    "grammy_auto_retry",
    "grammy_files",
    "grammy_router",
    "grammy_emoji",
    "grammy_parse_mode",
    "grammy_storages",
    "grammy_conversations",
    "grammy_autoquote",
    "grammy_i18n",
    "grammy_commands"
  ]
}
</file>

<file path="site/docs/.vitepress/plugins/current-versions/plugins.ts">
import imports from "./index.json" with { type: "json" };
import type MarkdownIt from "$types/markdown-it";
export const currentVersions = (md: MarkdownIt) =>
</file>

<file path="site/docs/.vitepress/plugins/index.ts">

</file>

<file path="site/docs/.vitepress/plugins/markdown.ts">
import type MarkdownIt from "$types/markdown-it";
import { betterLineBreaks, currentVersions } from "./index.ts";
export const markdown = (md: MarkdownIt) =>
</file>

<file path="site/docs/.vitepress/shared/syntaxes/env.tmLanguage.json">
{
  "name": "env",
  "scopeName": "source.env",
  "fileTypes": [
    ".env",
    ".env-sample",
    ".env.example",
    ".env.local",
    ".env.dev",
    ".env.test",
    ".env.testing",
    ".env.production",
    ".env.prod"
  ],
  "patterns": [
    {
      "match": "(#).*$\\n?",
      "name": "comment.line.number-sign.env",
      "captures": {
        "1": {
          "name": "punctuation.definition.comment.env"
        }
      }
    },
    {
      "name": "string.quoted.double.env",
      "begin": "(\\\")",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.string.begin.env"
        }
      },
      "patterns": [
        {
          "include": "#interpolation"
        },
        {
          "include": "#variable"
        },
        {
          "include": "#escape-characters"
        }
      ],
      "end": "(\\\")",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end"
        }
      }
    },
    {
      "name": "string.quoted.single.env",
      "begin": "(\\')",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.string.begin.env"
        }
      },
      "end": "(\\')",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end"
        }
      }
    },
    {
      "match": "(?<=[\\w])\\s?=",
      "name": "keyword.operator.assignment.env"
    },
    {
      "match": "([\\w]+)(?=\\s?\\=)",
      "name": "variable.other.env"
    },
    {
      "match": "(?i)\\s?(export)",
      "name": "keyword.other.env"
    },
    {
      "match": "(?i)(?<=\\=)\\s?(true|false|null)",
      "name": "constant.language.env"
    },
    {
      "match": "\\b((0(x|X)[0-9a-fA-F]*)|(([0-9]+\\.?[0-9]*)|(\\.[0-9]+))((e|E)(\\+|-)?[0-9]+)?)\\b",
      "name": "constant.numeric.env"
    }
  ],
  "repository": {
    "$base": {},
    "$self": {},
    "interpolation": {
      "begin": "(\\$\\{|\\{)",
      "beginCaptures": {
        "1": {
          "name": "string.interpolated.env keyword.other.template.begin.env"
        }
      },
      "patterns": [
        {
          "match": "(?x)(\\$+)?([a-zA-Z_\\x{7f}-\\x{ff}][a-zA-Z0-9_\\x{7f}-\\x{ff}]*?\\b)",
          "captures": {
            "1": {
              "name": "punctuation.definition.variable.env variable.other.env"
            },
            "2": {
              "name": "variable.other.env"
            }
          }
        }
      ],
      "end": "(\\})",
      "endCaptures": {
        "1": {
          "name": "string.interpolated.env keyword.other.template.end.env"
        }
      }
    },
    "variable": {
      "patterns": [
        {
          "match": "(?x)(\\$+)([a-zA-Z_\\x{7f}-\\x{ff}][a-zA-Z0-9_\\x{7f}-\\x{ff}]*?\\b)",
          "captures": {
            "1": {
              "name": "punctuation.definition.variable.env variable.other.env"
            },
            "2": {
              "name": "variable.other.env"
            }
          }
        }
      ]
    },
    "escape-characters": {
      "patterns": [
        {
          "match": "\\\\[nrt\\\\\\$\\\"\\']",
          "name": "constant.character.escape.env"
        }
      ]
    }
  }
}
</file>

<file path="site/docs/.vitepress/shared/syntaxes/plaintext.tmLanguage.json">
{
  "name": "Plain Text",
  "scopeName": "text.plain",
  "displayName": "Plain Text",
  "fileTypes": ["txt", "text", "plain"],
  "patterns": [],
  "repository": {
    "$self": {},
    "$base": {}
  }
}
</file>

<file path="site/docs/.vitepress/shared/vars.ts">

</file>

<file path="site/docs/.vitepress/theme/layout/HomeHeroInfo.vue">
<script setup lang="ts">
import { onMounted, onUpdated, nextTick, ref, watch } from "vue";
const props = defineProps({
  name: String,
  text: String,
  taglines: Array<string>
});
const hasHover = () => window.matchMedia("(hover: hover)").matches;
const showContent = ref(false);
const tagline = ref('');
watch(props, (newProps) => {
  pickTagline(newProps.taglines);
})
onMounted(() => {
  pickTagline(props.taglines);
  showContent.value = true;
  if (hasHover())
    void import( "lazy-lottie-player/lazy-tgs-player.mjs");
});
onUpdated(() => nextTick(hydrateIcons));
function pickTagline(newTaglines: string[] | undefined) {
  if (newTaglines !== undefined && newTaglines.length > 0) {
    const randomIndex = Math.floor(Math.random() * newTaglines.length);
    tagline.value = newTaglines[randomIndex];
  }
}
function hydrateIcons() {
  if (!hasHover()) return;
  document.querySelectorAll("lazy-tgs-player").forEach(player => {
    const box = player.closest(".box");
    if (!box) return;
    box.addEventListener("mouseenter", () => player.play?.());
    box.addEventListener("mouseleave", () => player.pause?.());
  });
}
</script>
<template>
  <h1 v-if="name" class="name">
    <span class="clip">{{ name }}</span>
  </h1>
  <p v-if="text" class="text">{{ text }}</p>
  <p class="tagline">…
    <span v-if="showContent" :key="tagline" class="tagline"> {{ tagline }}</span>
  </p>
</template>
⋮----
<span class="clip">{{ name }}</span>
⋮----
<p v-if="text" class="text">{{ text }}</p>
⋮----
<span v-if="showContent" :key="tagline" class="tagline"> {{ tagline }}</span>
⋮----
<style scoped>
.name,
.text {
  max-width: 392px;
  letter-spacing: -0.4px;
  line-height: 40px;
  font-size: 32px;
  font-weight: 700;
  white-space: pre-wrap;
}
.VPHero.has-image .name,
.VPHero.has-image .text {
  margin: 0 auto;
}
.name {
  color: var(--vp-home-hero-name-color);
}
@media (min-width: 640px) {
  .name,
  .text {
    max-width: 576px;
    line-height: 56px;
    font-size: 48px;
  }
}
@media (min-width: 960px) {
  .name,
  .text {
    line-height: 64px;
    font-size: 56px;
  }
  .VPHero.has-image .name,
  .VPHero.has-image .text {
    margin: 0;
  }
}
.tagline {
  padding-top: 8px;
  max-width: 392px;
  line-height: 28px;
  font-size: 18px;
  font-weight: 500;
  font-style: italic;
  white-space: pre-wrap;
  color: var(--vp-c-text-2);
}
.VPHero.has-image .tagline {
  margin: 0 auto;
}
@media (min-width: 640px) {
  .tagline {
    padding-top: 12px;
    max-width: 576px;
    line-height: 32px;
    font-size: 20px;
  }
}
@media (min-width: 960px) {
  .tagline {
    line-height: 36px;
    font-size: 24px;
  }
  .VPHero.has-image .tagline {
    margin: 0;
  }
}
</style>
</file>

<file path="site/docs/.vitepress/theme/layout/Layout.vue">
<script setup lang="ts">
import DefaultTheme from "vitepress/theme-without-fonts";
import { useData } from "vitepress";
import HomeHeroInfo from "./HomeHeroInfo.vue";
import { onMounted } from "vue";
import { polyfillCountryFlagEmojis } from "country-flag-emoji-polyfill";
const { Layout } = DefaultTheme as any;
const { frontmatter } = useData();
onMounted(() => polyfillCountryFlagEmojis());
</script>
<template>
  <Layout>
    <template #home-hero-info>
      <HomeHeroInfo :name="frontmatter.hero.name" :text="frontmatter.hero.text" :taglines="frontmatter.hero.taglines" />
    </template>
  </Layout>
</template>
⋮----
<template #home-hero-info>
      <HomeHeroInfo :name="frontmatter.hero.name" :text="frontmatter.hero.text" :taglines="frontmatter.hero.taglines" />
    </template>
</file>

<file path="site/docs/.vitepress/theme/style/_custom-block.scss">
:root {
  .tip.custom-block {
    color: var(--vp-c-green-dark);
    background-color: #e9f8fd;
  }
  .warning.custom-block {
    color: #ff8c1b;
    .custom-block-title {
      color: #ff8c1b;
    }
  }
  .danger.custom-block {
    color: #f33958;
  }
  &.dark {
    .tip.custom-block {
      color: #53c4ea;
      background-color: #06242f;
    }
    .warning.custom-block {
      .custom-block-title {
        color: #fdba29;
      }
      color: #fdba29;
      background-color: #272418;
    }
    .danger.custom-block {
      .custom-block-title {
        color: #f2183c;
      }
      background-color: #291c24;
    }
  }
}
.vp-doc .custom-block div[class*="language-"] {
  margin: 16px 0;
}
:root {
  .tip.custom-block code {
    color: #577e8e;
  }
  .warning.custom-block code {
    color: #e29945;
  }
  .danger.custom-block code {
    color: #f96e86;
  }
  .details.custom-block code {
    color: #8c8ba4;
  }
  &.dark {
    .tip.custom-block code {
      color: #5d9ab2;
    }
    .warning.custom-block code {
      color: #b89c47;
    }
  }
}
.tip.custom-block blockquote {
  --vp-c-divider: #bad7e3;
  p {
    color: #65a9c4;
    code {
      color: #577e8e;
    }
  }
  :root.dark & {
    --vp-c-divider: #517480;
    p {
      color: #6598a8;
    }
  }
}
.warning.custom-block blockquote {
  --vp-c-divider: #fad8b0;
  p {
    color: #e6a04f;
    code {
      color: #ae9c4a;
    }
  }
  :root.dark & {
    --vp-c-divider: #806f3e;
    p {
      color: #b59c50;
      code {
        color: #ae9c4a;
        background-color: #2a2923;
      }
    }
  }
}
.danger.custom-block blockquote {
  --vp-c-divider: #f2c9cc;
  p {
    color: #e48696;
    code {
      color: #e18389;
    }
  }
  :root.dark & {
    --vp-c-divider: #aa5056;
    p {
      color: #b55f65;
      code {
        color: #dc6d74;
        background-color: #2e1e22;
      }
    }
  }
}
.details.custom-block blockquote {
  p {
    color: #8c8ba4;
  }
  :root.dark & {
    --vp-c-divider: #575665;
    p {
      color: #8c8ba4;
    }
  }
}
.vp-doc div[class*="language-"] {
  border-radius: 8px;
  margin: 16px 0;
}
.vp-code-group .tabs {
  margin-left: 0;
  margin-right: 0;
  border-radius: 8px 8px 0 0;
}
</file>

<file path="site/docs/.vitepress/theme/style/_fonts.scss">
@font-face {
  font-family: InterVariable;
  font-style: normal;
  font-weight: 100 900;
  font-display: swap;
  src: url("/fonts/InterVariable.woff2") format("woff2");
}
@font-face {
  font-family: InterVariable;
  font-style: italic;
  font-weight: 100 900;
  font-display: swap;
  src: url("/fonts/InterVariable-Italic.woff2") format("woff2");
}
@font-face {
  font-display: swap;
  font-family: "Source Code Pro";
  font-style: normal;
  font-weight: 400;
  src: url("/fonts/source-code-pro-v22-cyrillic_cyrillic-ext_latin_latin-ext-regular.woff2")
    format("woff2");
}
h1,
h2,
h3,
h4,
h5,
h6,
th,
input:checked + label,
.VPNav .title,
.custom-block-title,
.outline-title {
  font-family:
    "Twemoji Country Flags",
    InterVariable,
    "Inter var",
    "Inter",
    ui-sans-serif,
    system-ui,
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    "Helvetica Neue",
    Helvetica,
    Arial,
    "Noto Sans",
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol",
    "Noto Color Emoji",
    Oxygen,
    Ubuntu,
    Cantarell,
    "Fira Sans",
    "Droid Sans",
    sans-serif;
}
</file>

<file path="site/docs/.vitepress/theme/style/_normalize.scss">
:root {
  code,
  a {
    hyphens: none;
  }
}
.VPDoc {
  p,
  li {
    text-align: justify;
    text-justify: auto;
    hyphens: auto;
  }
}
.VPHomeFeatures .box {
  .title {
    font-size: 1.2rem;
  }
  .details {
    font-size: 1rem;
  }
}
.VPHomeHero .VPButton.medium {
  font-size: 0.98rem;
}
:root .VPHome {
  margin-bottom: 0px;
}
:root .VPFeature .icon .VPImage {
  width: 32px;
  height: 32px;
  margin: 0;
}
:root
  .external-link-icon-enabled
  :is(.vp-doc a[href*="://"], .vp-doc a[target="_blank"])::after {
  content: "";
  margin-left: 2px;
}
:root
  :is(
    .vp-external-link-icon,
    .vp-doc a[href*=":
    .vp-doc a[target="_blank"]
  )::after {
  margin-left: 2px;
}
.NotFound .quote {
  max-width: 100%;
}
#home-content h2:first-child {
  margin-top: 3.5rem;
  padding-top: 2rem;
}
#home-footer {
  margin-top: 3rem;
  p {
    line-height: 1.3rem;
  }
}
.vp-doc {
  h4,
  h5,
  h6 {
    margin-top: 24px;
  }
}
.typeRef {
  text-decoration-color: #97e1f1 !important;
  &::after {
    content: none !important;
    display: none !important;
  }
}
p.src {
  margin: 0 !important;
  & > sup.src > a::after {
    content: none !important;
    display: none !important;
  }
}
</file>

<file path="site/docs/.vitepress/theme/style/_selection.scss">
::selection {
  background-color: #009dca44;
}
::selection:window-inactive,
::selection:-moz-window-inactive {
  background-color: #009dca22;
}
.VPButton {
  user-select: none;
}
</file>

<file path="site/docs/.vitepress/theme/style/_table.scss">
:root {
  tr:nth-child(2n) code {
    background-color: #eeeeee;
  }
  &.dark {
    tr:nth-child(2n) code {
      background-color: #2a2f36;
    }
  }
}
</file>

<file path="site/docs/.vitepress/theme/style/_vars.scss">
:root {
  --vp-c-green: #1793bc;
  --vp-c-green-dark: var(--vp-c-green);
  &.dark {
    --vp-c-yellow: #eaa102;
  }
}
:root {
  --vp-c-indigo-1: #009dca;
  --vp-c-indigo-2: #0094bd;
  --vp-c-indigo-3: #0089af;
  --vp-c-divider: #d1d4da;
  --vp-c-gutter: var(--vp-c-divider);
  &.dark {
    --vp-c-bg: #181a1e;
    --vp-c-bg-elv: var(--vp-c-mute-dark);
    --vp-c-bg-elv-mute: var(
      --vp-c-bg-soft-down
    );
    --vp-c-bg-soft: #1f2329;
    --vp-c-bg-soft-down: #2b333c;
    --vp-c-bg-alt: #101114;
    --vp-c-indigo-2: #0089af;
    --vp-c-indigo-3: #006783;
    --vp-c-divider: #363a43;
    --vp-c-gutter: var(--vp-c-divider);
    --vp-c-mute: #23272d;
    --vp-c-mute-dark: #1e2228;
    --vp-c-mute-darker: #191c22;
  }
}
:root {
  --vp-font-family-base:
    "Twemoji Country Flags", InterVariable, "Inter var", "Inter", ui-sans-serif,
    system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    "Helvetica Neue", Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji",
    "Segoe UI Symbol", "Noto Color Emoji", Oxygen, Ubuntu, Cantarell,
    "Fira Sans", "Droid Sans", sans-serif;
  --vp-font-family-mono:
    "Source Code Pro", "SF Mono", Consolas, Monaco, "Andale Mono",
    "Ubuntu Mono", monospace;
}
:root {
  --vp-code-color: #476582;
  &.dark {
    --vp-code-color: #c9def1;
  }
}
:root {
  --vp-custom-block-tip-code-bg: #5bdbfe1c;
  --vp-custom-block-warning-code-bg: #fef3e6;
  --vp-custom-block-danger-code-bg: #f43f5d16;
  --vp-custom-block-details-code-bg: #ededee;
  &.dark {
    --vp-custom-block-details-bg: #242429;
    --vp-custom-block-details-code-bg: #313137;
    --vp-custom-block-tip-bg: #171d21;
    --vp-custom-block-tip-code-bg: #29a9ff14;
    --vp-custom-block-warning-bg: #21211f;
    --vp-custom-block-warning-code-bg: #eaa10216;
    --vp-custom-block-danger-bg: #21191d;
  }
}
</file>

<file path="site/docs/.vitepress/theme/style/index.scss">
@use "vars";
@use "normalize";
@use "selection";
@use "fonts";
@use "custom-block";
@use "table";
</file>

<file path="site/docs/.vitepress/theme/index.ts">
import DefaultTheme from "vitepress/theme-without-fonts";
import Layout from "./layout/Layout.vue";
⋮----
import type { EnhanceAppContext } from "vitepress";
import ThankYou from "../components/ThankYou.vue";
import LanguagePopup from "../components/LanguagePopup.vue";
import NotFound from "../components/NotFound.vue";
⋮----
enhanceApp(ctx: EnhanceAppContext)
</file>

<file path="site/docs/.vitepress/config.ts">
import { defineConfig } from "vitepress";
import { algolia } from "./configs/algolia/index.ts";
⋮----
import { markdown } from "./plugins/index.ts";
import plaintext from "./shared/syntaxes/plaintext.tmLanguage.json" with {
  type: "json",
};
import env from "./shared/syntaxes/env.tmLanguage.json" with { type: "json" };
</file>

<file path="site/docs/advanced/business.md">
# Telegram Business

Telegram Business allows your private chat with another (human) user to be managed by a bot.
This includes sending and receiving messages on your behalf.
Typically, this is useful if you run your business on Telegram, and that other user is a customer.

> If you are not familiar with Telegram Business yet, check out the [official docs](https://core.telegram.org/bots#manage-your-business) by Telegram before you continue.

Naturally, grammY has full support for this.

## Handling Business Messages

A bot can manage a private chat between two users via Telegram Business---an account that is subscribed to Telegram's business subscription.
Managing private chats is done via a _business connection_ object that looks like [this](/ref/types/businessconnection).

### Receiving Business Messages

Once a business connection was set up, the bot will **receive messages** from _both chat participants_.

```ts
bot.on("business_message", async (ctx) => {
  // Access the message object.
  const message = ctx.businessMessage;
  // Shortcuts work as expected.
  const msg = ctx.msg;
});
```

At this point, it is not clear who of the two chat participants sent a message.
It could be a message by your customer---but it could also be a message sent by yourself (not your bot)!

Thus, we need to differentiate between the two users.
For this, we need to inspect the aforementioned business connection object.
The business connection tells us who is the business account user, i.e. the user identifier of you (or one of your employees).

```ts
bot.on("business_message", async (ctx) => {
  // Get information about the business connection.
  const conn = await ctx.getBusinessConnection();
  const employee = conn.user;
  // Check who sent this message.
  if (ctx.from.id === employee.id) {
    // You sent this message.
  } else {
    // Your customer sent this message.
  }
});
```

You can also skip calling `getBusinessConnection` for every update by doing [this](#working-with-business-connections).

### Sending Messages

Your bot is able to **send messages** to this chat _without being a member of the chat_.
It works as expected with `ctx.reply` and all of its variants.
grammY checks if the [context shortcut](../guide/context#shortcuts) `ctx.businessConnectionId` is available, so it can send the message to the managed business chat.

```ts
bot.on("business_message").filter(
  async (ctx) => {
    const conn = await ctx.getBusinessConnection();
    return ctx.from.id !== conn.user.id;
  },
  async (ctx) => {
    // Automatically respond to all customer questions.
    if (ctx.msg.text.endsWith("?")) {
      await ctx.reply("Soon.");
    }
  },
);
```

This will look as if you had sent the message yourself.
There is no way to tell for your customer whether the message was sent manually or via your bot.
(You will see a small indicator for this, though.)
(But your bot is probably much faster at replying than you.
Sorry.)

## Going Further

There are a few more things to consider when integrating your bot with Telegram Business.
We will cover a few aspects here briefly.

### Editing or Deleting Business Messages

When you or your customer edit or delete messages in your chat, your bot will be notified of this.
More specifically, you will receive `edited_business_message` or `deleted_business_messages` updates.
Your bot can handle them the normal way using `bot.on` and its countless [filter queries](../guide/filter-queries).

However, your bot is **NOT** able edit or delete messages in the chat.
Similarly, your bot is **NOT** able to forward messages from the chat, or copy them elsewhere.
All of these things are left to humans.

### Working With Business Connections

When the bot is connected to a business account, it will receive a `business_connection` update.
This update will also be received when the bot is disconnected or the connection is edited in a different way.

For example, a bot may or may not be able to send messages to the chats it manages.
You can catch this using the `:can_reply` query part.

```ts
bot.on("business_connection:can_reply", async (ctx) => {
  // Connection allows sending messages.
});
```

It makes a lot of sense to store business connection objects in your database.
That way, you can avoid calling `ctx.getBusinessConnection()` for every update only to [find out who sent a message](#receiving-business-messages).

Moreover, a `business_connection` update contains a `user_chat_id`.
This chat identifier can be used to initate a conversation with the user who connected the bot.

```ts
bot.on("business_connection:is_enabled", async (ctx) => {
  const id = ctx.businessConnection.user_chat_id;
  await ctx.api.sendMessage(id, "Thanks for connecting me!");
});
```

This works even if the user has not started your bot yet.

### Managing Individual Chats

If you connect a bot to manage your account, Telegram apps will offer you a button to manage this bot in each managed chat.
This button sends `/start` to the bot.

This start command has a special [deep linking](../guide/commands#deep-linking-support) payload defined by Telegram.
It has the format `bizChatXXXXX` where `XXXXX` will be the chat identifier of the managed chat.

```ts
bot.command("start", async (ctx) => {
  const payload = ctx.match;
  if (payload.startsWith("bizChat")) {
    const id = payload.slice(7); // strip `bizChat`
    await ctx.reply(`Let's manage chat #${id}!`);
  }
});
```

This gives important context to your bot and enables it to manage individual business chats right from the conversation with each customer.
</file>

<file path="site/docs/advanced/deployment.md">
# Deployment Checklist

Here is a list of things that you may want to keep in mind when hosting a large bot.

> You may also be interested in our guides for hosting a bot.
> Check out **Hosting / Tutorials** at the top of the page to see some of the platforms that already have dedicated guides.

## Errors

1. [Install an error handler with `bot.catch` (long polling) or on your web framework (webhooks).](../guide/errors)
2. Use `await` on all promises and install **linting**, with rules that enforce this, so that you never forget.

## Message Sending

1. Send files by path or `Buffer` instead of by stream, or at least make sure you [know the pitfalls](./transformers#use-cases-of-transformer-functions).
2. Use `bot.on("callback_query:data")` as the fallback handler to [react to all callback queries](../plugins/keyboard#responding-to-inline-keyboard-clicks).
3. Use the [`auto-retry` plugin](../plugins/auto-retry) to automatically handle flood wait errors.

## Scaling

This depends on your deployment type.

### Long Polling

1. [Use grammY runner.](../plugins/runner)
2. [Use `sequentialize` with the same session key resolver function as your session middleware.](./scaling#concurrency-is-hard)
3. Go through the configuration options of `run` ([API reference](/ref/runner/run)) and make sure they fit your needs, or even consider composing your own runner out of [sources](/ref/runner/updatesource) and [sinks](/ref/runner/updatesink).
   The main thing to consider is the maximum load you want to apply to your server, i.e. how many updates may be processed at the same time.
4. Consider implementing [graceful shutdown](./reliability#graceful-shutdown) in order to stop your bot when you want to terminate it (i.e. to switch to a new version).

### Webhooks

1. Make sure you do not perform any long-running operations in your middleware, such as large file transfers.
   [This leads to timeout errors](../guide/deployment-types#ending-webhook-requests-in-time) for the webhooks, and duplicate update processing as Telegram will re-send non-acknowledged updates.
   Consider using a task queuing system instead.
2. Make yourself familiar with the configuration of `webhookCallback` ([API reference](/ref/core/webhookcallback)).
3. If you adjusted the `getSessionKey` option for your session, [use `sequentialize` with the same session key resolver function as your session middleware](./scaling#concurrency-is-hard).
4. If you are running on a serverless or autoscaling platform, [set the bot information](/ref/core/botconfig) to prevent excessive `getMe` calls.
5. Consider using [webhook replies](../guide/deployment-types#webhook-reply).

## Sessions

1. Consider using `lazySessions` as explained [here](../plugins/session#lazy-sessions).
2. Use the `storage` option to set your storage adapter, otherwise all data will be lost when the bot process stops.

## Testing

Write tests for your bot.
This can be done with grammY like so:

1. Mock outgoing API requests using [transformer functions](./transformers).
2. Define and send sample update objects to your bot via `bot.handleUpdate` ([API reference](/ref/core/bot#handleupdate)).
   Consider to take some inspiration from these [update objects](https://core.telegram.org/bots/webhooks#testing-your-bot-with-updates) provided by the Telegram team.

::: tip Contribute a Testing Framework
While grammY provides the necessary hooks to start writing tests, it would be very helpful to have a testing framework for bots.
This is novel territory, such testing frameworks largely do not exist.
We look forward to your contributions!

An example on how tests could be done [can be found here](https://github.com/PavelPolyakov/grammy-with-tests).
:::
</file>

<file path="site/docs/advanced/flood.md">
# Scaling Up IV: Flood Limits

Telegram limits how many messages your bot can send each second.
This means that any API request you perform could error with status code 429 (Too Many Requests) and a `retry_after` header as specified [here](https://core.telegram.org/bots/api#responseparameters).
This can happen anytime.

There is only one correct way to handle these situations:

1. Wait for the specified number of seconds.
2. Retry the request.

Fortunately, there is a [plugin](../plugins/auto-retry) for that.

That plugin is [very simple](https://github.com/grammyjs/auto-retry/blob/main/src/mod.ts).
It literally just sleeps and retries.
However, using it has a major implication: **any request can be slow**.
This means that when you run your bot on webhooks, [you technically have to use a queue](../guide/deployment-types#ending-webhook-requests-in-time) no matter what you do, or else you need to configure the auto-retry plugin in a way that it never takes a lot of time---but then your bot may skip some requests.

## What the Exact Limits Are

They are unspecified.

Deal with it.

We have some good ideas about how many requests you can perform, but the exact numbers are unknown.
(If someone tells you the actual limits, they are not well-informed.)
The limits are not simply hard thresholds that you can find out by experimenting with the Bot API.
Rather, they are flexible constraints that change based on your bot's exact request payloads, the number of users, and other factors, not all of which are known.

Here are a few misconceptions and false assumptions about rate limits.

- My bot is too new to receive flood wait errors.
- My bot does not get enough traffic to receive flood wait errors.
- This feature of my bot is not used enough to receive flood wait errors.
- My bot leaves enough time between API calls so it will not receive flood wait errors.
- This particular method call cannot receive flood wait errors.
- `getMe` cannot receive flood wait errors.
- `getUpdates` cannot receive flood wait errors.

All of these are wrong.

Let's get to the things we _do_ know.

## Safe Assumptions About Rate Limits

From the [Bot FAQ](https://core.telegram.org/bots/faq#my-bot-is-hitting-limits-how-do-i-avoid-this), we know a few limits that cannot be exceeded, ever.

1. _"When sending messages inside a particular chat, avoid sending more than one message per second. We may allow short bursts that go over this limit, but eventually you'll begin receiving 429 errors."_

   This one should be pretty clear. The auto-retry plugin handles this for you.

2. _"If you're sending bulk notifications to multiple users, the API will not allow more than 30 messages per second or so. Consider spreading out notifications over large intervals of 8—12 hours for best results."_

   **This only applies to bulk notifications,** i.e. if you proactively message many users.
   If you are just responding to messages from users, then it is no problem to send 1,000 or more messages per second.

   When the Bot FAQ says that you should _"consider spreading out notifications over large intervals"_, this does not mean that you should add any artificial delays.
   Instead, the main takeaway here is that sending bulk notifications is a process that will take many hours.
   You cannot expect to message all users instantly at the same time.

3. _"Also note that your bot will not be able to send more than 20 messages per minute to the same group."_

   Again, pretty clear.
   Completely unrelated to bulk notifications or how many messages are sent in the group.
   And yet again, the auto-retry plugin will take care of this for you.

There are a few other known limits that were revealed outside of the official Bot API documentation.
For example, [it is known](https://t.me/tdlibchat/146123) that bots can only do up to 20 message edits in a minute per group chat.
However, this is the exception, and we also have to assume that these limits may be changed in the future.
Thus, this information does not affect how to program your bot.

For instance, throttling your bot based on these numbers is still a bad idea:

## Throttling

Some think that it is bad to run into rate limits.
They prefer to know the exact limits so they can throttle their bot.

This is incorrect.
Rate limits are a tool useful for flood control, and if you act accordingly, they won't have any negative impacts on your bot.
That is to say, hitting rate limits does not lead to bans.
Ignoring them does.

What's more, [according to Telegram](https://t.me/tdlibchat/47285), it is "useless and harmful" to know the exact limits.

It is _useless_ because even if you knew the limits, you would still have to handle flood wait errors.
For example, the Bot API server returns 429 while it shuts down in order to reboot during maintenance.

It is _harmful_ because if you were to artificially delay some requests in order to avoid hitting limits, the performance of your bot would be far from optimal.
This is why you should always make your requests as fast as possible but respect all flood wait errors (using the auto-retry plugin).

But if it is bad to throttle requests, how can you do broadcasting?

## How to Broadcast Messages

Broadcasting can be done following a very simple approach.

1. Send a message to a user.
2. If you receive 429, wait and retry.
3. Repeat.

Do not add artificial delays.
(They make broadcasting slower.)

Do not ignore 429 errors.
(This could lead to a ban.)

Do not send many messages in parallel.
(You can send very few messages in parallel (maybe 3 or so) but this can be challenging to implement.)

Step 2 in the above list is done automatically by the auto-retry plugin, so the code will look like this:

```ts
bot.api.config.use(autoRetry());

for (const [chatId, text] of broadcast) {
  await bot.api.sendMessage(chatId, text);
}
```

The interesting part here is what `broadcast` will be.
You need to have all your chats stored in some database, and you need to be able to slowly fetch all of them.

Currently, you will have to implement this logic yourself.
In the future, we want to create a broadcasting plugin.
We would be happy to take your contributions!
Join us [here](https://t.me/grammyjs).

### Can I Pay for Increased Rate Limits?

Yes.

> This section is only relevant if your bot has at least 10,000 Telegram Stars in its balance.

When you broadcast a lot of messages, you put a lot of load on the Telegram infrastructure.
Consequently, if you want Telegram to increase the limits, you need to compensate them for the traffic you generate.
(Most likely, you will also pay a bit extra.)

[Paid broadcasts](https://core.telegram.org/bots/api#paid-broadcasts) let you use your balance in [Telegram Stars](https://t.me/BotNews/90) to increase your bot's rate limits.
You will then be able to send **up to 1000 messages per second**.

1. Enable _Paid Broadcasts_ with [@BotFather](https://t.me/BotFather).
2. You can use the same code as for normal broadcasts.
   After all, you still have to respect rate limits the same way, even if the limits are much higher now.
   However, you need to perform several API calls concurrently for a much higher throughput.
3. Specify `allow_paid_broadcast` in every API call.

Step 2 implies that you should use a queue that lets you perform the tasks with a certain degree of concurrency.
If you use too little concurrency, your throughput will be lower than 1000 messages per second.
If you use too much of it, you will run into rate limits faster than necessary.
Also, if you have a lot of concurrent calls to `sendMessage`, and one of them receives 429, then all the other outgoing requests will effectively ignore this rate limit.
As a result, Telegram will impose an even longer cooldown period on you.

The right number of concurrent calls can be picked by looking at the average time it takes to send a message.
For example, if this average value is 57 milliseconds, you should aim at performing 57 concurrent calls to `sendMessage` at all times.
</file>

<file path="site/docs/advanced/middleware.md">
# Middleware Redux

In the Guide, [we introduced middleware](../guide/middleware) as a stack of functions.
While it is not wrong that you can use middleware in this linear fashion (also in grammY), calling it just a stack is a simplification.

## Middleware in grammY

Commonly, you see the following pattern.

```ts
const bot = new Bot("");

bot.use(/* ... */);
bot.use(/* ... */);

bot.on(/* ... */);
bot.on(/* ... */);
bot.on(/* ... */);

bot.start();
```

Looks pretty much like a stack, except, behind the scenes, it really is a tree.
The heart of this functionality is the `Composer` class ([reference](/ref/core/composer)) that builds up this tree.

First of all, every instance of `Bot` is an instance of `Composer`.
It's just a subclass, so `class Bot extends Composer`.

Also, you should know that every single method of `Composer` internally calls `use`.
For example, `filter` just calls `use` with some branching middleware, while `on` just calls `filter` again with some predicate function that matches updates against the given [filter query](../guide/filter-queries).
We can therefore limit ourselves to looking at `use` for now, and the rest follows.

We now have to dive a bit into the details of what `Composer` does with your `use` calls, and how it differs from other middleware systems out there.
The difference may seem subtle, but wait until the next subsection to find out why it has remarkable consequences.

## Augmenting `Composer`

You can install more middleware on an instance of `Composer` even after installing the `Composer` itself somewhere.

```ts
const bot = new Bot(""); // subclass of `Composer`

const composer = new Composer();
bot.use(composer);

// These will be run:
composer.use(/* A */);
composer.use(/* B */);
composer.use(/* C */);
```

`A`, `B`, and `C` will be run.
All this says is that once you have installed an instance of `Composer`, you can still call `use` on it and this middleware will still be run.
(This is nothing spectacular, but already a main difference to popular competing frameworks that simply ignore subsequent operations.)

You may be wondering where the tree structure is in there.
Let's have a look at this snippet:

```ts
const composer = new Composer();

composer.use(/* A */);
composer.use(/* B */).use(/* C */);
composer.use(/* D */).use(/* E */).use(/* F */).use(/* G */);
composer.use(/* H */).use(/* I */);
composer.use(/* J */).use(/* K */).use(/* L */);
```

Can you see it?

As you can guess, all middleware will be run in order from `A` to `L`.

Other libraries would internally flatten this code to be equivalent to `composer.use(/* A */).use(/* B */).use(/* C */).use(/* D */)...` and so on.
On the contrary, grammY preserves the tree you specified: one root node (`composer`) has five children (`A`, `B`, `D`, `H`, `J`), while the child `B` has one other child, `C`, etc.
This tree will then be traversed by every update in depth-first order, hence effectively passing through `A` to `L` in linear order, much like what you know from other systems.

This is made possible by creating a new instance of `Composer` every time you call `use` that will in turn be extended (as explained above).

## Concatenating `use` Calls

If we only used `use`, this would not be too useful (pun intended).
It gets more interesting as soon as e.g. `filter` comes into play.

Check this out:

```ts
const composer = new Composer();

composer.filter(/* 1 */, /* A */).use(/* B */)

composer.filter(/* 2 */).use(/* C */, /* D */)
```

On line 3, we register `A` behind a predicate function `1`.
`A` will only be evaluated for updates which pass the condition `1`.
However, `filter` returns a `Composer` instance that we augment with the `use` call on line 3, so `B` is still guarded by `1`, even though it is installed in a completely different `use` call.

Line 5 is equivalent to line 3 in the respect that both `C` and `D` will only be run if `2` holds.

Remember how `bot.on()` calls could be chained in order to concatenate filter queries with AND?
Imagine this:

```ts
const composer = new Composer();

composer.filter(/* 1 */).filter(/* 2 */).use(/* A */);
```

`2` will only be checked if `1` holds, and `A` will only be run if `2` (and thus `1`) holds.

Revisit the section about [combining filter queries](../guide/filter-queries#combining-multiple-queries) with your new knowledge and feel your new power.

A special case here is `fork`, as it starts two computations that are concurrent, i.e. interleaved on the event loop.
Instead of returning the `Composer` instance created by the underlying `use` call, it returns a `Composer` that reflects the forked computation.
This allows for concise patterns like `bot.fork().on(":text").use(/* A */)`.
`A` will now be executed on the parallel computation branch.
</file>

<file path="site/docs/advanced/proxy.md">
# Proxy Support

grammY lets you configure a number of things about how network requests are performed.
This includes injecting a custom payload into every request, which can be used to install a proxy agent.
Check out the `ApiClientOptions` in the [grammY API Reference](/ref/core/apiclientoptions).

In Deno, here is how you would use an `http` proxy:

```ts
import { Bot } from "https://deno.land/x/grammy/mod.ts";

const client = Deno.createHttpClient({
  proxy: { url: "http://host:port/" },
});
const bot = new Bot("", {
  client: {
    baseFetchConfig: {
      // @ts-ignore
      client,
    },
  },
});
```

> Note that you need to run this with the `--unstable` flag.

In Node.js, here is how you would use a proxy with the `socks-proxy-agent` package ([npm](https://www.npmjs.com/package/socks-proxy-agent)):

```ts
import { Bot } from "grammy";
import { SocksProxyAgent } from "socks-proxy-agent";

const socksAgent = new SocksProxyAgent({
  hostname: host, // put in the proxy host
  port: port, // put in the proxy port
});

const bot = new Bot("", {
  client: {
    baseFetchConfig: {
      agent: socksAgent,
      compress: true,
    },
  },
});
```

> Note that specifying `compress: true` is an optional performance optimization.
> It has nothing to do with proxy support.
> It is part of the default value for `baseFetchConfig`, so if you still want it, you should specify it again.

Getting a proxy to work can be difficult.
Contact us in the [Telegram chat](https://t.me/grammyjs) if you run into issues, or if you need grammY to support further configuration options.
We also have a [Russian Telegram chat](https://t.me/grammyjs_ru).
</file>

<file path="site/docs/advanced/README.md">
---
prev: false
---

# Overview: Advanced Topics

When your bot becomes more popular, you may run into more complex issues than just making your bot work at all.

This section of the docs will start out with a deep dive into [grammY's middleware system](./middleware), which will allow you to write more sophisticated message handling than commonly necessary.

The next four chapters care about scaling up.
Read [Part I](./structuring) if your code gets very complex.
Read [Part II](./scaling) if you have to process a lot of messages.
Read [Part III](./reliability) if you worry about the reliability of your bot.
Read [Part IV](./flood) if you are hitting rate limits, i.e. getting 429 errors.

If you need to intercept and transform API requests on the fly, grammY offers you to do this by installing [transformer functions](./transformers).

grammY also has [proxy support](./proxy).

Last but not least, we compiled a [list of a few things that you should keep in mind](./deployment) when deploying your bot.
There is nothing new in there, it's just a bunch of things about potential traps, all in a central place for you to go through.
Maybe it let's you sleep better at night.
</file>

<file path="site/docs/advanced/reliability.md">
# Scaling Up III: Reliability

If you made sure you have proper [error handling](../guide/errors) for your bot, you are basically good to go.
All errors that should be expected to happen (failing API calls, failing network requests, failing database queries, failing middleware, etc) are all caught.

You should make sure to always `await` all promises, or at least call `catch` on them if you ever don't want to `await` stuff.
Use a linting rule to make sure you cannot forget this.

## Graceful Shutdown

For bots that are using long polling, there is one more thing to consider.
As you are going to stop your instance during operation at some point again, you should consider catching `SIGTERM` and `SIGINT` events, and call `bot.stop` (built-in long polling) or stop your bot via its [handle](/ref/runner/runnerhandle#stop) (grammY runner):

### Simple Long Polling

::: code-group

```ts [TypeScript]
import { Bot } from "grammy";

const bot = new Bot("");

// Stopping the bot when the Node.js process
// is about to be terminated
process.once("SIGINT", () => bot.stop());
process.once("SIGTERM", () => bot.stop());

await bot.start();
```

```js [JavaScript]
const { Bot } = require("grammy");

const bot = new Bot("");

// Stopping the bot when the Node.js process
// is about to be terminated
process.once("SIGINT", () => bot.stop());
process.once("SIGTERM", () => bot.stop());

await bot.start();
```

```ts [Deno]
import { Bot } from "https://deno.land/x/grammy/mod.ts";

const bot = new Bot("");

// Stopping the bot when the Deno process
// is about to be terminated
Deno.addSignalListener("SIGINT", () => bot.stop());
Deno.addSignalListener("SIGTERM", () => bot.stop());

await bot.start();
```

:::

### Using grammY runner

::: code-group

```ts [TypeScript]
import { Bot } from "grammy";
import { run } from "@grammyjs/runner";

const bot = new Bot("");

const runner = run(bot);

// Stopping the bot when the Node.js process
// is about to be terminated
const stopRunner = () => runner.isRunning() && runner.stop();
process.once("SIGINT", stopRunner);
process.once("SIGTERM", stopRunner);
```

```js [JavaScript]
const { Bot } = require("grammy");
const { run } = require("@grammyjs/runner");

const bot = new Bot("");

const runner = run(bot);

// Stopping the bot when the Node.js process
// is about to be terminated
const stopRunner = () => runner.isRunning() && runner.stop();
process.once("SIGINT", stopRunner);
process.once("SIGTERM", stopRunner);
```

```ts [Deno]
import { Bot } from "https://deno.land/x/grammy/mod.ts";
import { run } from "https://deno.land/x/grammy_runner/mod.ts";

const bot = new Bot("");

const runner = run(bot);

// Stopping the bot when the Deno process
// is about to be terminated
const stopRunner = () => runner.isRunning() && runner.stop();
Deno.addSignalListener("SIGINT", stopRunner);
Deno.addSignalListener("SIGTERM", stopRunner);
```

:::

That's basically all there is to reliability, your instance should:registered: never:tm: crash now.

## Reliability Guarantees

What if your bot is processing financial transactions and you must consider a [`kill -9` scenario](https://stackoverflow.com/questions/43724467/what-is-the-difference-between-kill-and-kill-9) where the CPU physically breaks or there is a power outage in the data center?
If for some reason someone or something actually hard-kills the process, it gets a bit more complicated.

In essence, bots cannot guarantee an _exactly once_ execution of your middleware.
Read this [discussion](https://github.com/tdlib/telegram-bot-api/issues/126) on GitHub in order to learn more about **why** your bot could send duplicate messages (or none at all) in extremely rare cases.
The remainder of this section is elaborating on **how** grammY behaves under these unusual circumstances, and how to handle these situations.

> Do you just care about coding a Telegram bot? [Skip the rest of this page.](./flood)

### Webhook

If you are running your bot on webhooks, the Bot API server will retry delivering updates to your bot if it does not respond with `OK` in time.
That pretty much defines the behavior of the system comprehensively---if you need to prevent processing duplicate updates, you should build your own de-duplication based on `update_id`.
grammY does not do this for you, but feel free to PR if you think someone else could profit from this.

### Long Polling

Long polling is more interesting.
The built-in polling basically re-runs the most recent update batch that was fetched but could not complete.

> Note that if you properly stop your bot with `bot.stop`, the [update offset](https://core.telegram.org/bots/api#getting-updates) will be synced with the Telegram servers by calling `getUpdates` with the correct offset but without processing the update data.

In other words, you will never loose any updates, however, it may happen that you re-process up to 100 updates that you have seen before.
As calls to `sendMessage` are not idempotent, users may receive duplicate messages from your bot.
However, _at least once_ processing is guaranteed.

### grammY Runner

If you are using the [grammY runner](../plugins/runner) in concurrent mode, the next `getUpdates` call is potentially performed before your middleware processes the first update of the current batch.
Thus, the update offset is [confirmed](https://core.telegram.org/bots/api#getupdates) prematurely.
This is the cost of heavy concurrency, and unfortunately, it cannot be avoided without reducing both throughput and responsiveness.
As a result, if your instance is killed in the right (wrong) moment, it could happen that up to 100 updates cannot be fetched again because Telegram regards them as confirmed.
This leads to data loss.

If it is crucial to prevent this, you should use the sources and sinks of the grammY runner package to compose your own update pipeline that passes all updates through a message queue first.

1. You'd basically have to create a [sink](/ref/runner/updatesink) that pushes to the queue, and start one runner that only supplies your message queue.
2. You'd then have to create a [source](/ref/runner/updatesource) that pulls from the message queue again.
   You will effectively run two different instances of the grammY runner.

This vague draft described above has only been sketched but not implemented, according to our knowledge.
Please [take contact with the Telegram group](https://t.me/grammyjs) if you have any question or if you attempt this and can share your progress.

On the other hand, if your bot is under heavy load and the update polling is slowed down due to the [automatic load constraints](../plugins/runner#sink), chances are increasing that some updates will be fetched again, which leads to duplicate messages again.
Thus, the price of full concurrency is that neither _at least once_ nor _at most once_ processing can be guaranteed.
</file>

<file path="site/docs/advanced/scaling.md">
# Scaling Up II: High Load

Making your bot able to handle high load depends on whether you run your bot [via long polling or via webhooks](../guide/deployment-types).
Either way, you should read up on some pitfalls [below](#concurrency-is-hard).

## Long Polling

Most bots never need to process more than a handful of messages per minute (during "peak load").
In other words, scalability is not a concern for them.
In order to be predictable, grammY is processing updates sequentially.
This is the order of operations:

1. Fetch up to 100 updates via `getUpdates` ([Telegram Bot API Reference](https://core.telegram.org/bots/api#getupdates))
2. For every update, `await` the middleware stack for it

However, if your bot processes one message per second (or something like that) during load peaks, this can begin to impact the responsiveness negatively.
For instance, the message of Bob has to wait until the message of Alice is done processing.

This can be solved by not waiting for Alice's message to be done processing, i.e. processing both messages concurrently.
In order to achieve maximum responsiveness, we'd also like to pull in new messages while the messages of Bob and Alice are still processing.
Ideally, we would also like to limit the concurrency to some fixed number to constrain the maximum server load.

Concurrent processing is not shipped with the grammY core package.
Instead, **the [grammY runner](../plugins/runner) package can be used** to run your bot.
It supports all of the above out of the box, and it is extremely simple to use.

```ts
// Previously
bot.start();

// With grammY runner, which exports `run`.
run(bot);
```

The default concurrency limit is 500.
If you want to dig deeper into the package, check out this [page](../plugins/runner).

Concurrency is hard, so check out the [subsection below](#concurrency-is-hard) to find out what you should keep in mind when using grammY runner.

## Webhooks

If you run your bot on webhooks, it will automatically process updates concurrently as soon as they are received.
Naturally, in order for this to work well under high load, you should make yourself familiar with [using webhooks](../guide/deployment-types#how-to-use-webhooks).
This means that you still have to be aware of some consequences of concurrency, confer the [subsection below](#concurrency-is-hard).

Also, [remember that](../guide/deployment-types#ending-webhook-requests-in-time) Telegram will deliver updates from the same chat in sequence, but updates from different chats concurrently.

## Concurrency Is Hard

If your bot processes all updates concurrently, this can cause a number of problems that need special attention.
For example, if two messages from the same chat end up being received by the same `getUpdates` call, they would be processed concurrently.
The order of messages inside the same chat can no longer be guaranteed.

The main point where this can clash is when you use [sessions](../plugins/session), which may run into a write-after-read hazard.
Imagine this sequence of events:

1. Alice sends message A
2. Bot begins processing A
3. Bot reads session data for Alice from database
4. Alice sends message B
5. Bot begins processing B
6. Bot reads session data for Alice from database
7. Bot is done processing A, and writes new session to database
8. Bot is done processing B, and writes new session to database, hence overwriting the changes performed during processing A.
   Data loss due to WAR hazard!

> Note: You could try to use database transactions for your sessions, but then you can only detect the hazard and not prevent it.
> Trying to use a lock instead would effectively eliminate all concurrency.
> It is much easier to avoid the hazard in the first place.

Most other session systems of web frameworks simply accept the risk of race conditions, as they do not happen too frequently on the web.
However, we do not want this because Telegram bots are much more likely to experience clashes of parallel requests for the same session key.
Hence, we have to make sure that updates that access the same session data are processed in sequence in order to avoid this dangerous race condition.

grammY runner ships with `sequentialize()` middleware which makes sure that updates that clash are processed in sequence.
You can configure it with the very same function that you use to determine the session key.
It will then avoid the above race condition by slowing down those (and only those) updates that would cause a collision.

::: code-group

```ts [TypeScript]
import { Bot, Context, session } from "grammy";
import { run, sequentialize } from "@grammyjs/runner";

// Create a bot.
const bot = new Bot("");

// Build a unique identifier for the `Context` object.
function getSessionKey(ctx: Context) {
  return ctx.chat?.id.toString();
}

// Sequentialize before accessing session data!
bot.use(sequentialize(getSessionKey));
bot.use(session({ getSessionKey }));

// Add the usual middleware, now with safe session support.
bot.on("message", (ctx) => ctx.reply("Got your message."));

// Still run it concurrently!
run(bot);
```

```js [JavaScript]
const { Bot, Context, session } = require("grammy");
const { run, sequentialize } = require("@grammyjs/runner");

// Create a bot.
const bot = new Bot("");

// Build a unique identifier for the `Context` object.
function getSessionKey(ctx) {
  return ctx.chat?.id.toString();
}

// Sequentialize before accessing session data!
bot.use(sequentialize(getSessionKey));
bot.use(session({ getSessionKey }));

// Add the usual middleware, now with safe session support.
bot.on("message", (ctx) => ctx.reply("Got your message."));

// Still run it concurrently!
run(bot);
```

```ts [Deno]
import { Bot, Context, session } from "https://deno.land/x/grammy/mod.ts";
import { run, sequentialize } from "https://deno.land/x/grammy_runner/mod.ts";

// Create a bot.
const bot = new Bot("");

// Build a unique identifier for the `Context` object.
function getSessionKey(ctx: Context) {
  return ctx.chat?.id.toString();
}

// Sequentialize before accessing session data!
bot.use(sequentialize(getSessionKey));
bot.use(session({ getSessionKey }));

// Add the usual middleware, now with safe session support.
bot.on("message", (ctx) => ctx.reply("Got your message."));

// Still run it concurrently!
run(bot);
```

:::

Feel free to join the [Telegram chat](https://t.me/grammyjs) to discuss how to use grammY runner with your bot.
We are always happy to hear from people who maintain large bots so we can improve grammY based on their experience with the package.
</file>

<file path="site/docs/advanced/structuring.md">
# Scaling Up I: Large Codebase

As soon as your bot grows in complexity, you are going to face the challenge of how to structure your application code base.
Naturally, you can split it across files.

## Possible Solution

> grammY is still pretty young and does not provide any official integrations with DI containers yet.
> Subscribe to [@grammyjs_news](https://t.me/grammyjs_news) to be notified as soon as we support this.

You are free to structure your code however you like, and there is no one-size-fits-all solution.
That being said, a straightforward and proven strategy to structure your code is the following.

1. Group things that semantically belong together in the same file (or, depending on the code size, directory).
   Every single one of these parts exposes middleware that will handle the designated messages.
2. Create a bot instance centrally that merges all middleware by installing it onto the bot.
3. (Optional.) Pre-filter the updates centrally, and send down updates the right way only.
   You may also want to check out `bot.route` ([API Reference](/ref/core/composer#route)) or alternatively the [router plugin](../plugins/router) for that.

A runnable example that implements the above strategy can be found in the [Example Bot repository](https://github.com/grammyjs/examples/tree/main/scaling).

## Example Structure

For a very simple bot that manages a TODO list, you could imagine this structure.

```asciiart:no-line-numbers
src/
├── bot.ts
└── todo/
    ├── item.ts
    └── list.ts
```

`item.ts` just defines some stuff about TODO items, and these code parts are used in `list.ts`.

In `list.ts`, you would then do something like this:

```ts
export const lists = new Composer();

// Register some handlers here that handle your middleware the usual way.
lists.on("message", async (ctx) => {/* ... */});
```

> Note that if you use TypeScript, you need to pass your [custom context type](../guide/context#customizing-the-context-object) when creating the composer.
> For example, you'll need to use `new Composer<MyContext>()`.

Optionally, you can use an [error boundary](../guide/errors#error-boundaries) to handle all errors that happen inside your module.

Now, in `bot.ts`, you can install this module like so:

```ts
import { lists } from "./todo/list";

const bot = new Bot("");

bot.use(lists);
// ... maybe more modules like `todo` here

bot.start();
```

Optionally, you can use the [router plugin](../plugins/router) or [`bot.route`](/ref/core/composer#route) to bundle up the different modules, if you're able to determine which middleware is responsible upfront.

However, remember that the exact way of how to structure your bot is very hard to say generically.
As always in software, do it in a way that makes the most sense :wink:

## Type Definitions for Extracted Middleware

The above structure using composers works well.
However, sometimes you may find yourself in the situation that you want to extract a handler into a function, rather than creating a new composer and adding the logic to it.
This requires you to add the correct middleware type definitions to your handlers because they can no longer be inferred through the composer.

grammY exports type definitions for all **narrowed types of middleware**, such as the middleware that you can pass to command handlers.
In addition, it exports the type definitions for the **narrowed context objects** that are being used in that middleware.
Both types are parameterized with your [custom context object](../guide/context#customizing-the-context-object).
Hence, a command handler would have the type `CommandMiddleware<MyContext>` and its context object `CommandContext<MyContext>`.
They can be used as follows.

::: code-group

```ts [Node.js]
import {
  type CallbackQueryMiddleware,
  type CommandContext,
  type NextFunction,
} from "grammy";

function commandMiddleware(ctx: CommandContext<MyContext>, next: NextFunction) {
  // command handling
}
const callbackQueryMiddleware: CallbackQueryMiddleware<MyContext> = (ctx) => {
  // callback query handling
};

bot.command(["start", "help"], commandMiddleware);
bot.callbackQuery("query-data", callbackQueryMiddleware);
```

```ts [Deno]
import {
  type CallbackQueryMiddleware,
  type CommandContext,
  type NextFunction,
} from "https://deno.land/x/grammy/mod.ts";

function commandMiddleware(ctx: CommandContext<MyContext>, next: NextFunction) {
  // command handling
}
const callbackQueryMiddleware: CallbackQueryMiddleware<MyContext> = (ctx) => {
  // callback query handling
};

bot.command(["start", "help"], commandMiddleware);
bot.callbackQuery("query-data", callbackQueryMiddleware);
```

:::

Check out the [type aliases API reference](/ref/core/#type-aliases) to see an overview over all type aliases that grammY exports.
</file>

<file path="site/docs/advanced/transformers.md">
# Bot API Transformers

Middleware is a function that handles a context object, i.e. incoming data.

grammY also provides you with the inverse.
A _transformer function_ is a function that handles outgoing data, i.e.

- a method name of the Bot API to call, and
- a payload object that matches the method.

Instead of having `next` as the last argument to invoke downstream middleware, you receive `prev` as the first argument to utilize upstream transformer functions.
Looking at the type signature of `Transformer` ([grammY API Reference](/ref/core/transformer)), we can see how it reflects that.
Note that `Payload<M, R>` refers to the payload object that has to match the given method, and that `ApiResponse<ApiCallResult<M, R>>` is the return type of the invoked method.

The last invoked transformer function is a built-in caller that does things like JSON serialization of certain fields, and eventually calling `fetch`.

There is no equivalent of a `Composer` class for transformer functions because that's probably overkill, but if you need it, you can write your own.
PR welcome! :wink:

## Installing a Transformer Function

Transformer functions can be installed on `bot.api`.
Here is an example for a transformer function that does nothing:

```ts
// Pass-through transformer function
bot.api.config.use((prev, method, payload, signal) =>
  prev(method, payload, signal)
);

// Comparison with pass-through middleware
bot.use((ctx, next) => next());
```

Here is an example of a transformer function that prevents all API calls from happening:

```ts
// Incorrectly return `{ ok: true } as any` instead of the respective object types.
bot.api.config.use((prev, method, payload, signal) => ({ ok: true }) as any);
```

You can also install transformer functions on the context object's API object.
The transformer function will then only be used temporarily for the API requests that are performed on that specific context object.
Calls to `bot.api` are left unaffected.
Calls via context objects of concurrently running middleware are left unaffected, as well.
As soon as the respective middleware completes, the transformer function is discarded.

```ts
bot.on("message", async (ctx) => {
  // Install on all context objects that process messages.
  ctx.api.config.use((prev, method, payload, signal) =>
    prev(method, payload, signal)
  );
});
```

> The `signal` parameter should be always passed to `prev`.
> It allows canceling requests and is important for `bot.stop` to work.

Transformer functions installed on `bot.api` will be pre-installed on every `ctx.api` object.
Thus, calls to `ctx.api` will be transformed by both those transformers on `ctx.api`, as well as those transformers installed on `bot.api`.

## Use Cases of Transformer Functions

Transformer functions are as flexible as middleware, and they have just as many different applications.

For instance, the [grammY menu plugin](../plugins/menu) installs a transformer function to turn outgoing menu instances into the correct payload.
You can also use them to

- implement [flood control](../plugins/transformer-throttler),
- mock API requests during testing,
- add [retry behavior](../plugins/auto-retry), or
- more.

Note, however, that retrying an API call can have odd side-effects: if you call `sendDocument` and pass a readable stream instance to `InputFile`, then the stream will be read the first time the request is tried.
If you invoke `prev` again, the stream may already be (partially) consumed, hence leading to broken files.
It is therefore a more reliable way to pass file paths to `InputFile`, so grammY can recreate the stream as necessary.

## API Flavoring

grammY features [context flavors](../guide/context#context-flavors) that can be used to adjust the context type.
This includes API methods---both those that are directly on the context object such as `ctx.reply`, and all methods in `ctx.api` and `ctx.api.raw`.
However, you cannot adjust the types of `bot.api` and `bot.api.raw` via context flavors.

This is why grammY supports _API flavors_.
They solve this problem:

```ts
import { Api, Bot, Context } from "grammy";
import { SomeApiFlavor, SomeContextFlavor, somePlugin } from "some-plugin";

// Context flavoring
type MyContext = Context & SomeContextFlavor;
// API flavoring
type MyApi = Api & SomeApiFlavor;

// Use both flavors.
const bot = new Bot<MyContext, MyApi>("");

// Use a plugin.
bot.api.config.use(somePlugin());

// Now call `bot.api` with adjusted types from API flavor.
bot.api.somePluginMethod();

// Also, use adjusted context type from context flavor.
bot.on("message", (ctx) => ctx.api.somePluginMethod());
```

API flavors work exactly analogously to context flavors.
There are both additive and transformative API flavors, and multiple API flavors can be combined the same way as you would do with context flavors.
If you are unsure how this works, head back to the [section about context flavors](../guide/context#context-flavors) in the guide.
</file>

<file path="site/docs/demo/examples.md">
# Example Bots

Coming soon, please come back later.
</file>

<file path="site/docs/demo/README.md">
# Live Browser Demo

Coming soon, please come back later.
</file>

<file path="site/docs/guide/api.md">
# Bot API

## General Information

Telegram bots communicate with the Telegram servers via HTTP requests.
The Telegram Bot API is the specification of this interface, i.e. a [long list](https://core.telegram.org/bots/api) of methods and data types, commonly called a reference.
It defines everything that Telegram bots can do.
You can find it linked under the Resources tab in the Telegram section.

The setup can be visualized like this:

```asciiart:no-line-numbers
your grammY bot <———HTTP———> Bot API <———MTProto———> Telegram
```

In words: when your bot sends a message, it will be sent as an HTTP request to a _Bot API server_.
This server is hosted at `api.telegram.org`.
It will translate the request to Telegram's native protocol called MTProto, and send a request to the Telegram backend which takes care of sending the message to the user.

Analogously, whenever a user responds, the inverse path is taken.

When you run your bot, you need to decide how the updates should be sent across the HTTP connection.
This can be done with [long polling or webhooks](./deployment-types).

You can also host the Bot API server yourself.
This is mainly useful to send large files, or to decrease latency.

## Calling the Bot API

The Bot API is what defines what bots can and cannot do.
Every single method of the Bot API has an equivalent in grammY, and we make sure to always keep the library in sync with the latest and greatest features for bots.
Example: `sendMessage` in the [Telegram Bot API Reference](https://core.telegram.org/bots/api#sendmessage) and in the [grammY API Reference](/ref/core/api#sendmessage).

### Calling a Method

You can call API methods via `bot.api`, or [equivalently](./context#available-actions) via `ctx.api`:

::: code-group

```ts [TypeScript]
import { Api, Bot } from "grammy";

const bot = new Bot("");

async function sendHelloTo12345() {
  // Send a message to 12345.
  await bot.api.sendMessage(12345, "Hello!");

  // Send a message and store the response, which contains info about the sent message.
  const sentMessage = await bot.api.sendMessage(12345, "Hello again!");
  console.log(sentMessage.message_id);

  // Send a message without the `bot` object.
  const api = new Api(""); // <-- put your bot token between the ""
  await api.sendMessage(12345, "Yo!");
}
```

```js [JavaScript]
const { Api, Bot } = require("grammy");

const bot = new Bot("");

async function sendHelloTo12345() {
  // Send a message to 12345.
  await bot.api.sendMessage(12345, "Hello!");

  // Send a message and store the response, which contains info about the sent message.
  const sentMessage = await bot.api.sendMessage(12345, "Hello again!");
  console.log(sentMessage.message_id);

  // Send a message without the `bot` object.
  const api = new Api(""); // <-- put your bot token between the ""
  await api.sendMessage(12345, "Yo!");
}
```

```ts [Deno]
import { Api, Bot } from "https://deno.land/x/grammy/mod.ts";

const bot = new Bot("");

async function sendHelloTo12345() {
  // Send a message to 12345.
  await bot.api.sendMessage(12345, "Hello!");

  // Send a message and store the response, which contains info about the sent message.
  const sentMessage = await bot.api.sendMessage(12345, "Hello again!");
  console.log(sentMessage.message_id);

  // Send a message without the `bot` object.
  const api = new Api(""); // <-- put your bot token between the ""
  await api.sendMessage(12345, "Yo!");
}
```

:::

> Note that `bot.api` is simply an instance of `Api` that is pre-constructed for you for convenience.
> Note also that if you have access to a context object (i.e. you are inside a message handler), it is always preferable to call `ctx.api` or one the [available actions](./context#available-actions).

While `Api` instances cover the entire Bot API, they sometimes change the function signatures a bit to make them more usable.
Strictly speaking, all methods of the Bot API expect a JSON object with a number of properties.
Notice, however, how `sendMessage` in the above code example receives two arguments, a chat identifier and a string.
grammY knows that these two values belong to the `chat_id` and the `text` property, respectively, and will build the correct JSON object for you.

As mentioned [earlier](./basics#sending-messages), you can specify other options in the third argument of type `Other`:

```ts
async function sendHelloTo12345() {
  await bot.api.sendMessage(12345, "<i>Hello!</i>", {
    parse_mode: "HTML",
  });
}
```

Moreover, grammY takes care of numerous technical details to simplify the API usage.
As an example, some specific properties in some specific methods have to be `JSON.stringify`ed before they are sent.
This is easy to forget, hard to debug, and it breaks type inference.
grammY allows you to specify objects consistently across the API, and makes sure that the right properties are serialized on the fly before sending them.

### Type Definitions for the Bot API

grammY ships with complete type coverage of the Bot API.
The [`@grammyjs/types`](https://github.com/grammyjs/types) repository contains the type definitions that grammY uses internally.
These type definitions are also directly exported from the core `grammy` package so you can use them in your own code.

#### Type Definitions on Deno

On Deno, you can simply import type definitions from `types.ts`, which is right next to `mod.ts`:

```ts
import { type Chat } from "https://deno.land/x/grammy/types.ts";
```

#### Type Definitions on Node.js

On Node.js, things are more complicated.
You need to import the types from `grammy/types`.
For example, you get access to the `Chat` type like this:

```ts
import { type Chat } from "grammy/types";
```

However, officially, Node.js only supports importing from sub-paths properly since Node.js 16.
Consequently, TypeScript requires the `moduleResolution` to be set to `node16` or `nodenext`.
Adjust your `tsconfig.json` accordingly and add the highlighted line:

```json{4}
{
  "compilerOptions": {
    // ...
    "moduleResolution": "node16"
    // ...
  }
}
```

In some cases, this can also work without adjusting your TypeScript configuration.

::: warning Wrong Autocomplete on Node.js
If you do not change your `tsconfig.json` file as described above, it may happen that your code editor suggests in autocomplete to import types from `grammy/out/client` or something.
**All paths starting with `grammy/out` are internal. Do not use them.**
They could be changed arbitrarily at any point in time, so we strongly advise you to import from `grammy/types` instead.
:::

### Making Raw API Calls

There may be times when you want to use the original function signatures, but still rely on the convenience of the grammY API (e.g. JSON serializing where appropriate).
grammY supports this via the `bot.api.raw` (or the `ctx.api.raw`) properties.

You can call the raw methods like this:

```ts
async function sendHelloTo12345() {
  await bot.api.raw.sendMessage({
    chat_id: 12345,
    text: "<i>Hello!</i>",
    parse_mode: "HTML",
  });
}
```

Basically, all parameters of the function signature are merged with the options object when you use the raw API.

## Choosing a Data Center Location

> [Skip](./filter-queries) the rest of the page if you are just getting started.

If you want to reduce the networking latency of your bot, it matters where you host it.

The Bot API server behind `api.telegram.org` is hosted in Amsterdam in the Netherlands.
Therefore, the best location to run your bot is Amsterdam.

::: tip Hosting Comparison
You may be interested in our [comparison on hosting providers](../hosting/comparison#comparison-tables).
:::

However, there might be an even better place to run your bot, although this takes significantly more effort.

[Remember](#general-information) that the Bot API server does not actually contain your bot.
It only relays requests, translates between HTTP and MTProto, and so on.
The Bot API server may be in Amsterdam, but the Telegram servers are distributed across three different locations:

- Amsterdam, Netherlands
- Miami, Florida, United States
- Singapore

Thus, when the Bot API server sends a request to the Telegram servers, it may have to send data halfway around the globe.
Whether or not this happens depends on the data center of the bot itself.
The data center of the bot is the same data center as for the user who created the bot.
The data center of a user depends on many factors, including the location of the user.

Hence, this is what you can do if you want to reduce the latency even further.

1. Contact [@where_is_my_dc_bot](https://t.me/where_is_my_dc_bot) and send a file that was uploaded with your own account.
   It will tell you the location of your user account.
   This is also the location of your bot.
2. If your data center is in Amsterdam, there is nothing you need to do.
   Otherwise, keep reading.
3. Buy a [VPS](../hosting/comparison#vps) in the location of your data center.
4. [Run a local Bot API server](#running-a-local-bot-api-server) on that VPS.
5. Host your bot in the same location as your data center.

That way, each request will only travel the shortest possible distance between Telegram and your bot.

## Running a Local Bot API Server

There are two main advantages to running your own Bot API server.

1. Your bot can send and receive large files.
2. Your bot might have reduced networking delays (see [above](#choosing-a-data-center-location)).

> Other minor advantages are listed [here](https://core.telegram.org/bots/api#using-a-local-bot-api-server).

You must run the Bot API server on a VPS.
It will crash or drop messages if you try to run it somewhere else.

You should also compile the Bot API server from scratch.
It is helpful if you are experienced in compiling large C++ projects, but if you aren't, then you can simply copy the build instructions and hope that they work.

**The easiest way to run the Bot API server is by following the [build instructions generator](https://tdlib.github.io/telegram-bot-api/build.html?os=Linux) provided by Telegram.**

> More options can be found in the [Bot API server's repository](https://github.com/tdlib/telegram-bot-api#installation).

Building the server gives you an executable that you can run.

Did you obtain that executable?
You can now move your bot to the local Bot API server!

### Logging Out of the Hosted Bot API Server

First, you need to log out of the hosted Bot API server.
Take this URL and paste it into a browser (remember to replace `<token>` with your bot token):

```text
https://api.telegram.org/bot<token>/logOut
```

You should see `{"ok":true,"result":true}`.

### Configuring grammY to Use the Local Bot API Server

Next, you can tell grammY to use your local Bot API server instead of `api.telegram.org`.
Let's say that your bot runs on `localhost` on port 8081.
You should then use the following configuration.

```ts
const bot = new Bot("", { // <-- use the same token as before
  client: { apiRoot: "http://localhost:8081" },
});
```

You can now start your bot again.
It will use the local Bot API server.

> If something went wrong and you have no idea how to fix it no matter how much you google it, don't be shy to join our [community chat](https://t.me/grammyjs) and ask for help!
> We know even less about your mistake than you, but we can probably answer your questions.

Remember that you also have to adjust your code to work with local file paths instead of URLs pointing to your files.
For example, calling `getFile` will give you a `file_path` that points to your local disk, rather than a file that first needs to be downloaded from Telegram.
Similarly, the [files plugin](../plugins/files) has a method called `getUrl` that will no longer return a URL, but an absolute file path instead.

If you ever want to change this configuration again and move your bot to a different server, be sure to read [this section](https://github.com/tdlib/telegram-bot-api#moving-a-bot-to-a-local-server) of the README of the Bot API server repository.
</file>

<file path="site/docs/guide/basics.md">
# Sending and Receiving Messages

As soon as you start your bot with `bot.start()`, grammY will supply your listeners with the messages that users send to your bot.
grammY also provides methods to easily reply to these messages.

## Receiving Messages

The easiest way to listen for messages is via

```ts
bot.on("message", async (ctx) => {
  const message = ctx.message; // the message object
});
```

However, there are a number of other options, too.

```ts
// Handles commands, such as /start.
bot.command("start", async (ctx) => {/* ... */});

// Matches the message text against a string or a regular expression.
bot.hears(/echo *(.+)?/, async (ctx) => {/* ... */});
```

You can use auto-complete in your code editor to see all available options, or check out [all methods](/ref/core/composer) of the `Composer` class.

> [Read more](./filter-queries) about filtering for specific message types with `bot.on()`.

## Sending Messages

All methods that bots can use (**[important list](https://core.telegram.org/bots/api#available-methods)**) are available on the `bot.api` object.

```ts
// Send a text message to user 12345.
await bot.api.sendMessage(12345, "Hi!");
// Optionally, you can pass an options object.
await bot.api.sendMessage(12345, "Hi!", {/* more options */});
// Inspect the message object of the sent message.
const message = await bot.api.sendMessage(12345, "Hi!");
console.log(message.message_id);

// Get information about the bot itself.
const me = await bot.api.getMe();

// etc
```

Every method takes an optional options object of type `Other`, which allows you to set further options for your API calls.
These options objects correspond exactly with the options that you can find in list of methods linked above.
You can also use auto-complete in your code editor to see all available options, or check out [all methods](/ref/core/api) of the `Api` class.
The rest of this page shows some examples for this.

Also, check out the [next section](./context) to learn how the context object of a listener makes sending messages a breeze!

## Sending Messages With Reply

You can use the Telegram reply-to feature by specifying the message identifier to reply to using `reply_parameters`.

```ts
bot.hears("ping", async (ctx) => {
  // `reply` is an alias for `sendMessage` in the same chat (see next section).
  await ctx.reply("pong", {
    // `reply_parameters` specifies the actual reply feature.
    reply_parameters: { message_id: ctx.msg.message_id },
  });
});
```

> Note that only sending a message via `ctx.reply` does **NOT** mean you are automatically replying to anything.
> Instead, you should specify `reply_parameters` for this.
> The function `ctx.reply` is just an alias for `ctx.api.sendMessage`, see the [next section](./context#available-actions).

The reply parameters also allow you to reply to messages in other chats, as well as to quote parts of a message---or even both at the same time!
Have a look at Bot API's [reply parameters documentation](https://core.telegram.org/bots/api#replyparameters).

## Sending Message With Formatting

> Check out the [section about formatting options](https://core.telegram.org/bots/api#formatting-options) in the Telegram Bot API Reference written by the Telegram team.

You can send messages with **bold** or _italic_ text, use URLs, and more.
There are two ways to do this, as described in the [section about formatting options](https://core.telegram.org/bots/api#formatting-options), namely Markdown and HTML.

### Markdown

> Also see <https://core.telegram.org/bots/api#markdownv2-style>

Send your message with markdown in the text, and specify `parse_mode: "MarkdownV2"`.

```ts
await bot.api.sendMessage(
  12345,
  "*Hi\\!* _Welcome_ to [grammY](https://grammy.dev)\\.",
  { parse_mode: "MarkdownV2" },
);
```

### HTML

> Also see <https://core.telegram.org/bots/api#html-style>

Send your message with HTML elements in the text, and specify `parse_mode: "HTML"`.

```ts
await bot.api.sendMessage(
  12345,
  '<b>Hi!</b> <i>Welcome</i> to <a href="https://grammy.dev">grammY</a>.',
  { parse_mode: "HTML" },
);
```

## Sending Files

File handling is explained in greater depth in a [later section](./files#sending-files).

## Force Reply

> This can be useful if your bot is running in [privacy mode](https://core.telegram.org/bots/features#privacy-mode) in group chats.

When you send a message, you can make the user's Telegram client automatically specify the message as reply.
That means that the user will reply to your bot's message automatically (unless they remove the reply manually).
As a result, your bot will receive the user's message even when running in [privacy mode](https://core.telegram.org/bots/features#privacy-mode) in group chats.

You can force a reply like this:

```ts
bot.command("start", async (ctx) => {
  await ctx.reply("Hi! I can only read messages that explicitly reply to me!", {
    // Make Telegram clients automatically show a reply interface to the user.
    reply_markup: { force_reply: true },
  });
});
```
</file>

<file path="site/docs/guide/commands.md">
# Commands

Commands are special entities in Telegram messages, that serve as instructions for bots.

## Usage

> Revisit the commands section in the [Telegram Bot Features](https://core.telegram.org/bots/features#commands) written by the Telegram team.

grammY provides special handling for commands (e.g. `/start` and `/help`).
You can directly register listeners for certain commands via `bot.command()`.

```ts
// Respond to the command /start.
bot.command("start" /* , ... */);
// Respond to the command /help.
bot.command("help" /* , ... */);
// Respond to the commands /a, /b, /c, and /d.
bot.command(["a", "b", "c", "d"] /* , ... */);
```

Note that only those commands that are in the beginning of a message are handled, so if a user sends `"Please do not send /start to that bot!"`, then your listener will not be called, even though the `/start` command _is_ contained in the message.

Telegram supports sending targeted commands to bots, i.e. commands that end with `@your_bot_name`.
grammY handles this automatically for you, so `bot.command("start")` will match messages with `/start` and with `/start@your_bot_name` as commands.
You can choose to match only targeted commands by specifying `bot.command("start@your_bot_name")`.

::: tip Suggest Commands to Users
You can call

```ts
await bot.api.setMyCommands([
  { command: "start", description: "Start the bot" },
  { command: "help", description: "Show help text" },
  { command: "settings", description: "Open settings" },
]);
```

to make Telegram clients display a list of suggested commands in the text input field.

Alternatively, you can configure this by talking to [@BotFather](https://t.me/BotFather).
:::

## Arguments

Users can send **arguments** along with their commands.
You can access the argument string via `ctx.match`.

```ts
bot.command("add", async (ctx) => {
  // `item` will be "apple pie" if a user sends "/add apple pie".
  const item = ctx.match;
});
```

Note that you can always access the entire message's text via `ctx.msg.text`.

## Deep Linking Support

> Revisit the deep linking section in the [Telegram Bot Features](https://core.telegram.org/bots/features#deep-linking) written by the Telegram team.

When a user visits `https://t.me/your_bot_name?start=payload`, their Telegram client will show a START button that (when clicked) sends the string from the URL parameter along with the message, in this example, the message text will be `"/start payload"`.
Telegram clients will not show the payload to the user (they will only see `"/start"` in the UI), however, your bot will receive it.
grammY extracts this payload for you, and provides it under `ctx.match`.
In our example with the above link, `ctx.match` would contain the string `"payload"`.

Deep linking is useful if you want to build a referral system, or track where users discovered your bot.
For example, your bot could send a channel post with an [inline keyboard](../plugins/keyboard#inline-keyboards) button.
The button contains a URL like the one above, e.g. `https://t.me/your_bot_name?start=awesome-channel-post-12345`.
When a user clicks on the button underneath the post, their Telegram client will open a chat with your bot, and display the START button as described above.
This way, your bot can identify where a user came from, and that they clicked the button underneath a specific channel post.

Naturally, you can also embed such links anywhere else: on the web, in messages, in QR codes, etc.

Check out this [section of the Telegram docs](https://core.telegram.org/api/links#bot-links) to see a full list of possible link formats.
They also let you prompt users to add your bot to groups or channels, and optionally grant your bot the necessary admin rights.
</file>

<file path="site/docs/guide/context.md">
# Context

The `Context` object ([grammY API Reference](/ref/core/context)) is an important part of grammY.

Whenever you register a listener on your bot object, this listener will receive a context object.

```ts
bot.on("message", async (ctx) => {
  // `ctx` is the `Context` object.
});
```

You can use the context object to

- [access information about the message](#available-information)
- [perform actions in response to the message](#available-actions).

Note that context objects are commonly called `ctx`.

## Available Information

When a user sends a message to your bot, you can access it via `ctx.message`.
As an example, to get the message text, you can do this:

```ts
bot.on("message", async (ctx) => {
  // `txt` will be a `string` when processing text messages.
  // It will be `undefined` if the received message does not have any message text,
  // e.g. photos, stickers, and other messages.
  const txt = ctx.message.text;
});
```

Similarly, you can access other properties of the message object, e.g. `ctx.message.chat` for information about the chat where the message was sent.
Check out the [part about `Message`s in the Telegram Bot API Reference](https://core.telegram.org/bots/api#message) to see which data is available.
Alternatively, you can simply use autocomplete in your code editor to see the possible options.

If you register your listener for other types, `ctx` will also give you information about those.
Example:

```ts
bot.on("edited_message", async (ctx) => {
  // Get the new, edited, text of the message.
  const editedText = ctx.editedMessage.text;
});
```

Moreover, you can get access to the raw `Update` object ([Telegram Bot API Reference](https://core.telegram.org/bots/api#update)) that Telegram sends to your bot.
This update object (`ctx.update`) contains all the data that sources `ctx.message` and the like.

The context object always contains information about your bot, accessible via `ctx.me`.

### Shortcuts

There are a number of shortcuts installed on the context object.

| Shortcut                   | Description                                                                                                          |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| `ctx.msg`                  | Gets the message object, also edited ones                                                                            |
| `ctx.msgId`                | Gets the message identifier for messages or reactions                                                                |
| `ctx.chat`                 | Gets the chat object                                                                                                 |
| `ctx.chatId`               | Gets the chat identifier from `ctx.chat` or from `business_connection` updates                                       |
| `ctx.senderChat`           | Gets the sender chat object out of `ctx.msg` (for anonymous channel/group messages)                                  |
| `ctx.from`                 | Gets the author of the message, callback query, or other things                                                      |
| `ctx.inlineMessageId`      | Gets the inline message identifier for callback queries or chosen inline results                                     |
| `ctx.businessConnectionId` | Gets the business connection identifier for messages or business connection updates                                  |
| `ctx.entities`             | Gets the message entities and their text, optionally filtered by entity type                                         |
| `ctx.reactions`            | Gets the reactions from an update in a [way that is easy to work with](./reactions#inspecting-how-reactions-changed) |

In other words, you can also do this:

```ts
bot.on("message", async (ctx) => {
  // Get the text of the message.
  const text = ctx.msg.text;
});

bot.on("edited_message", async (ctx) => {
  // Get the new, edited, text of the message.
  const editedText = ctx.msg.text;
});

bot.on("message:entities", async (ctx) => {
  // Get all the entities.
  const entities = ctx.entities();

  // Get the first entity's text.
  entities[0].text;

  // Get email entities.
  const emails = ctx.entities("email");

  // Get phone and email entities.
  const phonesAndEmails = ctx.entities(["email", "phone_number"]);
});

bot.on("message_reaction", async (ctx) => {
  const { emojiAdded } = ctx.reactions();
  if (emojiAdded.includes("🎉")) {
    await ctx.reply("partY");
  }
});
```

> Skip ahead to [Reactions](./reactions) if you are interested in them.

Hence, if you want to, you can forget about `ctx.message` and `ctx.channelPost` and `ctx.editedMessage` and so on and so forth, and just always use `ctx.msg` instead.

## Probing via Has Checks

The context object has a few methods that allow you to probe the contained data for certain things.
For example, you can call `ctx.hasCommand("start")` to see if the context object contains a `/start` command.
This is why the methods are collectively named _has checks_.

::: tip Know When to Use Has Checks
This is the exact same logic that is used by `bot.command("start")`.
Note that you should usually use [filter queries](./filter-queries) and similar methods.
Using has checks works best inside the [conversations plugin](../plugins/conversations).
:::

The has checks correctly narrow down the context type.
This means that checking if a context has callback query data will tell TypeScript that the context has the field `ctx.callbackQuery.data` present.

```ts
if (ctx.hasCallbackQuery(/query-data-\d+/)) {
  // `ctx.callbackQuery.data` is known to be present here
  const data: string = ctx.callbackQuery.data;
}
```

The same applies to all other has checks.
Check out the [API reference of the context object](/ref/core/context#has) to see a list of all has checks.
Also check out the static property `Context.has` in the [API reference](/ref/core/context#has) that lets you create efficient predicate functions for probing a lot of context objects.

## Available Actions

If you want to respond to a message from a user, you could write this:

```ts
bot.on("message", async (ctx) => {
  // Get the chat identifier.
  const chatId = ctx.msg.chat.id;
  // The text to reply with
  const text = "I got your message!";
  // Send the reply.
  await bot.api.sendMessage(chatId, text);
});
```

You can notice two things that are not optimal about this:

1. We must have access to the `bot` object.
   This means that we have to pass the `bot` object all around our code base in order to respond, which is annoying when you have more than one source file and you define your listener somewhere else.
2. We have to take out the chat identifier of the context, and explicitly pass it to `sendMessage` again.
   This is annoying, too, because you most likely always want to respond to the same user that sent a message.
   Imagine how often you would type the same thing over and over again!

Regarding point 1., the context object simply provides you access to the same API object that you find on `bot.api`, it is called `ctx.api`.
You could now write `ctx.api.sendMessage` instead and you no longer have to pass around your `bot` object.
Easy.

However, the real strength is to fix point 2.
The context object lets you simply send a reply like this:

```ts
bot.on("message", async (ctx) => {
  await ctx.reply("I got your message!");
});

// Or, even shorter:
bot.on("message", (ctx) => ctx.reply("Gotcha!"));
```

Neat! :tada:

Under the hood, the context _already knows its chat identifier_ (namely `ctx.msg.chat.id`), so it gives you the `reply` method to just send a message back to the same chat.
Internally, `reply` again calls `sendMessage` with the chat identifier pre-filled for you.

Consequently, all methods on the context object take options objects of type `Other` as explained [earlier](./basics#sending-messages).
This can be used to pass further configuration to every API call.

::: tip Telegram Reply Feature
Even though the method is called `ctx.reply` in grammY (and many other frameworks), it does not use the [reply feature of Telegram](https://telegram.org/blog/replies-mentions-hashtags#replies) where a previous message is linked.

If you look up what `sendMessage` can do in the [Bot API Reference](https://core.telegram.org/bots/api#sendmessage), you will see a number of options, such as `parse_mode`, `link_preview_options`, and `reply_parameters`.
The latter can be used to make a message a reply:

```ts
await ctx.reply("^ This is a message!", {
  reply_parameters: { message_id: ctx.msg.message_id },
});
```

The same options object can be passed to `bot.api.sendMessage` and `ctx.api.sendMessage`.
Use auto-complete to see the available options right in your code editor.
:::

Naturally, every other method on `ctx.api` has a shortcut with the correct pre-filled values, such as `ctx.replyWithPhoto` to reply with a photo, or `ctx.exportChatInviteLink` to get an invite link for the respective chat.
If you want to get an overview over what shortcuts exist, then auto-complete is your friend, along with the [grammY API Reference](/ref/core/context).

Note that you may not want to react in the same chat always.
In this case, you can just fall back to using `ctx.api` methods, and specify all options when calling them.
For example, if you receive a message from Alice and want to react by sending a message to Bob, then you cannot use `ctx.reply` because it will always send messages to the chat with Alice.
Instead, call `ctx.api.sendMessage` and specify the chat identifier of Bob.

## How Context Objects Are Created

Whenever your bot receives a new message from Telegram, it is wrapped in an update object.
In fact, update objects can not only contain new messages, but also all other sorts of things, such as edits to messages, poll answers, and [much more](https://core.telegram.org/bots/api#update).

A fresh context object is created exactly once for every incoming update.
Contexts for different updates are completely unrelated objects, they only reference the same bot information via `ctx.me`.

The same context object for one update will be shared by all installed middleware ([docs](./middleware)) on the bot.

## Customizing the Context Object

> If you are new to context objects, you don't need to worry about the rest of this page.

You can install your own properties on the context object if you want.

### Via Middleware (Recommended)

The customizations can be easily done in [middleware](./middleware).

::: tip Middlewhat?
This section requires an understanding of middleware, so in case you have not skipped ahead to this [section](./middleware) yet, here is a very brief summary.

All you really need to know is that several handlers can process the same context object.
There are special handlers which can modify `ctx` before any other handlers are run, and the modifications of the first handler will be visible to all subsequent handlers.
:::

The idea is to install middleware before you register other listeners.
You can then set the properties you want inside these handlers.
If you do `ctx.yourCustomPropertyName = yourCustomValue` inside such a handler, then the property `ctx.yourCustomPropertyName` will be available in the remaining handlers, too.

For illustration purposes, let's say you want to set a property called `ctx.config` on the context object.
In this example, we will use it to store some configuration about the project so that all handlers have access to it.
The configuration will make it easier to detect if the bot is used by its developer or by regular users.

Right after creating your bot, do this:

```ts
const BOT_DEVELOPER = 123456; // bot developer chat identifier

bot.use(async (ctx, next) => {
  // Modify context object here by setting the config.
  ctx.config = {
    botDeveloper: BOT_DEVELOPER,
    isDeveloper: ctx.from?.id === BOT_DEVELOPER,
  };
  // Run remaining handlers.
  await next();
});
```

After that, you can use `ctx.config` in the remaining handlers.

```ts
bot.command("start", async (ctx) => {
  // Work with modified context here!
  if (ctx.config.isDeveloper) await ctx.reply("Hi mom!! <3");
  else await ctx.reply("Welcome, human!");
});
```

However, you will notice that TypeScript does not know that `ctx.config` is available, even though we are assigning the property correctly.
So while the code will work at runtime, it does not compile.
To fix this, we need to adjust the type of the context and add the property.

```ts
interface BotConfig {
  botDeveloper: number;
  isDeveloper: boolean;
}

type MyContext = Context & {
  config: BotConfig;
};
```

The new type `MyContext` now accurately describes the context objects our bot is actually handling.

> You will need to make sure that you keep the types in sync with the properties you initialize.

We can use the new type by passing it to the `Bot` constructor.

```ts
const bot = new Bot<MyContext>("");
```

In summary, the setup will look like this:

::: code-group

```ts [TypeScript]
const BOT_DEVELOPER = 123456; // bot developer chat identifier

// Define custom context type.
interface BotConfig {
  botDeveloper: number;
  isDeveloper: boolean;
}
type MyContext = Context & {
  config: BotConfig;
};

const bot = new Bot<MyContext>("");

// Set custom properties on context objects.
bot.use(async (ctx, next) => {
  ctx.config = {
    botDeveloper: BOT_DEVELOPER,
    isDeveloper: ctx.from?.id === BOT_DEVELOPER,
  };
  await next();
});

// Define handlers for custom context objects.
bot.command("start", async (ctx) => {
  if (ctx.config.isDeveloper) await ctx.reply("Hi mom!");
  else await ctx.reply("Welcome");
});
```

```js [JavaScript]
const BOT_DEVELOPER = 123456; // bot developer chat identifier

const bot = new Bot("");

// Set custom properties on context objects.
bot.use(async (ctx, next) => {
  ctx.config = {
    botDeveloper: BOT_DEVELOPER,
    isDeveloper: ctx.from?.id === BOT_DEVELOPER,
  };
  await next();
});

// Define handlers for custom context objects.
bot.command("start", async (ctx) => {
  if (ctx.config.isDeveloper) await ctx.reply("Hi mom!");
  else await ctx.reply("Welcome");
});
```

:::

Naturally, the custom context type can also be passed to other things which handle middleware, such as [composers](/ref/core/composer).

```ts
const composer = new Composer<MyContext>();
```

Some plugins will also require you to pass a custom context type, such as the [router](../plugins/router) or the [menu](../plugins/menu) plugin.
Check out their docs to see how they can use a custom context type.
These types are called context flavors, as described [down here](#context-flavors).

### Via Inheritance

In addition to setting custom properties on the context object, you can subclass the `Context` class.

```ts
class MyContext extends Context {
  // etc
}
```

However, we recommend that you customize the context object [via middleware](#via-middleware-recommended) because it is much more flexible and works much better if you want to install plugins.

We will now see how to use custom classes for context objects.

When constructing your bot, you can pass a custom context constructor that will be used to instantiate the context objects.
Note that your class must extend `Context`.

::: code-group

```ts [TypeScript]
import { Bot, Context } from "grammy";
import type { Update, UserFromGetMe } from "grammy/types";

// Define a custom context class.
class MyContext extends Context {
  // Set some custom properties.
  public readonly customProp: number;

  constructor(update: Update, api: Api, me: UserFromGetMe) {
    super(update, api, me);
    this.customProp = me.username.length * 42;
  }
}

// Pass the constructor of the custom context class as an option.
const bot = new Bot("", {
  ContextConstructor: MyContext,
});

bot.on("message", async (ctx) => {
  // `ctx` is now of type `MyContext`.
  const prop = ctx.customProp;
});

bot.start();
```

```js [JavaScript]
const { Bot, Context } = require("grammy");

// Define a custom context class.
class MyContext extends Context {
  // Set some custom properties.
  public readonly customProp;

  constructor(update, api, me) {
    super(update, api, me);
    this.customProp = me.username.length * 42;
  }
}

// Pass the constructor of the custom context class as an option.
const bot = new Bot("", {
  ContextConstructor: MyContext,
});

bot.on("message", async (ctx) => {
  // `ctx` is now of type `MyContext`.
  const prop = ctx.customProp;
});

bot.start();
```

```ts [Deno]
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import type {
  Update,
  UserFromGetMe,
} from "https://deno.land/x/grammy/types.ts";

// Define a custom context class.
class MyContext extends Context {
  // Set some custom properties.
  public readonly customProp: number;

  constructor(update: Update, api: Api, me: UserFromGetMe) {
    super(update, api, me);
    this.customProp = me.username.length * 42;
  }
}

// Pass the constructor of the custom context class as an option.
const bot = new Bot("", {
  ContextConstructor: MyContext,
});

bot.on("message", async (ctx) => {
  // `ctx` is now of type `MyContext`.
  const prop = ctx.customProp;
});

bot.start();
```

:::

Notice how the custom context type will be inferred automatically when you are using a subclass.
You no longer need to write `Bot<MyContext>` because you already specified your subclass constructor in the options object of `new Bot()`.

However, this makes it very hard (if not impossible) to install plugins, as they often need you to install context flavors.

## Context Flavors

Context flavors are a way to tell TypeScript about new properties on your context object.
These new properties can be shipped in plugins or other modules and then installed on your bot.

Context flavors are also able to transform the types of existing properties using automatic procedures which are defined by plugins.

### Additive Context Flavors

As implied above, there are two different kinds of context flavors.
The basic one is called _additive context flavor_, and whenever we talk about context flavoring, we just mean this basic form.
Let's look at how it works.

As an example, when you have [session data](../plugins/session), you must register `ctx.session` on the context type.
Otherwise,

1. you cannot install the built-in sessions plugin, and
2. you don't have access to `ctx.session` in your listeners.

> Even though we'll use sessions as an example here, similar things apply for lots of other things.
> In fact, most plugins will give you a context flavor that you need to use.

A context flavor is simply a small new type that defines the properties that should be added to the context type.
Let's look at an example for a flavor.

```ts
interface SessionFlavor<S> {
  session: S;
}
```

The `SessionFlavor` type ([API Reference](/ref/core/sessionflavor)) is straightforward: it defines only the property `session`.
It takes a type parameter that will define the actual structure of the session data.

How is that useful?
This is how you can flavor your context with session data:

```ts
import { Context, SessionFlavor } from "grammy";

// Declare `ctx.session` to be of type `string`.
type MyContext = Context & SessionFlavor<string>;

// Pass the type to your bot instance.
const bot = new Bot<MyContext>("");
```

You can now use the session plugin, and you have access to `ctx.session`:

```ts
bot.on("message", async (ctx) => {
  // Now `str` is of type `string`.
  const str = ctx.session;
});
```

Note that you should not only pass `MyContext` to your instance of `Bot`.
You also need to use it in many other places.
For example, if you create a new instance of `Composer`, use plugins like the [router plugin](../plugins/router), or [extract middleware into functions](../advanced/structuring#type-definitions-for-extracted-middleware), you should now specify your custom context type.

### Transformative Context Flavors

The other kind of context flavor is more powerful.
Instead of being installed with the `&` operator, they need to be installed like so:

```ts
import { Context } from "grammy";
import { SomeFlavorA } from "my-plugin";

type MyContext = SomeFlavorA<Context>;
```

Everything else works the same way.

Every (official) plugin states in its documentation whether it must be used via additive or via transformative context flavor.

### Combining Different Context Flavors

If you have different [additive context flavors](#additive-context-flavors), you can just install them like this:

```ts
type MyContext = Context & FlavorA & FlavorB & FlavorC;
```

The order of context flavors does not matter, you can combine them in any order you like.

Multiple [transformative context flavors](#transformative-context-flavors) can also be combined:

```ts
type MyContext = FlavorX<FlavorY<FlavorZ<Context>>>;
```

Here, the order could matter, as `FlavorZ` transforms `Context` first, then `FlavorY`, and the result of this will be transformed again by `FlavorX`.

You can even mix additive and transformative flavors:

```ts
type MyContext = FlavorX<
  FlavorY<
    FlavorZ<
      Context & FlavorA & FlavorB & FlavorC
    >
  >
>;
```

Make sure to follow this pattern when installing several plugins.
There are a number of type errors that stem from incorrect combination of context flavors.
</file>

<file path="site/docs/guide/deployment-types.md">
---
next: false
---

# Long Polling vs. Webhooks

There are two ways how your bot can receive messages from the Telegram servers.
They are called _long polling_ and _webhooks_.
grammY supports both of these two ways, while long polling is the default.

This section first describes what long polling and webhooks actually are, and in turn outlines some of the advantages and disadvantages of using one or the other deployment method.
It will also cover how to use them with grammY.

## Introduction

You can think of the whole webhooks vs. long polling discussion as a question of what _deployment type_ to use.
In other words, there are two fundamentally different ways to host your bot (run it on some server), and they differ in the way how the messages reach your bot, and can be processed by grammY.

This choice matters a lot when you need to decide where to host your bot.
For instance, some infrastructure providers only support one of the two deployment types.

Your bot can either pull them in (long polling), or the Telegram servers can push them to your bot (webhooks).

> If you already know how these things work, scroll down to see how to use [long polling](#how-to-use-long-polling) or [webhooks](#how-to-use-webhooks) with grammY.

## How Does Long Polling Work?

_Imagine you're getting yourself a scoop of ice cream in your trusted ice cream parlor.
You walk up to the employee and ask for your favorite type of ice cream.
Unfortunately, he lets you know that it is out of stock._

_The next day, you're craving that delicious ice cream again, so you go back to the same place and ask for the same ice cream.
Good news!
They restocked over night so you can enjoy your salted caramel ice cream today!
Yummy._

**Polling** means that grammY proactively sends a request to Telegram, asking for new updates (think: messages).
If no messages are there, Telegram will return an empty list, indicating that no new messages were sent to your bot since the last time you asked.

When grammY sends a request to Telegram and new messages have been sent to your bot in the meantime, Telegram will return them as an array of up to 100 update objects.

```asciiart:no-line-numbers
______________                                   _____________
|            |                                   |           |
|            |   <--- are there messages? ---    |           |
|            |    ---       nope.         --->   |           |
|            |                                   |           |
|            |   <--- are there messages? ---    |           |
|  Telegram  |    ---       nope.         --->   |    Bot    |
|            |                                   |           |
|            |   <--- are there messages? ---    |           |
|            |    ---  yes, here you go   --->   |           |
|            |                                   |           |
|____________|                                   |___________|
```

It is immediately obvious that this has some drawbacks.
Your bot only receives new messages every time it asks, i.e. every few seconds or so.
To make your bot respond faster, you could just send more requests and not wait as long between them.
We could for example ask for new messages every millisecond! What could go wrong…

Instead of deciding to spam the Telegram servers, we will use _long polling_ instead of regular (short) polling.

**Long polling** means that grammY proactively sends a request to Telegram, asking for new updates.
If no messages are there, Telegram will keep the connection open until new messages arrive, and then respond to the request with those new messages.

_Time for ice cream again!
The employee already greets you with your first name by now.
Asked about some ice cream of your favorite kind, the employee smiles at you and freezes.
In fact, you don't get any response at all.
So you decide to wait, firmly smiling back.
And you wait.
And wait._

_Some hours before the next sunrise, a truck of a local food delivery company arrives and brings a couple of large boxes into the parlor's storage room.
They read **ice cream** on the outside.
The employee finally starts to move again.
"Of course we have salted caramel!
Two scoops with sprinkles, the usual?"_

_As if nothing had happened, you enjoy your ice cream while leaving the world's most unrealistic ice cream parlor._

```asciiart:no-line-numbers
______________                                   _____________
|            |                                   |           |
|            |   <--- are there messages? ---    |           |
|            |   .                               |           |
|            |   .                               |           |
|            |   .     *both waiting*            |           |
|  Telegram  |   .                               |    Bot    |
|            |   .                               |           |
|            |   .                               |           |
|            |    ---  yes, here you go   --->   |           |
|            |                                   |           |
|____________|                                   |___________|
```

> Note that in reality, no connection would be kept open for hours.
> Long polling requests have a default timeout of 30 seconds (in order to avoid a number of [technical problems](https://datatracker.ietf.org/doc/html/rfc6202#section-5.5)).
> If no new messages are returned after this period of time, then the request will be cancelled and resent---but the general concept stays the same.

Using long polling, you don't need to spam Telegram's servers, and still you get new messages immediately!
Nifty.
This is what grammY does by default when you run `bot.start()`.

## How Do Webhooks Work?

_After this terrifying experience (a whole night without ice cream!), you'd prefer not to ask anyone about ice cream at all anymore.
Wouldn't it be cool if the ice cream could come to you?_

Setting up a **webhook** means that you will provide Telegram with a URL that is accessible from the public internet.
Whenever a new message is sent to your bot, Telegram (and not you!) will take the initiative and send a request with the update object to your server.
Nice, heh?

_You decide to walk to the ice cream parlor one very last time.
You tell your friend behind the counter where you live.
He promises to head over to your apartment personally whenever new ice cream is there (because it would melt in the mail).
Cool guy._

```asciiart:no-line-numbers
______________                                   _____________
|            |                                   |           |
|            |                                   |           |
|            |                                   |           |
|            |         *both waiting*            |           |
|            |                                   |           |
|  Telegram  |                                   |    Bot    |
|            |                                   |           |
|            |                                   |           |
|            |    ---  hi, new message   --->    |           |
|            |   <---    thanks dude     ---     |           |
|____________|                                   |___________|
```

## Comparison

**The main advantage of long polling over webhooks is that it is simpler.**
You don't need a domain or a public URL.
You don't need to fiddle around with setting up SSL certificates in case you're running your bot on a VPS.
Use `bot.start()` and everything will work, no further configuration required.
Under load, you are in complete control of how many messages you can process.

Places where long polling works well include:

- During development on your local machine.
- On the majority of servers.
- On hosted "backend" instances, i.e. machines that actively run your bot 24/7.

**The main advantage of webhooks over long polling is that they are cheaper.**
You save a ton of superfluous requests.
You don't need to keep a network connection open at all times.
You can use services that automatically scale your infrastructure down to zero when no requests are coming.
If you want to, you can even [make an API call when responding to the Telegram request](#webhook-reply), even though this has a number of drawbacks.
Check out the configuration option [here](/ref/core/apiclientoptions#canusewebhookreply).

Places where webhooks work well include:

- On servers with SSL certificates.
- On hosted "frontend" instances that scale according to their load.
- On serverless platforms, such as cloud functions or programmable edge networks.

## I Still Have No Idea What to Use

Then go for long polling.
If you don't have a good reason to use webhooks, then note that there are no major drawbacks to long polling, and---according to our experience---you will spend much less time fixing things.
Webhooks can be a bit nasty from time to time (see [below](#ending-webhook-requests-in-time)).

Whatever you choose, if you ever run into serious problems, it should not be too hard to switch to the other deployment type after the fact.
With grammY, you only have to touch a few lines of code.
The setup of your [middleware](./middleware) is the same.

## How to Use Long Polling

Call

```ts
bot.start();
```

to run your bot with a very simple form of long polling.
It processes all updates sequentially.
This makes your bot very easy to debug, and all behavior very predictable, because there is no concurrency involved.

If you want your messages to be handled concurrently by grammY, or you worry about throughput, check out the section about [grammY runner](../plugins/runner).

## How to Use Webhooks

If you want to run grammY with webhooks, you can integrate your bot into a web server.
We therefore expect you to be able to start a simple web server with a framework of your choice.

Every grammY bot can be converted to middleware for a number of web frameworks, including `express`, `koa`/`oak`, and more.
You can import the `webhookCallback` function ([API reference](/ref/core/webhookcallback)) to create a middleware for the respective framework.

::: code-group

```ts [TypeScript]
import express from "express";

const app = express(); // or whatever you're using
app.use(express.json()); // parse the JSON request body

// "express" is also used as default if no argument is given.
app.use(webhookCallback(bot, "express"));
```

```js [JavaScript]
const express = require("express");

const app = express(); // or whatever you're using
app.use(express.json()); // parse the JSON request body

// "express" is also used as default if no argument is given.
app.use(webhookCallback(bot, "express"));
```

```ts [Deno]
import { Application } from "https://deno.land/x/oak/mod.ts";

const app = new Application(); // or whatever you're using

// Make sure to specify the framework you use.
app.use(webhookCallback(bot, "oak"));
```

:::

> Note that you must not call `bot.start()` when using webhooks.

Your application is now listening for webhook requests from Telegram.
The last thing you need to do is to tell Telegram where to send the updates.
There are several ways to do this, but in the end, they all just call `setWebhook` as documented [here](https://core.telegram.org/bots/api#setwebhook).

The easiest way to set your webhook is to paste the following URL in the address bar of your browser, replacing `<token>` by your bot token and `<url>` by the public endpoint of your server.

```txt
https://api.telegram.org/bot<token>/setWebhook?url=<url>
```

We also built a proper interface for this if you prefer to manage your webhook via a website.
You can find it here: <https://telegram.tools/webhook-manager>

Note that you can set your webhook from code, too:

```ts
const endpoint = ""; // <-- put your URL here
await bot.api.setWebhook(endpoint);
```

Finally, make sure to read [Marvin's Marvellous Guide to All Things Webhook](https://core.telegram.org/bots/webhooks) written by the Telegram team if you consider [running your bot on webhooks on a VPS](../hosting/vps#running-the-bot-on-webhooks).

### Web Framework Adapters

In order to support many different web frameworks, grammY adopts the concept of **adapters**.
Each adapter is responsible for relaying input and output from the web framework to grammY and vice versa.
The second parameter passed to `webhookCallback` ([API reference](/ref/core/webhookcallback)) defines the framework adapter used to communicate with the web framework.

Because of how this approach works, we usually need an adapter for each framework but, since some frameworks share a similiar interface, there are adapters that are known to work with multiple frameworks.
Below is a table containing the currently available adapters, and the framework, APIs, or runtimes they are known to work with.

| Adapter            | Framework/API/Runtime                                                                               |
| ------------------ | --------------------------------------------------------------------------------------------------- |
| `aws-lambda`       | AWS Lambda Functions                                                                                |
| `aws-lambda-async` | AWS Lambda Functions with `async`/`await`                                                           |
| `azure`            | Azure Functions                                                                                     |
| `bun`              | `Bun.serve`                                                                                         |
| `cloudflare`       | Cloudflare Workers                                                                                  |
| `cloudflare-mod`   | Cloudflare Module Workers                                                                           |
| `express`          | Express, Google Cloud Functions                                                                     |
| `fastify`          | Fastify                                                                                             |
| `hono`             | Hono                                                                                                |
| `http`, `https`    | Node.js `http`/`https` modules, Vercel Serverless                                                   |
| `koa`              | Koa                                                                                                 |
| `next-js`          | Next.js                                                                                             |
| `nhttp`            | NHttp                                                                                               |
| `oak`              | Oak                                                                                                 |
| `serveHttp`        | `Deno.serveHttp`                                                                                    |
| `std/http`         | `Deno.serve`, `std/http`, `Deno.upgradeHttp`, `Fresh`, `Ultra`, `Rutt`, `Sift`, Vercel Edge Runtime |
| `sveltekit`        | SvelteKit                                                                                           |
| `worktop`          | Worktop                                                                                             |

### Webhook Reply

When a webhook request is received, your bot can call up to one method in the response.
As a benefit, this saves your bot from making up to one HTTP request per update.
However, there are a number of drawbacks to using this:

1. You will not be able to handle potential errors of the respective API call.
   This includes rate limiting errors, so you won't actually be guaranteed that your request has any effect.
2. More importantly, you also won't have access to the response object.
   For example, calling `sendMessage` will not give you access to the message you send.
3. Furthermore, it is not possible to cancel the request.
   The `AbortSignal` will be disregarded.
4. Note also that the types in grammY do not reflect the consequences of a performed webhook callback!
   For instance, they indicate that you always receive a response object, so it is your own responsibility to make sure you're not screwing up while using this minor performance optimization.

If you want to use webhook replies, you can specify the `canUseWebhookReply` option in the `client` option of your `BotConfig` ([API reference](/ref/core/botconfig)).
Pass a function that determines whether or not to use webhook reply for the given request, identified by method.

```ts
const bot = new Bot("", {
  client: {
    // We accept the drawback of webhook replies for typing status.
    canUseWebhookReply: (method) => method === "sendChatAction",
  },
});
```

This is how webhook replies work under the hood.

```asciiart:no-line-numbers
______________                                   _____________
|            |                                   |           |
|            |                                   |           |
|            |                                   |           |
|            |         *both waiting*            |           |
|            |                                   |           |
|  Telegram  |                                   |    Bot    |
|            |                                   |           |
|            |                                   |           |
|            |    ---  hi, new message   --->    |           |
|            | <--- okay, and sendChatAction --- |           |
|____________|                                   |___________|
```

### Ending Webhook Requests in Time

> You can ignore the rest of this page if all your middleware completes fast, i.e. within a few seconds.
> This section is primarily for people who want to do file transfers in response to messages, or other operations that need more time.

When Telegram sends an update from one chat to your bot, it will wait for you to end the request before delivering the next update that belongs to that chat.
In other words, Telegram will deliver updates from the same chat in sequence, and updates from different chats are sent concurrently.
(The source of this information is [here](https://github.com/tdlib/telegram-bot-api/issues/75#issuecomment-755436496).)

Telegram tries to make sure that your bot receives all updates.
That means that if an update delivery fails for a chat, the subsequent updates will be queued until the first update succeeds.

#### Why Not Ending a Webhook Request Is Dangerous

Telegram has a timeout for each update that it sends to your webhook endpoint.
If you don't end a webhook request fast enough, Telegram will re-send the update, assuming that it was not delivered.
As a result, your bot can unexpectedly process the same update multiple times.
This means that it will perform all update handling, including the sending of any response messages, multiple times.

```asciiart:no-line-numbers
______________                                   _____________
|            |                                   |           |
|            | ---    hi, new message    --->    |           |
|            |                              .    |           |
|            |        *bot processing*      .    |           |
|            |                              .    |           |
|  Telegram  | --- I said new message!!! --->    |    Bot    |
|            |                              ..   |           |
|            |    *bot processing twice*    ..   |           |
|            |                              ..   |           |
|            | ---      HEEELLLOOOO      --->    |           |
|            |                              ...  |           |
|            |   *bot processing thrice*    ...  |           |
|____________|                              ...  |___________|
```

This is why grammY has its own, shorter timeout inside `webhookCallback` (default: 10 seconds).
If your middleware finishes before that, the function `webhookCallback` will respond to the webhook automatically.
In that case, everything is fine.
However, if your middleware does not finish before grammY's timeout, `webhookCallback` will throw an error.
This means that you can handle the error in your web framework.
If you don't have that error handling, Telegram will send the same update again---but at least you will have error logs now, to tell you that something is wrong.

Once Telegram sends an update to your bot for the second time, it is unlikely that your handling of it will be faster than the first time.
As a result, it will likely timeout again, and Telegram will send the update again.
Thus, your bot will not just see the update two times, but a few dozen times, until Telegram stops retrying.
You may observe that your bot starts spamming users as it tries to handle all of those updates (that are in fact the same every time).

#### Why Ending a Webhook Request Early Is Also Dangerous

You can configure `webhookCallback` to not throw an error after the timeout, but instead end the webhook request early, even though your middleware is still running.
You can do this by passing `"return"` as a third argument to `webhookCallback`, instead of the default value `"throw"`.
However, while this behavior has some valid use cases, such a solution usually causes more problems than it solves.

Remember that once you respond to a webhook request, Telegram will send the next update for that chat.
However, as the old update is still being processed, two updates which were previously processed sequentially, are suddenly processed in parallel.
This can lead to race conditions.
For example, the session plugin will inevitably break due to [WAR](https://en.wikipedia.org/wiki/Hazard_(computer_architecture)#Write_after_read_(WAR)) hazards.
**This causes data loss!**
Other plugins and even your own middleware may break too.
The extent of this is unknown and depends on your bot.

#### How to Solve This Problem

This answer is easier said than done.
**It is your job to make sure that your middleware finishes fast enough.**
Don't use long-running middleware.
Yes, we know that you perhaps _want_ to have long-running tasks.
Still.
Don't do it.
Not in your middleware.

Instead, use a queue (there are plenty of queuing systems out there, from very simple to very sophisticated).
Instead of trying to perform all of the work in the small webhook timeout window, just append the task to the queue to be handled separately, and let your middleware complete.
The queue can use all the time it wants.
When it's done, it can send a message back to the chat.
This is straightforward to do if you just use a simple in-memory queue.
It can be a little more challenging if you're using a fault-tolerant external queuing system, that persists the state of all tasks, and can retry things even if your server suddenly dies.

```asciiart:no-line-numbers
______________                                   _____________
|            |                                   |           |
|            |   ---   hi, new message    --->   |           |
|            |  <---     thanks dude      ---.   |           |
|            |                               .   |           |
|            |                               .   |           |
|  Telegram  |      *bot queue working*      .   |    Bot    |
|            |                               .   |           |
|            |                               .   |           |
|            |  <--- message with result  ---    |           |
|            |   ---       alrighty       --->   |           |
|____________|                                   |___________|
```

#### Why `"return"` Is Generally Worse Than `"throw"`

You may be wondering why the default action of `webhookCallback` is to throw an error, instead of ending the request successfully.
This design choice was made for the following reasons.

Race conditions are very hard to reproduce and may occur extremely rarely or sporadically.
The solution to this is to _make sure not to run into timeouts_ in the first place.
But, if you do, you really want to know that this is happening, so that you can investigate and fix the problem!
For that reason, you want the error to occur in your logs.
Setting the timeout handler to `"return"`, hence suppressing the timeout and pretending that nothing happened, is exactly the opposite of useful behavior.

If you do this, you're in some sense using the update queue in Telegram's webhook delivery as your task queue.
This is a bad idea for all of the reasons described above.
Just because grammY _can_ suppress errors that can make you lose your data, does not mean you _should_ tell it to.
This configuration setting should not be used in cases where your middleware simply takes too much time to complete.
Take the time to correctly fix this issue, and your future self (and users) will thank you.
</file>

<file path="site/docs/guide/errors.md">
# Error Handling

Every single error caused by your middleware will be caught by grammY.
You should install a custom error handler to handle errors.

Most importantly, this section will teach you [how to catch errors](#catching-errors) that can be thrown.

Afterwards, we will look at all three types of errors that your bot can encounter.

| Name                                     | Purpose                                                                                                   |
| ---------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| [`BotError`](#the-boterror-object)       | Error object that wraps any error thrown in your middleware (for example, the two errors below)           |
| [`GrammyError`](#the-grammyerror-object) | Thrown if the Bot API server returns `ok: false`, indicating that your API request was invalid and failed |
| [`HttpError`](#the-httperror-object)     | Thrown if the Bot API server could not be reached                                                         |

A more advanced error handling mechanism can be found [down here](#error-boundaries).

## Catching Errors

How you catch errors will depend on your setup.

### Long Polling

If you run your bot via `bot.start()`, or if you are using [grammY runner](../plugins/runner), then you should **install an error handler via `bot.catch`**.

grammY has a default error handler installed that stops the bot if it was started by `bot.start()`.
It then re-throws the error.
It depends on the platform what will happen next.
That is why **you should install an error handler via `bot.catch`**.

Example:

```ts
bot.catch((err) => {
  const ctx = err.ctx;
  console.error(`Error while handling update ${ctx.update.update_id}:`);
  const e = err.error;
  if (e instanceof GrammyError) {
    console.error("Error in request:", e.description);
  } else if (e instanceof HttpError) {
    console.error("Could not contact Telegram:", e);
  } else {
    console.error("Unknown error:", e);
  }
});
```

### Webhooks

If you run your bot via webhooks, grammY will pass the error on to the web framework that you use, e.g. `express`.
You should handle errors according to the conventions of that framework.

## The `BotError` Object

The `BotError` object bundles up a thrown error with the corresponding [context object](./context) that caused the error to be thrown.
This works as follows.

Whatever error occurs while processing an update, grammY will catch the thrown error for you.
It is often useful to access the context object that caused the error.

grammY does not touch the thrown error in any way, but instead wraps it into an instance of `BotError`.
Given that object is named `err`, you can then access the original error via `err.error`.
You can access the respective context object via `err.ctx`.

Check out the `BotError` class in the [grammY API Reference](/ref/core/boterror).

## The `GrammyError` Object

If an API method like `sendMessage` fails, grammY will throw a `GrammyError`.
Note that also `GrammyError` instances will be wrapped in `BotError` objects if they are thrown in middleware.

A thrown `GrammyError` indicates that the corresponding API request failed.
The error provides access to the error code returned by the Telegram backend, as well as the description.

Check out the `GrammyError` class in the [grammY API Reference](/ref/core/grammyerror).

## The `HttpError` Object

An `HttpError` is thrown if a network request fails.
This means that grammY was unable to contact the Bot API server.
The error object holds information about why the request failed, which are available under the `error` property.

You will rarely see this kind of error, unless your network infrastructure is unstable, or the Bot API server of your bot is temporarily offline.

> Note that if the Bot API server can be contacted, but it returns `ok: false` for a given method call, a [`GrammyError`](./errors#the-grammyerror-object) is thrown instead.

Check out the `HttpError` class in the [grammY API Reference](/ref/core/httperror).

## Error Boundaries

> This is an advanced topic that is mostly useful for larger bots.
> If you are relatively new to grammY, simply skip the remainder of this section.

If you divide your code base into different parts, _error boundaries_ allow you install different error handlers for different parts of your middleware.
They achieve this by letting you fence errors in a part of your middleware.
In other words, if an error is thrown in a specially protected part of middleware, it will not be able to escape from that part of the middleware system.
Instead, a dedicated error handler is invoked, and the surrounded part of the middleware pretends to complete successfully.
This is a feature of grammY's middleware system, so error boundaries don't care whether you're running your bot with webhooks or long polling.

Optionally, you may choose to instead let the middleware execution _resume_ normally after the error was handled, continuing right outside the error boundary.
In that case, the fenced middleware does not only act as if it had completed successfully, but it also passes on the control flow to the next middleware that was installed after the error boundary.
Thus, it looks like the middleware inside the error boundary has called `next`.

```ts
const bot = new Bot("");

bot.use(/* A */);
bot.use(/* B */);

const composer = new Composer();
composer.use(/* X */);
composer.use(/* Y */);
composer.use(/* Z */);
bot.errorBoundary(boundaryHandler /* , Q */).use(composer);

bot.use(/* C */);
bot.use(/* D */);

bot.catch(errorHandler);

function boundaryHandler(err: BotError, next: NextFunction) {
  console.error("Error in Q, X, Y, or Z!", err);
  /*
   * You could call `next` if you want to run
   * the middleware at C in case of an error:
   */
  // await next()
}

function errorHandler(err: BotError) {
  console.error("Error in A, B, C, or D!", err);
}
```

In the above example, the `boundaryHandler` will be invoked for

1. all middlewares that are passed to `bot.errorBoundary` after `boundaryHandler` (i.e. `Q`), and
2. all middlewares that are installed on subsequently installed composer instances (i.e. `X`, `Y`, and `Z`).

> Regarding point 2, you may want to skip ahead to the [advanced explanation](../advanced/middleware) of middleware to learn how chaining works in grammY.

You can also apply an error boundary to a composer without calling `bot.errorBoundary`:

```ts
const composer = new Composer();

const protected = composer.errorBoundary(boundaryHandler);
protected.use(/* B */);

bot.use(composer);
bot.use(/* C */);

bot.catch(errorHandler);

function boundaryHandler(err: BotError, next: NextFunction) {
  console.error("Error in B!", err);
}

function errorHandler(err: BotError) {
  console.error("Error in C!", err);
}
```

The `boundaryHandler` of the above example will be invoked for middlewares bound to `protected`.

If you actively want the error to cross a boundary (that is, pass it outside), you can re-throw the error inside your error handler.
The error will then be passed to the next surrounding boundary.

In a sense, you can regard the error handler installed via `bot.catch` as the outermost error boundary.
</file>

<file path="site/docs/guide/files.md">
# File Handling

Telegram bots can not only send and receive text messages, but also many other kinds of messages, such as photos and videos.
This involves handling the files that are attached to the messages.

## How Files Work for Telegram Bots

> This section explains how files work for Telegram bots.
> If you want to know how you can work with files in grammY, scroll down for [downloading](#receiving-files) and [uploading](#sending-files) files.

Files are stored separately from messages.
A file on the Telegram servers is identified by a `file_id`, which is just a long string of characters.
For example, it could look like `AgADBAADZRAxGyhM3FKSE4qKa-RODckQHxsoABDHe0BDC1GzpGACAAEC`.

### Identifiers for Receiving Files

> Bots only receive file identifiers.
> If they want to obtain file contents, they have to request them explicitly.

Whenever your bot **receives** a message with a file, it will in fact not directly receive the complete file data, but only the `file_id` instead.
If your bot actually wants to download the file, then it can do so by calling the `getFile` method ([Telegram Bot API reference](https://core.telegram.org/bots/api#getfile)).
This method enables you to download the file by constructing a special, temporary, URL.
Note that this URL is only guaranteed to be valid for 60 minutes, after which it may expire. In this case, you can simply call `getFile` again.

Files can be received like [this](#receiving-files).

### Identifiers for Sending Files

> Sending files gives you a file identifier, too.

Whenever your bot **sends** a message with a file, it will receive information about the sent message, including the `file_id` of the sent file.
This means that all files the bot sees, both via sending or receiving, will make a `file_id` available to the bot.
If you want to work with a file after your bot sees it, you should always store its `file_id`.

> Use file identifiers whenever you can.
> They are very efficient.

When a bot sends a message, it can **specify a `file_id` that it has seen before**.
This will allow it to send the identified file, without needing to upload the data for it.

You can reuse the same `file_id` as often as you want, so you could send the same file to five different chats, using the same `file_id`.
However, you must make sure to use the correct method---for example, you cannot use a `file_id` that identifies a photo when calling [`sendVideo`](https://core.telegram.org/bots/api#sendvideo).

Files can be sent like [this](#sending-files).

### Identifiers May Surprise You

> File identifiers **only work for your bot**.
> If another bot uses your file identifiers, it may randomly work and randomly crash and randomly kill innocent kittens.
> :cat: → :skull:

Every bot has its own set of `file_id`s for the files that it can access.
You cannot reliably use a `file_id` from your friend's bot, to access a file with _your_ bot.
Each bot will use different identifiers for the same file.
This implies that you cannot simply guess a `file_id` and access some random person's file, because Telegram keeps track of which `file_id`s are valid for your bot.

::: warning Using Foreign `file_id`s
Note that in some cases it _is_ technically possible that a `file_id` from another bot seems to work correctly.
**However**, using a foreign `file_id` like this is dangerous as it can stop working at any time, without warning.
So, always ensure that any `file_id`s you use were originally for your bot.
:::

> A file can have several file identifiers.

On the other hand, it is possible that a bot eventually sees the same file identified by different `file_id`s.
This means that you cannot rely on comparing `file_id`s to check if two files are the same.
If you need to identify the same file over time (or across multiple bots), you should use the `file_unique_id` value that your bot receives along with every `file_id`.

The `file_unique_id` cannot be used to download files, but will be the same for any given file, across every bot.

## Receiving Files

You can handle files just like any other message.
For example, if you want to listen for voice messages, you can do this:

```ts
bot.on("message:voice", async (ctx) => {
  const voice = ctx.msg.voice;

  const duration = voice.duration; // in seconds
  await ctx.reply(`Your voice message is ${duration} seconds long.`);

  const fileId = voice.file_id;
  await ctx.reply("The file identifier of your voice message is: " + fileId);

  const file = await ctx.getFile(); // valid for at least 1 hour
  const path = file.file_path; // file path on Bot API server
  await ctx.reply("Download your own file again: " + path);
});
```

::: tip Passing a Custom file_id to getFile
On the context object, `getFile` is a [shortcut](./context#shortcuts), and will fetch information for a file on the current message.
If you want to get a different file while handling a message, use `ctx.api.getFile(file_id)` instead.
:::

> Check out the [`:media` and `:file` shortcuts](./filter-queries#shortcuts) for filter queries if you want to receive any kind of file.

Once you have called `getFile`, you can use the returned `file_path` to download the file using this URL `https://api.telegram.org/file/bot<token>/<file_path>`, where `<token>` must be replaced by your bot token.

If you [run your own Bot API server](./api#running-a-local-bot-api-server), the `file_path` will instead be an absolutely file path that points to a file on your local disk.
In that case, you do not need to download anything anymore, as the Bot API server downloads the file for you when calling `getFile`.

::: tip Files Plugin
grammY does not come bundled with its own file downloader, but you can install the [official files plugin](../plugins/files).
This allows you to download files via `await file.download()`, and to obtain a download URL for them via `file.getUrl()`.
:::

## Sending Files

Telegram bots have [three ways](https://core.telegram.org/bots/api#sending-files) to send files:

1. Via `file_id`, i.e. by sending a file by an identifier that is already known to the bot.
2. Via URL, i.e. by passing a public file URL, which Telegram downloads and sends for you.
3. Via uploading your own file.

In all cases, the methods you need to call are named the same.
Depending on which of the three ways you pick to send your file, the parameters to these functions will vary.
For example, to send a photo, you can use `ctx.replyWithPhoto` (or `sendPhoto` if you use `ctx.api` or `bot.api`).

You can send other types of files by simply renaming the method and changing the type of the data you pass to it.
In order to send a video, you can use `ctx.replyWithVideo`.
It's the same case for a document: `ctx.replyWithDocument`.
You get the idea.

Let's dive into what the three ways of sending a file are.

### Via `file_id` or URL

The first two methods are simple: you just pass the respective value as a `string`, and you're done.

```ts
// Send via file_id.
await ctx.replyWithPhoto(existingFileId);

// Send via URL.
await ctx.replyWithPhoto("https://grammy.dev/images/grammY.png");

// Alternatively, you use bot.api.sendPhoto() or ctx.api.sendPhoto().
```

### Uploading Your Own Files

grammY has good support for uploading your own files.
You can do this by importing and using the `InputFile` class ([grammY API Reference](/ref/core/inputfile)).

```ts
// Send a file via local path
await ctx.replyWithPhoto(new InputFile("/tmp/picture.jpg"));

// alternatively, use bot.api.sendPhoto() or ctx.api.sendPhoto()
```

The `InputFile` constructor not only takes file paths, but also streams, `Buffer` objects, async iterators, and---depending on your platform---more, or a function that creates any of these things.
All you need to remember is: **create an instance of `InputFile` and pass it to any method to send a file**.
Instances of `InputFile` can be passed to all methods that accept sending files by upload.

Here are some examples on how you can construct `InputFile`s.

#### Uploading a File From Disk

If you already have a file stored on your machine, you can let grammY upload this file.

::: code-group

```ts [Node.js]
import { createReadStream } from "fs";

// Send a local file.
new InputFile("/path/to/file");

// Send from a read stream.
new InputFile(createReadStream("/path/to/file"));
```

```ts [Deno]
// Send a local file.
new InputFile("/path/to/file");

// Send a `Deno.FsFile` instance.
new InputFile(await Deno.open("/path/to/file"));
```

:::

#### Uploading Raw Binary Data

You can also send a `Buffer` object, or an iterator that yields `Buffer` objects.
On Deno, you can send `Blob` objects, too.

::: code-group

```ts [Node.js]
// Send a buffer or a byte array.
const buffer = Uint8Array.from([65, 66, 67]);
new InputFile(buffer); // "ABC"
// Send an iterable.
new InputFile(function* () {
  // "ABCABCABCABC"
  for (let i = 0; i < 4; i++) yield buffer;
});
```

```ts [Deno]
// Send a blob.
const blob = new Blob(["ABC"], { type: "text/plain" });
new InputFile(blob);
// Send a buffer or a byte array.
const buffer = Uint8Array.from([65, 66, 67]);
new InputFile(buffer); // "ABC"
// Send an iterable.
new InputFile(function* () {
  // "ABCABCABCABC"
  for (let i = 0; i < 4; i++) yield buffer;
});
```

:::

#### Downloading and Reuploading a File

You can even make grammY download a file from the internet.
This will not actually save the file on your disk.
Instead, grammY will only pipe through the data, and only keep a small chunk of it in memory.
This is very efficient.

> Note that Telegram supports downloading the file for you in many methods.
> If possible, you should prefer to [send the file via URL](#via-file-id-or-url), instead of using `InputFile` to stream the file contents through your server.

```ts
// Download a file, and stream the response to Telegram.
new InputFile(new URL("https://grammy.dev/images/grammY.png"));
new InputFile({ url: "https://grammy.dev/images/grammY.png" }); // equivalent
```

### Adding a Caption

When sending files, you can specify further options in an options object of type `Other`, exactly as explained [earlier](./basics#sending-messages).
For example, this lets you send captions.

```ts
// Send a photo from a local file to user 12345 with the caption "photo.jpg".
await bot.api.sendPhoto(12345, new InputFile("/path/to/photo.jpg"), {
  caption: "photo.jpg",
});
```

As always, just like with all other API methods, you can send files via `ctx` (easiest), `ctx.api`, or `bot.api`.

## File Size Limits

grammY itself can send files without any size limits, however, Telegram restricts file sizes as documented [here](https://core.telegram.org/bots/api#sending-files).
This means that your bot cannot download files larger than 20 MB, or upload files larger than 50 MB.
Some combinations have even stricter limits, such as photos sent by URL (5 MB).

As mentioned in an [earlier section](./api), your bot is able to work with large files with some extra effort.
If you want to support uploading files up to 2000 MB (maximum file size on Telegram) and downloading files of any size ([4000 MB with Telegram Premium](https://t.me/premium/5)), you must [host your own Bot API server](./api#running-a-local-bot-api-server) in addition to hosting your bot.

Hosting your own Bot API server has, in and of itself, nothing to do with grammY.
However, grammY supports all of the methods that are needed to configure your bot to use your own Bot API Server.
</file>

<file path="site/docs/guide/filter-queries.md">
# Filter Queries and `bot.on()`

The first argument of `bot.on()` is a string called _filter query_.

## Introduction

Most (all?) other bot frameworks allow you to perform a primitive form of filtering for updates, e.g. only `on("message")` and the like.
Other filtering of messages is left to the developer, which often leads to endless `if` statements in their code.

On the contrary, **grammY ships with its own query language** that you can use in order to **filter for exactly the messages** you want.

This allows for over 1150 different filters to be used, and we may add more over time.
Every valid filter can be auto-completed in your code editor.
Hence, you can simply type `bot.on("")`, open auto-complete, and search through all queries by typing something.

![Filter Query Search](/images/filter-query-search.png)

The type inference of `bot.on()` will comprehend the filter query you picked.
It therefore tightens a few types on the context that are known to exist.

```ts
bot.on("message", async (ctx) => {
  // Could be undefined if the received message has no text.
  const text: string | undefined = ctx.msg.text;
});
bot.on("message:text", async (ctx) => {
  // Text is always present because this handler is called when a text message is received.
  const text: string = ctx.msg.text;
});
```

In a sense, grammY implements the filter queries both [at runtime](#performance), and [on the type level](#type-safety).

## Example Queries

Here are some example queries:

### Regular Queries

Simple filters for updates, and sub-filters:

```ts
bot.on("message"); // called when any message is received
bot.on("message:text"); // only text messages
bot.on("message:photo"); // only photo messages
```

### Filter for Entities

Sub-filters that go one level deeper:

```ts
bot.on("message:entities:url"); // messages containing a URL
bot.on("message:entities:code"); // messages containing a code snippet
bot.on("edited_message:entities"); // edited messages with any kind of entities
```

### Omit Values

You can omit some values in the filter queries.
grammY will then search through different values to match your query.

```ts
bot.on(":text"); // any text messages and any text post of channels
bot.on("message::url"); // messages with URL in text or caption (photos, etc)
bot.on("::email"); // messages or channel posts with email in text or caption
```

Leaving out the _first_ value matches both messages and channel posts.
[Remember](./context#available-actions) that `ctx.msg` gives you access to both messages or channel posts, whichever is matched by the query.

Leaving out the _second_ value matches both entities and caption entities.
You can leave out both the first and the second part at the same time.

### Shortcuts

The query engine of grammY allows to define neat shortcuts that group related queries together.

#### `msg`

The `msg` shortcut groups new messages and new channel posts.
In other words, using `msg` is equivalent to listening for both `"message"` and `"channel_post"` events.

```ts
bot.on("msg"); // any message or channel post
bot.on("msg:text"); // exactly the same as `:text`
```

#### `edit`

This `edit` shortcut groups edited messages and edited channel posts.
In other words, using `edit` is equivalent to listening for both `"edited_message"` and `"edited_channel_post"` events.

```ts
bot.on("edit"); // any message or channel post edit
bot.on("edit:text"); // edits of text messages
bot.on("edit::url"); // edits of messages with URL in text or caption
bot.on("edit:location"); // live location updated
```

#### `:media`

The `:media` shortcut groups photo and video messages.
In other words, using `:media` is equivalent to listening for both `":photo"` and `":video"` events.

```ts
bot.on("message:media"); // photo and video messages
bot.on("edited_channel_post:media"); // edited channel posts with media
bot.on(":media"); // media messages or channel posts
```

#### `:file`

The `:file` shortcut groups all messages that contain a file.
In other words, using `:file` is equivalent to listening for `":photo"`, `":animation"`, `":audio"`, `":document"`, `":video"`, `":video_note"`, `":voice"`, and `":sticker"` events.
Hence, you can be sure that `await ctx.getFile()` will give you a file object.

```ts
bot.on(":file"); // files in messages or channel posts
bot.on("edit:file"); // edits to file messages or file channel posts
```

### Syntactic Sugar

There are two special cases for the query parts that make filtering for users more convenient.
You can detect bots in queries with the `:is_bot` query part.
The syntactic sugar `:me` can be used to refer to your bot from within a query, which will compare the user identifiers for you.

```ts
// A service message about a bot that joined the chat
bot.on("message:new_chat_members:is_bot");
// A service message about your bot being removed
bot.on("message:left_chat_member:me");
```

Note that while this syntactic sugar is useful to work with service messages, it should not be used to detect if someone actually joins or leaves a chat.
Services messages are messages that inform the users in the chat, and some of them will not be visible in all cases.
For example, in large groups, there will not be any service messages about users that join or leave the chat.
Hence, your bot may not notice this.
Instead, you should listen for [chat member updates](#chat-member-updates).

## Combining Multiple Queries

You can combine any number of filter queries with AND as well as OR operations.

### Combine With OR

If you want to install some piece of middleware behind the OR concatenation of two queries, you can pass both of them to `bot.on()` in an array.

```ts
// Runs if the update is about a message OR an edit to a message
bot.on(["message", "edited_message"] /* , ... */);
// Runs if a hashtag OR email OR mention entity is found in text or caption
bot.on(["::hashtag", "::email", "::mention"] /* , ... */);
```

The middleware will be executed if _any of the provided queries_ matches.
The order of the queries does not matter.

### Combine With AND

If you want to install some piece of middleware behind the AND concatenation of two queries, you can chain the calls to `bot.on()`.

```ts
// Matches forwarded URLs
bot.on("::url").on(":forward_origin" /* , ... */);
// Matches photos that contain a hashtag in a photo's caption
bot.on(":photo").on("::hashtag" /* , ... */);
```

The middleware will be executed if _all of the provided queries_ match.
The order of the queries does not matter.

### Building Complex Queries

It is technically possible to combine filter queries to more complicated formulas if they are in [CNF](https://en.wikipedia.org/wiki/Conjunctive_normal_form), even though this is unlikely to be useful.

```ts
bot
  // Matches all channel posts or forwarded messages ...
  .on(["channel_post", ":forward_origin"])
  // ... that contain text ...
  .on(":text")
  // ... with at least one URL, hashtag, or cashtag.
  .on(["::url", "::hashtag", "::cashtag"] /* , ... */);
```

The type inference of `ctx` will scan through the entire call chain and inspect every element of all three `.on` calls.
As an example, it can detect that `ctx.msg.text` is a required property for the above code snippet.

## Useful Tips

Here are some less-known features of filter queries that can come in handy.
Some of them are a little advanced, so feel free to move on to the [next section](./commands).

### Chat Member Updates

You can use the following filter query to receive status updates about your bot.

```ts
bot.on("my_chat_member"); // block, unblock, join, or leave
```

In private chats, this triggers when the bot is blocked or unblocked.
In groups, this triggers when the bot is added or removed.
You can now inspect `ctx.myChatMember` to figure out what exactly happened.

This is not to be confused with

```ts
bot.on("chat_member");
```

which can be used to detect status changes of other chat members, such as when people join, get promoted, and so on.

> Note that `chat_member` updates need to be enabled explicitly by specifying `allowed_updates` when starting your bot.

### Combining Queries With Other Methods

You can combine filter queries with other methods on the `Composer` class ([API Reference](/ref/core/composer)), such as `command` or `filter`.
This allows for powerful message handling patterns.

```ts
bot.on(":forward_origin").command("help"); // forwarded /help commands

// Only handle commands in private chats.
const pm = bot.chatType("private");
pm.command("start");
pm.command("help");
```

### Filtering by Message Sender Type

There are five different possible types of message authors on Telegram:

1. Channel post authors
2. Automatic forwards from linked channels in discussion groups
3. Normal user accounts, this includes bots (i.e. "normal" messages)
4. Admins sending on behalf of the group ([anonymous admins](https://telegram.org/blog/filters-anonymous-admins-comments#anonymous-group-admins))
5. Users sending messages as one of their channels

You can combine filter queries with other update handling mechanisms to find out the type of the message author.

```ts
// Channel posts sent by `ctx.senderChat`
bot.on("channel_post");

// Automatic forward from the channel `ctx.senderChat`:
bot.on("message:is_automatic_forward");
// Regular messages sent by `ctx.from`
bot.on("message").filter((ctx) => ctx.senderChat === undefined);
// Anonymous admin in `ctx.chat`
bot.on("message").filter((ctx) => ctx.senderChat?.id === ctx.chat.id);
// Users sending messages on behalf of their channel `ctx.senderChat`
bot.on("message").filter((ctx) =>
  ctx.senderChat !== undefined && ctx.senderChat.id !== ctx.chat.id
);
```

### Filtering by User Properties

If you want to filter by other properties of a user, you need to perform an additional request, e.g. `await ctx.getAuthor()` for the author of the message.
Filter queries will not secretly perform further API requests for you.
It is still simple to perform this kind of filtering:

```ts
bot.on("message").filter(
  async (ctx) => {
    const user = await ctx.getAuthor();
    return user.status === "creator" || user.status === "administrator";
  },
  (ctx) => {
    // Handles messages from creators and admins.
  },
);
```

### Reusing Filter Query Logic

Internally, `bot.on` relies on a function called `matchFilter`.
It takes a filter query and compiles it down to a predicate function.
The predicate is simply passed to `bot.filter` in order to filter for updates.

You can import `matchFilter` directly if you want to use it in your own logic.
For example, you can decide to drop all updates that match a certain query:

```ts
// Drop all text messages or text channel posts.
bot.drop(matchFilter(":text"));
```

Analogously, you can make use of the filter query types that grammY uses internally:

### Reusing Filter Query Types

Internally, `matchFilter` uses TypeScript's [type predicates](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) to narrow down the type of `ctx`.
It takes a type `C extends Context` and a `Q extends FilterQuery` and produces `ctx is Filter<C, Q>`.
In other words, the `Filter` type is what you actually receive for your `ctx` in the middleware.

You can import `Filter` directly if you want to use it in your own logic.
For example, you can decide to define a handler function that handles specific context objects which were filtered by a filter query:

```ts
function handler(ctx: Filter<Context, ":text">) {
  // handle narrowed context object
}

bot.on(":text", handler);
```

> Check out the API references for [`matchFilter`](/ref/core/matchfilter), [`Filter`](/ref/core/filter), and [`FilterQuery`](/ref/core/filterquery) to read on.

## The Query Language

> This section is meant for users who want to have a deeper understanding of filter queries in grammY, but it does not contain any knowledge required to create a bot.

### Query Structure

Every query consists of up to three query parts.
Depending on how many query parts a query has, we differentiate between L1, L2, and L3 queries, such as `"message"`, `"message:entities"`, and `"message:entities:url"`, respectively.

The query parts are separated by colons (`:`).
We refer to the part up to the first colon or the end of the query string as the _L1 part_ of a query.
We refer to the part from the first colon to the second colon or to the end of the query string as the _L2 part_ of the query.
We refer to the part from the second colon to the end of the query string as the _L3 part_ of the query.

Example:

| Filter Query                 | L1 part     | L2 part      | L3 part     |
| ---------------------------- | ----------- | ------------ | ----------- |
| `"message"`                  | `"message"` | `undefined`  | `undefined` |
| `"message:entities"`         | `"message"` | `"entities"` | `undefined` |
| `"message:entities:mention"` | `"message"` | `"entities"` | `"mention"` |

### Query Validation

Even though the type system should catch all invalid filter queries at compile time, grammY also checks all passed filter queries at runtime during setup.
Every passed filter query is matched against a validation structure that checks if it is valid.
Not only is it good to fail immediately during setup instead of at runtime, it has also happened before that bugs in TypeScript cause serious problems with the sophisticated type inference system that powers filter queries.
If this happens again in the future, this will prevent issues that could otherwise occur.
In this case, you will be provided with helpful error messages.

### Performance

**grammY can check every filter query in (amortized) constant time per update**, independent of the structure of the query or the incoming update.

The validation of the filter queries happens only once, when the bot is initialized and `bot.on()` is called.

On start-up, grammY derives a predicate function from the filter query by splitting it into its query parts.
Every part will be mapped to a function that performs a single truthiness check for an object property, or two checks if the part is omitted and two values need to be checked.
These functions are then combined to form a predicate that only has to check for as many values as are relevant for the query, without iterating over the object keys of `Update`.

This system uses less operations than some competing libraries, which need to perform containment checks in arrays when routing updates.
grammY's filter query system is faster despite being much more powerful.

### Type Safety

As mentioned above, filter queries will automatically narrow down certain properties on the context object.
The predicate derived from one or more filter queries is a TypeScript type predicate that performs this narrowing.
In general, you can trust that type inference works correctly.
If a property is inferred to be present, you can safely rely on it.
If a property is inferred to be potentially absent, then this means that there are certain cases of it missing.
It is not a good idea to perform type casts with the `!` operator.

> It may not be obvious to you what those cases are.
> Don't hesitate to ask in the [group chat](https://t.me/grammyjs) if you cannot figure it out.

Computing these types is complicated.
A lot of knowledge about the Bot API went into this part of grammY.
If you want to understand more about the basic approaches to how these types are computed, there is a [talk on YouTube](https://youtu.be/ZvT_xexjnMk) that you can watch.
</file>

<file path="site/docs/guide/games.md">
# Games

## Introduction

Telegram Games is a very interesting feature and it is great fun to play with.
What can you do with it?
The answer is anything, any HTML5 game that you have developed you can provide to users on Telegram with the help of this feature.
(Yes, this means that you will have to develop a real website-based game that is publicly accessible on the internet before you can integrate it into your Telegram bot.)

## Setting Up a Game With Your Bot via @BotFather

For simplicity, let's assume that by now you must have set up a bot and a game associated with your bot on [@BotFather](https://t.me/BotFather).
If you haven't already, check out this [article](https://core.telegram.org/bots/games) by the Telegram team.

> Note: We will only learn the bot side development.
> Developing the game is entirely up to the developer.
> All we need here is a link of the HTML5 game hosted on the internet.

## Sending the Game via a Bot

We can send the game in grammY via the `replyWithGame` method which takes the name of the game you created with BotFather as argument.
Alternatively, we can also use the `api.sendGame` method (grammY provides all the official [Bot API](https://core.telegram.org/bots/api) methods).
An advantage of using the `api.sendGame` method is you can specify the `chat.id` of a specific user to send it to.

1. Sending Game via `replyWithGame`

   ```ts
   // We will be using the start command to invoke the game reply method.
   bot.command("start", async (ctx) => {
     // Pass the name of the game you created in BotFather, for example "my_game".
     await ctx.replyWithGame("my_game");
   });
   ```

2. Sending a Game via `api.sendGame`

   ```ts
   bot.command("start", async (ctx) => {
     // You can get the chat identifier of the user to send your game to with `ctx.from.id`.
     // which gives you the chat identifier of the user who invoked the start command.
     const chatId = ctx.from.id;
     await ctx.api.sendGame(chatid, "my_game");
   });
   ```

> [Remember](./basics#sending-messages) that you can specify further options when sending messages by using the options object of type `Other`.

You can also specify a custom [inline keyboard](../plugins/keyboard#inline-keyboards) for the game to show buttons.
By default, it will be sent with a button with name as `Play my_game`, where _my_game_ is the name of your game.

```ts
// Define a new inline keyboard. You can write any text to be shown
// on the button, but make sure that the first button should always
// be the play button!

const keyboard = new InlineKeyboard().game("Start my_game");

// Notice that we have used game() unlike a normal inline keyboard
// where we use url() or text()

// Via the `replyWithGame` method
await ctx.replyWithGame("my_game", { reply_markup: keyboard });

// Via the `api.sendGame` method
await ctx.api.sendGame(chatId, "my_game", { reply_markup: keyboard });
```

## Listening to the Callback of Our Game Button

For providing logic to the button when it is pressed, and to redirect our users to our game and many more, we listen to the event `callback_query:game_short_name` which tells us that a game button has been pressed by the user.
All we need to do is:

```ts
// Pass your game url here that should be already hosted on the web.

bot.on("callback_query:game_short_name", async (ctx) => {
  await ctx.answerCallbackQuery({ url: "your_game_url" });
});
```

---

### Our Final Code Should Look Something Like This

```ts
bot.on("callback_query:game_short_name", async (ctx) => {
  await ctx.answerCallbackQuery({ url: "your_game_url" });
});

bot.command("start", async (ctx) => {
  await ctx.replyWithGame("my_game", {
    reply_markup: keyboard,
    // Or you can use the api method here, according to your needs.
  });
});
```

> Remember to add proper [error handling](./errors) to your bot before going live.

We may extend this article in the future by further advanced sections and FAQ's, but this is already all you need to start your game in Telegram.
Have fun playing! :space_invader:
</file>

<file path="site/docs/guide/getting-started.md">
# Getting Started

Create your first bot in minutes. (Scroll [down](#getting-started-on-deno) for a Deno guide.)

## Getting Started on Node.js

> This guide assumes that you have [Node.js](https://nodejs.org) installed, and `npm` should come with it.
> If you don't know what these things are, check out our [Introduction](./introduction)!

Create a new TypeScript project and install the `grammy` package.
Do this by opening a terminal and typing:

::: code-group

```sh [npm]
# Create a new directory and change into it.
mkdir my-bot
cd my-bot

# Set up TypeScript (skip if you use JavaScript).
npm install -D typescript
npx tsc --init

# Install grammY.
npm install grammy
```

```sh [Yarn]
# Create a new directory and change into it.
mkdir my-bot
cd my-bot

# Set up TypeScript (skip if you use JavaScript).
yarn add typescript -D
npx tsc --init

# Install grammY.
yarn add grammy
```

```sh [pnpm]
# Create a new directory and change into it.
mkdir my-bot
cd my-bot

# Set up TypeScript (skip if you use JavaScript).
pnpm add -D typescript
npx tsc --init

# Install grammY.
pnpm add grammy
```

:::

Create a new empty text file, e.g. called `bot.ts`.
Your folder structure should now look like this:

```asciiart:no-line-numbers
.
├── bot.ts
├── node_modules/
├── package.json
├── package-lock.json
└── tsconfig.json
```

Now, it's time to open Telegram to create a bot account, and obtain a bot token for it.
Talk to [@BotFather](https://t.me/BotFather) to do this.
The bot token looks like `123456:aBcDeF_gHiJkLmNoP-q`.
It is used to authenticate your bot.

Got the token? You can now code your bot in the `bot.ts` file.
You can copy the following example bot into that file, and pass your token to the `Bot` constructor:

::: code-group

```ts [TypeScript]
import { Bot } from "grammy";

// Create an instance of the `Bot` class and pass your bot token to it.
const bot = new Bot(""); // <-- put your bot token between the ""

// You can now register listeners on your bot object `bot`.
// grammY will call the listeners when users send messages to your bot.

// Handle the /start command.
bot.command("start", (ctx) => ctx.reply("Welcome! Up and running."));
// Handle other messages.
bot.on("message", (ctx) => ctx.reply("Got another message!"));

// Now that you specified how to handle messages, you can start your bot.
// This will connect to the Telegram servers and wait for messages.

// Start the bot.
bot.start();
```

```js [JavaScript]
const { Bot } = require("grammy");

// Create an instance of the `Bot` class and pass your bot token to it.
const bot = new Bot(""); // <-- put your bot token between the ""

// You can now register listeners on your bot object `bot`.
// grammY will call the listeners when users send messages to your bot.

// Handle the /start command.
bot.command("start", (ctx) => ctx.reply("Welcome! Up and running."));
// Handle other messages.
bot.on("message", (ctx) => ctx.reply("Got another message!"));

// Now that you specified how to handle messages, you can start your bot.
// This will connect to the Telegram servers and wait for messages.

// Start the bot.
bot.start();
```

:::

Compile the code by running

```sh
npx tsc
```

in your terminal.
This generates the JavaScript file `bot.js`.

You can now run the bot by executing

```sh
node bot.js
```

in your terminal.
Done! :tada:

Head over to Telegram to watch your bot respond to messages!

::: tip Enabling Logging
You can enable basic logging by running

```sh
export DEBUG="grammy*"
```

in your terminal before you execute `node bot.js`.
This makes it easier to debug your bot.
:::

## Getting Started on Deno

> This guide assumes that you have [Deno](https://deno.com) installed.

Create a new directory somewhere and create a new empty text file in it, e.g. called `bot.ts`.

```sh
mkdir ./my-bot
cd ./my-bot
touch bot.ts
```

Now, it's time to open Telegram to create a bot account, and obtain a bot token for it.
Talk to [@BotFather](https://t.me/BotFather) to do this.
The bot token looks like `123456:aBcDeF_gHiJkLmNoP-q`.
It is used to authenticate your bot.

Got the token? You can now code your bot in the `bot.ts` file.
You can copy the following example bot into that file, and pass your token to the `Bot` constructor:

```ts
import { Bot } from "https://deno.land/x/grammy/mod.ts";

// Create an instance of the `Bot` class and pass your bot token to it.
const bot = new Bot(""); // <-- put your bot token between the ""

// You can now register listeners on your bot object `bot`.
// grammY will call the listeners when users send messages to your bot.

// Handle the /start command.
bot.command("start", (ctx) => ctx.reply("Welcome! Up and running."));
// Handle other messages.
bot.on("message", (ctx) => ctx.reply("Got another message!"));

// Now that you specified how to handle messages, you can start your bot.
// This will connect to the Telegram servers and wait for messages.

// Start the bot.
bot.start();
```

You can now run the bot by executing

```sh
deno -IN bot.ts
```

in your terminal.
The `-IN` is short for `--allow-import --allow-net`.
These permissions have to be specified because Deno is [secure by default](https://docs.deno.com/runtime/fundamentals/security/).

Done! :tada:

Head over to Telegram to watch your bot respond to messages!

::: tip Enabling Logging
You can enable basic logging by running

```sh
export DEBUG="grammy*"
```

in your terminal before you run your bot.
This makes it easier to debug your bot.

You now need to grant the bot `--allow-env` permissions and run it using

```sh
deno -EIN bot.ts
```

so grammY can detect that `DEBUG` is set.
:::
</file>

<file path="site/docs/guide/introduction.md">
# Introduction

A Telegram bot is a special user account that is automated by a program.
Anyone can create a Telegram bot, the only prerequisite is that you know a little bit of coding.

> If you already know how to create bots, head over to [Getting Started](./getting-started)!

grammY is a library that makes it super simple to write such a bot.

## How to Write a Bot

Before you begin creating your bot, make yourself familiar with what Telegram bots can and cannot do.
Check out the [Introduction for Developers](https://core.telegram.org/bots) by the Telegram team.

In making your Telegram bot, you will create a text file with the source code of your bot.
(You can also copy one of our example files.)
It defines _what your bot actually does_, i.e. "when a user sends this message, respond with that", and so on.

You can then run that source file.
Your bot will now work, until you stop running it.

You're kinda done now…

## How to Keep a Bot Running

…except, if you are serious about your bot project.
If you stop your bot (or shut down your computer), your bot becomes unresponsive, so it will no longer react to any messages.

> Skip this section if you only want to play around with bots, and [continue down here with the prerequisites](#prerequisites-to-getting-started) to getting started.

Simply put, if you want the bot to be online all the time, you have to keep a computer running 24 hours every day.
Because you most likely don't want to do that with your laptop, you should upload your code to a _hosting provider_ (in other words, someone else's computer, also known as a _server_), and let those people run it for you.

There are countless companies that let you run your Telegram bot for free.
This documentation covers a number of different hosting providers that we know work well with grammY (check the [Hosting](../hosting/comparison) section).
In the end, however, the choice of which provider to pick is up to you.
Remember that running your code somewhere else means that whoever owns that "somewhere" has access to all your messages and the data of your users, so you should pick a provider that you can trust.

Here is a (simplified) diagram of how the setup will look in the end when Alice contacts your bot:

```asciiart:no-line-numbers
_________        sends a         ____________                    ____________
| Alice | —> Telegram message —> | Telegram | —> HTTP request —> | your bot |
—————————      to your bot       ————————————                    ————————————

 a phone                        Telegram servers                  your laptop,
                                                                better: a server


|____________________________________________|                   |___________|
                    |                                                  |
        Telegram's responsibility                             your responsibility
```

Similarly, your bot can make HTTP requests to the Telegram servers to send messages back to Alice.
(If you have never heard of HTTP, you can think of it as the data packages that are sent through the internet, for now.)

## What grammY Does for You

Bots interact with Telegram via HTTP requests.
Every time your bot sends or receives messages, HTTP requests go back and forth between the Telegram servers and your server/computer.

At its core, grammY implements all of this communication for you, so you can simply type `sendMessage` in your code and a message will be sent.
In addition, there are a variety of other helpful things that grammY does to make it simpler to create your bot.
You will get to know them as you go.

## Prerequisites to Getting Started

> Skip the rest of this page if you already know how to develop a Deno or a Node.js application, and [get started](./getting-started).

Here are a few interesting things about programming---things that are essential to coding, yet rarely explained because most developers think they are self-evident.

In the next section, you will create a bot by writing a text file that contains source code in the programming language [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html).
The grammY documentation will not teach you how to program, so we expect you to teach yourself.
Remember, though: creating a Telegram bot with grammY is actually a good way to learn coding! :rocket:

::: tip Learning How to Code
You can start learning TypeScript with the [official tutorial](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html) written by the TypeScript team, and then move on from there.
Don't spend more than 30 minutes reading things on the internet, then come back here, (read the rest of the section) and [get started](./getting-started).

If you see unfamiliar syntax in the docs, or if you get an error message that you don't understand, google it---the explanation is already on the internet (e.g. on Stack Overflow).
:::

::: danger Not Learning How to Code
Save yourself some time by watching this [34-second video](https://youtu.be/8RtGlWmXGhA).
:::

By picking grammY, you have already decided on a programming language, namely TypeScript.
But what happens once you've created your TypeScript code, how will it start running?
For that, you need to install some software which is able to _execute_ your code.
This type of software is called a _runtime environment_.
It takes in your source code files and actually does whatever is programmed in them.

For us, there are two runtime environments to choose from, [Deno](https://deno.com) and [Node.js](https://nodejs.org).
(If you see people call it _Node_, they are just too lazy to type ".js", but they mean the same thing.)

> The rest of this section helps you decide between these two platforms.
> If you already know what you want to use, jump down to the [prerequisites for Node.js](#prerequisites-for-node-js) or [those for Deno](#prerequisites-for-deno).

Node.js is the older, more mature technology.
If you need to connect to a funky database or do other low-level system-related things, chances are extremely high that you can do it with Node.js.
Deno is relatively new, so it is sometimes still lacking support for some advanced things.
Today, most servers use Node.js.

On the other hand side, Deno is significantly easier to learn and to use.
If you don't have much experience with programming yet, **it makes sense to start with Deno**.

Even if you have written code for Node.js before, you should consider giving Deno a go.
Many things that are hard under Node.js are a no-brainer under Deno.

Deno

- is much easier to install,
- does not require you to configure anything about your project,
- uses much less disk space,
- has superior, built-in development tools and great editor integration,
- is way more secure, and
- has many more advantages that do not fit here.

Developing code under Deno is also a lot more fun.
At least, that's our opinion.

However, if you have a reason to use Node.js, for example because you already know it well, then that is completely fine!
We are making sure that grammY works equally well on both platforms, and we are not cutting any corners.
Please choose what you think is best for you.

### Prerequisites for Deno

Before you can start creating your bot, let's first spend a few minutes on a proper setup for software development.
This means installing a few tools.

#### Preparing Your Machine for Development

[Install Deno](https://docs.deno.com/runtime/getting_started/installation/#download-and-install) if you have not done it already.

You also need a text editor that fits well with coding.
The best one for Deno is Visual Studio Code, often just called VS Code.
[Install it.](https://code.visualstudio.com)

Next, you need to connect VS Code and Deno.
That's very simple: There is an extension for VS Code that does everything automatically.
You can install it [as described here](https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno).

Your system is now ready for bot development! :tada:

#### Developing a Bot

Create a new directory somewhere.
It will contain your bot project.
Open this new directory in VS Code.

```sh
mkdir ./my-bot
cd ./my-bot
code .
```

> If you’re on macOS and the `code` command is not available, just open VS Code, hit `Cmd+Shift+P`, type "shell command", and hit Enter.

In VS Code, turn this empty directory into a Deno project.
Hit `Ctrl+Shift+P`, type "deno init", and hit Enter.
The bottom right of your editor should then display the version of Deno installed on your system.

Your Deno development environment is ready.
You can now start writing your bot.
This is explained on the next page.

One last thing:
After you have created your bot, for example in a file called `bot.ts`, you can run it by typing `deno -IN bot.ts` in your terminal.
(Yes, writing software means using the terminal a lot, get used to it.)
You can stop the bot again with `Ctrl+C`.

Ready?
[Get started](./getting-started#getting-started-on-deno)! :robot:

### Prerequisites for Node.js

You are going to write your bot in TypeScript, but, contrary to Deno, Node.js cannot actually run TypeScript.
Instead, once you have a source file (e.g. called `bot.ts`), you are going to _compile_ it to JavaScript.
You will then have two files: your original `bot.ts`, and a generated `bot.js`, which can in turn be run by Node.js.
The exact commands for all of that will be introduced in the next section when you actually create a bot, but it is important to know that these steps are necessary.

In order to run the `bot.js` file, you have to have [Node.js](https://nodejs.org/en/) installed.

In summary, this is what you have to do for Node.js:

1. Create a source file `bot.ts` with TypeScript code, e.g. using [VS Code](https://code.visualstudio.com) (or any other code editor).
2. Compile the code by running a command in your terminal. This generates a file called `bot.js`.
3. Run `bot.js` using Node.js, again from your terminal.

Every time you modify your code in `bot.ts`, you need to restart the Node.js process.
Hit `Ctrl+C` in your terminal to stop the process.
This will stop your bot.
Then, you need to repeat steps 2 and 3.

::: tip Wait, what?
Installing Node.js and setting up and configuring everything correctly takes a lot of time.
If you have never done this before, you should expect to run into plenty of confusing problems that are hard to fix.

This is why we sort of expect that you know how to set up your system, or that you are able to teach yourself.
(Already installing Node.js _the right way_ is so complicated that it does not fit this page.)

If you feel lost at this point, you should leave Node.js behind and use [Deno](#prerequisites-for-deno) instead.
:::

Still confident?
Great!
[Get started](./getting-started#getting-started-on-node-js)! :robot:
</file>

<file path="site/docs/guide/middleware.md">
# Middleware

The listener functions that are being passed to `bot.on()`, `bot.command()`, and their siblings, are called _middleware_.
While it is not wrong to say that they are listening for updates, calling them "listeners" is a simplification.

> This section explains what middleware is, and uses grammY as an example to illustrate how it can be used.
> If you are looking for specific documentation about what makes grammY's implementation of middleware special, check out [Middleware Redux](../advanced/middleware) in the advanced section of the docs.

## The Middleware Stack

Suppose you write a bot like this:

```ts{8}
const bot = new Bot("");

bot.use(session());

bot.command("start", (ctx) => ctx.reply("Started!"));
bot.command("help", (ctx) => ctx.reply("Help text"));

bot.on(":text", (ctx) => ctx.reply("Text!")); // (*)
bot.on(":photo", (ctx) => ctx.reply("Photo!"));

bot.start();
```

When an update with a regular text message arrives, these steps will be performed:

1. You send `"Hi there!"` to the bot.
2. The session middleware receives the update, and does its session things
3. The update will be checked for a `/start` command, which is not contained
4. The update will be checked for a `/help` command, which is not contained
5. The update will be checked for text in the message (or channel post), which succeeds.
6. The middleware at `(*)` will be invoked, it handles the update by replying with `"Text!"`.

The update is **not** checked for a photo content, because the middleware at `(*)` already handled the update.

Now, how does this work?
Let's find out.

We can inspect the `Middleware` type in grammY's reference [here](/ref/core/middleware#type):

```ts
// Omitted some type parameters for brevity.
type Middleware = MiddlewareFn | MiddlewareObj;
```

Aha!
Middleware can be a function or an object.
We only used functions (`(ctx) => { ... }`) so far, so let's ignore middleware objects for now, and dig deeper into the `MiddlewareFn` type ([reference](/ref/core/middlewarefn)):

```ts
// Omitted type parameters again.
type MiddlewareFn = (ctx: Context, next: NextFunction) => MaybePromise<unknown>;
// with
type NextFunction = () => Promise<void>;
```

So, middleware takes two parameters!
We only used one so far, the context object `ctx`.
We [already know](./context) what `ctx` is, but we also see a function with the name `next`.
In order to understand what `next` is, we have to look at all middleware that you install on your bot object as a whole.

You can view all installed middleware functions as a number of layers that are stacked on top of each other.
The first middleware (`session` in our example) is the uppermost layer, hence receiving each update first.
It can then decide if it wants to handle the update, or pass it down to the next layer (the `/start` command handler).
The function `next` can be used to invoke the subsequent middleware, often called _downstream middleware_.
This also means that if you don't call `next` in your middleware, the underlying layers of middleware will not be invoked.

This stack of functions is the _middleware stack_.

```asciiart:no-line-numbers
(ctx, next) => ...    |
(ctx, next) => ...    |—————upstream middleware of X
(ctx, next) => ...    |
(ctx, next) => ...       <— middleware X. Call `next` to pass down updates
(ctx, next) => ...    |
(ctx, next) => ...    |—————downstream middleware of X
(ctx, next) => ...    |
```

Looking back at our earlier example, we now know why `bot.on(":photo")` was never even checked: the middleware in `bot.on(":text", (ctx) => { ... })` already handled the update, and it did not call `next`.
In fact, it did not even specify `next` as a parameter.
It simply ignored `next`, hence not passing on the update.

Let's try out something else with our new knowledge!

```ts
const bot = new Bot("");

bot.on(":text", (ctx) => ctx.reply("Text!"));
bot.command("start", (ctx) => ctx.reply("Command!"));

bot.start();
```

If you run the above bot, and send `/start`, you will never get to see a response saying `Command!`.
Let's inspect what happens:

1. You send `"/start"` to the bot.
2. The `":text"` middleware receives the update and checks for text, which succeeds because commands are text messages.
   The update is handled immediately by the first middleware and your bot replies with "Text!".

The message is never even checked for if it contains the `/start` command!
The order in which you register your middleware matters, because it determines the order of the layers in the middleware stack.
You can fix the issue by flipping the order of lines 3 and 4.
If you called `next` on line 3, two responses would be sent.

**The `bot.use()` function simply registers middleware that receives all updates.**
This is why `session()` is installed via `bot.use()`---we want the plugin to operate on all updates, no matter what data is contained.

Having a middleware stack is an extremely powerful property of any web framework, and this pattern is widely popular (not just for Telegram bots).

Let's write our own little piece of middleware to better illustrate how it works.

## Writing Custom Middleware

We will illustrate the concept of middleware by writing a simple middleware function that can measure the response time of your bot, i.e. how long it takes your bot to handle a message.

Here is the function signature for our middleware.
You can compare it to the middleware type from above, and convince yourself that we actually have middleware here.

::: code-group

```ts [TypeScript]
/** Measures the response time of the bot, and logs it to `console` */
async function responseTime(
  ctx: Context,
  next: NextFunction, // is an alias for: () => Promise<void>
): Promise<void> {
  // TODO: implement
}
```

```js [JavaScript]
/** Measures the response time of the bot, and logs it to `console` */
async function responseTime(ctx, next) {
  // TODO: implement
}
```

:::

We can install it into our `bot` instance with `bot.use()`:

```ts
bot.use(responseTime);
```

Let's begin implementing it.
Here is what we want to do:

1. Once an update arrives, we store `Date.now()` in a variable.
2. We invoke the downstream middleware, hence let all message handling happen.
   This includes command matching, replying, and everything else your bot does.
3. We take `Date.now()` again, compare it to the old value, and `console.log` the time difference.

It is important to install our `responseTime` middleware _first_ on the bot (at the top of the middleware stack) to make sure that all operations are included in the measurement.

::: code-group

```ts [TypeScript]
/** Measures the response time of the bot, and logs it to `console` */
async function responseTime(
  ctx: Context,
  next: NextFunction, // is an alias for: () => Promise<void>
): Promise<void> {
  // take time before
  const before = Date.now(); // milliseconds
  // invoke downstream middleware
  await next(); // make sure to `await`!
  // take time after
  const after = Date.now(); // milliseconds
  // log difference
  console.log(`Response time: ${after - before} ms`);
}

bot.use(responseTime);
```

```js [JavaScript]
/** Measures the response time of the bot, and logs it to `console` */
async function responseTime(ctx, next) {
  // take time before
  const before = Date.now(); // milliseconds
  // invoke downstream middleware
  await next(); // make sure to `await`!
  // take time after
  const after = Date.now(); // milliseconds
  // log difference
  console.log(`Response time: ${after - before} ms`);
}

bot.use(responseTime);
```

:::

Complete, and works! :heavy_check_mark:

Feel free to use this middleware on your bot object, register more listeners, and play around with the example.
Doing so will help you to fully understand what middleware is.

::: danger DANGER: Always Make Sure to await next!
If you ever call `next()` without the `await` keyword, several things will break:

- :x: Your middleware stack will be executed in the wrong order.
- :x: You may experience data loss.
- :x: Some messages may not be sent.
- :x: Your bot may randomly crash in ways that are hard to reproduce.
- :x: If an error happens, your error handler will not be called for it.
  Instead, you will see that an `UnhandledPromiseRejectionWarning` will occur, which may crash your bot process.
- :x: The backpressure mechanism of [grammY runner](../plugins/runner) breaks, which protects your server from overly-high load, such as during load spikes.
- :skull: Sometimes, it also kills all of your innocent kittens. :crying_cat_face:

:::

The rule that you should use `await` is especially important for `next()`, but it actually applies to any expression in general that returns a `Promise`.
This includes `bot.api.sendMessage`, `ctx.reply`, and all other network calls.
If your project is important to you, then you use linting tools that warn you if you ever forget to use `await` on a `Promise`.

::: tip Enable no-floating-promises
Consider using [ESLint](https://eslint.org/) and configure it to use the [no-floating-promises](https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/no-floating-promises.mdx) rule.
This will make sure that you never forget to use `await` (by yelling at you).
:::

## Properties of Middleware in grammY

In grammY, middleware may return a `Promise` (which will be `await`ed), but it can also be synchronous.

In contrast to other middleware systems (such as the one from `express`), you cannot pass error values to `next`.
`next` does not take any arguments.
If you want to error, you can simply `throw` the error.
Another difference is that it does not matter how many arguments your middleware takes: `() => {}` will be handled exactly as `(ctx) => {}`, or as `(ctx, next) => {}`.

There are two types of middleware: functions and objects.
Middleware objects are simply a wrapper for middleware functions.
They are mostly used internally, but can sometimes also help third-party libraries, or be used in advanced use cases, such as with [Composer](/ref/core/composer):

```ts
const bot = new Bot("");

bot.use(/*...*/);
bot.use(/*...*/);

const composer = new Composer();
composer.use(/*...*/);
composer.use(/*...*/);
composer.use(/*...*/);
bot.use(composer); // composer is a middleware object!

bot.use(/*...*/);
bot.use(/*...*/);
// ...
```

If you want to dig deeper into how grammY implements middleware, check out [Middleware Redux](../advanced/middleware) in the advanced section of the docs.
</file>

<file path="site/docs/guide/reactions.md">
# Reactions

Bots can work with message reactions.
There are two types of reactions: emoji reactions and custom emoji reactions.

## Reacting to Messages

Bots can add a single emoji reaction to a message.

In same cases, bots can also react with custom emoji (even though bots cannot have [Telegram Premium](https://telegram.org/faq_premium?setln=en)).
When a premium user adds a custom emoji reaction to a message, bots can later add the same reaction to this message.
In addition, if a chat administrator explicitly allows custom emoji to be used, they can be used by the bots in that chat, too.

This is how you can react to messages.

```ts
// Use `ctx.react` for reactions on the current message.
bot.command("start", (ctx) => ctx.react("😍"));
bot.on("message", (ctx) => ctx.react("👍"));

// Use `ctx.api.setMessageReaction` for reactions somewhere else.
bot.on("message", async (ctx) => {
  await ctx.api.setMessageReaction(chat_id, message_id, [
    { type: "emoji", emoji: "🎉" },
  ]);
});

// Use `bot.api.setMessageReaction` outside handlers.
await bot.api.setMessageReaction(chat_id, message_id, [
  { type: "emoji", emoji: "💯" },
]);
```

As usual, TypeScript will provide auto-complete for the emojis you can use.
The list of available emoji reactions can be found [here](https://core.telegram.org/bots/api#reactiontypeemoji).

::: tip Emoji Plugin
It can be ugly to program with emoji.
Not all systems can display your source code properly.
Also, it is annoying to copy them from different places all the time.

Let the [emoji plugin](../plugins/emoji#useful-data-for-reactions) help you!
:::

Now that you know how your bot can react to messages, let's see how we can handle your users' reactions.

## Receiving Updates About Reactions

There are a few different ways to handle updates about reactions.
In private chats and group chats, your bot will receive a `message_reaction` update if a user changes their reaction to a message.
In channels (or automatically forwarded channel posts in groups), your bot will receive a `message_reaction_count` update that only shows the total count of reactions, but without revealing who reacted.

Both types of reactions are only received **if the bot is an administrator** in the chat.
In addition, they **need to be enabled** via `allowed_updates`.
For example, with built-in polling, you can enable them like this:

```ts
bot.start({
  allowed_updates: ["message", "message_reaction", "message_reaction_count"],
});
```

::: tip Enabling All Update Types
You may want to import `API_CONSTANTS` from grammY and then specify

```ts
allowed_updates: API_CONSTANTS.ALL_UPDATE_TYPES;
```

in order to receive all updates.
Be sure to check out the [API reference](/ref/core/apiconstants#all-update-types).
:::

[grammY runner](../plugins/runner#advanced-options) and `setWebhook` have similar ways to specify `allowed_updates`.

Now that your bot can receive reaction updates, let's see how it can handle them!

### Handling New Reactions

It is very simple to handle newly added reactions.
grammY has special support for this via `bot.reaction`.

```ts
bot.reaction("🎉", (ctx) => ctx.reply("whoop whoop"));
bot.reaction(["👍", "👎"], (ctx) => ctx.reply("Nice thumb"));
```

These handlers will trigger whenever a user adds a new emoji reaction to a message.

Naturally, if your bot handles custom emoji reactions by premium users, you can listen for them, too.

```ts
bot.reaction(
  { type: "custom_emoji", custom_emoji_id: "identifier-string" },
  async (ctx) => {/* ... */},
);
```

This requires you to know the identifier of the custom emoji in advance.

Finally, when a user pays for a star reaction and adds it to a message, you can handle these updates as follows.

```ts
bot.reaction({ type: "paid" }, (ctx) => ctx.reply("Thanks!"));
```

### Handling Arbitrary Changes to Reactions

Even though this is not visible in the UI of any official Telegram client, users can actually change several reactions at once.
This is why reaction updates give you two lists, the old reactions and the new reactions.
This allows your bot to handle arbitrary changes to the list of reactions.

```ts
bot.on("message_reaction", async (ctx) => {
  const reaction = ctx.messageReaction;
  // We only receive the message identifier, not the message content.
  const message = reaction.message_id;
  // The difference between these two lists describes the change.
  const old = reaction.old_reaction; // previous
  const now = reaction.new_reaction; // current
});
```

grammY lets you filter down the updates even more with special [filter queries](./filter-queries) for the reaction type.

```ts
// Updates where the current reaction contains at least one emoji.
bot.on("message_reaction:new_reaction:emoji", (ctx) => {/* ... */});
// Updates where the previous reaction contained at least one custom emoji.
bot.on("message_reaction:old_reaction:custom_emoji", (ctx) => {/* ... */});
// Updates where the current reaction contains a paid reaction.
bot.on("message_reaction:new_reaction:paid", (ctx) => {/* ... */});
```

While these two arrays of [`ReactionType` objects](https://core.telegram.org/bots/api#reactiontype) technically give you all the information you need in order to handle reaction updates, they can still be a bit cumbersome to work with.
This is why grammY can compute more useful things from the update.

### Inspecting How Reactions Changed

There is a [context shortcut](./context#shortcuts) called `ctx.reactions` that lets you see how exactly a reaction changed.

Here is how you can use `ctx.reactions` to detect if a user removes their upvote (but forgives them if they still keep their ok hand reaction).

```ts
bot.on("message_reaction", async (ctx) => {
  const { emoji, emojiAdded, emojiRemoved } = ctx.reactions();
  if (emojiRemoved.includes("👍")) {
    // Upvote was removed! Unacceptable.
    if (emoji.includes("👌")) {
      // Still okay, do not punish
      await ctx.reply("I forgive you");
    } else {
      // How dare they.
      await ctx.banAuthor();
    }
  }
});
```

There are four arrays returned by `ctx.reaction`: added emoji, removed emoji, kept emoji, and a list that tells you what the result of the change is.
In addition, there are four more arrays for custom emoji with similar information.
Finally, there are two boolean flags for paid reactions.

```ts
const {
  /** Emoji currently present in this user's reaction */
  emoji,
  /** Emoji newly added to this user's reaction */
  emojiAdded,
  /** Emoji not changed by the update to this user's reaction */
  emojiKept,
  /** Emoji removed from this user's reaction */
  emojiRemoved,
  /** Custom emoji currently present in this user's reaction */
  customEmoji,
  /** Custom emoji newly added to this user's reaction */
  customEmojiAdded,
  /** Custom emoji not changed by the update to this user's reaction */
  customEmojiKept,
  /** Custom emoji removed from this user's reaction */
  customEmojiRemoved,
  /** Indicates if a paid reaction is currently present in this user's reaction */
  paid,
  /** Indicates if a paid reaction was newly added to this user's reaction */
  paidAdded,
} = ctx.reactions();
```

A lot has been said about handling updates in private chats and group chats.
Let's look at channels.

### Handling Reaction Count Updates

In private chats, groups, and supergroups, it is known who reacts to which message.
However, for channel posts, we only have a list of anonymous reactions.
It is not possible to obtain a list of users who reacted to a certain post.
The same is true for channel posts that get forwarded to linked discussion group chats automatically.

In both cases, your bot will receive a `message_reaction_count` update.

You can handle it like so.

```ts
bot.on("message_reaction_count", async (ctx) => {
  const counts = ctx.messageReactionCount;
  // Again, we can only see the message identifer.
  const message = counts.message_id;
  // Here is a list of reactions with a count.
  const { reactions } = counts;
});
```

Be sure to check out the [specification](https://core.telegram.org/bots/api#messagereactioncountupdated) for message reaction count updates.
</file>

<file path="site/docs/guide/README.md">
<!-- markdownlint-disable first-line-heading -->

![grammY](/images/grammY.svg)

# Overview

Welcome to grammY!
You've come to the right place.

## What Is grammY?

grammY is a framework for creating Telegram bots.
It can be used from TypeScript and JavaScript and runs on Node.js, Deno, and in the browser.

Check out the [Introduction](./introduction) if you're new to writing Telegram bots, especially if you have little coding experience.

If you know how to write an application for Node.js or Deno or have already created a Telegram bot with another bot framework, get up and running in minutes with our [Getting Started](./getting-started) guide.

## About the Documentation

The documentation for grammY bots is divided into three layers.

1. High-level grammY docs _(this website)_
2. [Low-level grammY API reference](/ref/) _(auto-generated part of this website)_
3. [Raw HTTP API reference by Telegram](https://core.telegram.org/bots/api)

**The first part** (you're looking at it!) explains how bots work and how to use grammY.
This is what you will use most often.
The _Learn_ section is always a good start, as it explains all core concepts.
Also check out our great collection of _Plugins_, and have a look at the _Examples_.

**The second part** is the [grammY API reference](/ref/), linked at the top of the page.
This is a detailed overview of every single bit of code that grammY provides.
It is automatically generated from grammY's code and contains all of the useful tooltip explanations, normally found by hovering your cursor over any element of grammY in a code editor.
The same is true for every plugin in the grammY ecosystem.
In addition to appearing in the [overview of API references](/ref/), plugins have their API reference linked in the plugin summary at the bottom of each plugin page.

**The third part** is provided by Telegram and lists the raw definitions of the [HTTP API](https://core.telegram.org/bots/api) that grammY will connect to under the hood.
The grammY API reference links to it wherever that makes sense.
Have a look at it when you are interested in the detailed options that you can pass to API calls.

::: tip Join the Community!
We have a friendly [community chat](https://t.me/grammyjs) on Telegram that welcomes all new members. (You can find the Russian chat [here](https://t.me/grammyjs_ru).)
Join us to get assistance, ask questions, and learn tips and tricks for your next bot project.
:::
</file>

<file path="site/docs/hosting/cloudflare-workers-nodejs.md">
---
prev: false
next: false
---

# Hosting: Cloudflare Workers (Node.js)

[Cloudflare Workers](https://workers.cloudflare.com) is a public serverless computing platform that offers a convenient and simple solution for running JavaScript at the [edge](https://en.wikipedia.org/wiki/Edge_computing).
Having the ability to handle HTTP traffic and being based on the [Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API), building Telegram bots becomes a breeze.
In addition, you can even develop [Web Apps](https://core.telegram.org/bots/webapps) at the edge, all for free within certain quotas.

This guide will take you through the process of hosting your Telegram bots on Cloudflare Workers.

::: tip Looking for the Deno Version?
This tutorial explains how to deploy a Telegram bot to Cloudflare Workers using Node.js.
If you're looking for the Deno version, please check out [this tutorial](./cloudflare-workers) instead.
:::

## Prerequisites

1. a [Cloudflare account](https://dash.cloudflare.com/login) with your workers subdomain [configured](https://dash.cloudflare.com/?account=workers).
2. a working [Node.js](https://nodejs.org/) environment with `npm` installed.

## Setting Things Up

First, create a new project:

```sh
npm create cloudflare@latest
```

Then, you will be asked to enter the name of the worker:

```ansi{6}
using create-cloudflare version 2.17.1

╭ Create an application with Cloudflare Step 1 of 3
│
╰ In which directory do you want to create your application? also used as application name  // [!code focus]
  ./grammybot  // [!code focus]
```

Here we create a project named `grammybot`, you can choose your own, this will be the name of your worker as well as a part of the request URL.

::: tip
You can change the name of your worker in `wrangler.toml` later.
:::

Next, you will be asked to select the type of your worker, here we choose `"Hello World" Worker`:

```ansi{8}
using create-cloudflare version 2.17.1

╭ Create an application with Cloudflare Step 1 of 3
│
├ In which directory do you want to create your application?
│ dir ./grammybot
│
╰ What type of application do you want to create?  // [!code focus]
  ● "Hello World" Worker  // [!code focus]
  ○ "Hello World" Worker (Python)  // [!code focus]
  ○ "Hello World" Durable Object  // [!code focus]
  ○ Website or web app  // [!code focus]
  ○ Example router & proxy Worker  // [!code focus]
  ○ Scheduled Worker (Cron Trigger)  // [!code focus]
  ○ Queue consumer & producer Worker  // [!code focus]
  ○ API starter (OpenAPI compliant)  // [!code focus]
  ○ Worker built from a template hosted in a git repository  // [!code focus]
```

Next, you will be asked to choose whether you want to use TypeScript, if you want to use JavaScript, choose `No`.
Here we choose `Yes`:

```ansi{11}
using create-cloudflare version 2.17.1

╭ Create an application with Cloudflare Step 1 of 3
│
├ In which directory do you want to create your application?
│ dir ./grammybot
│
├ What type of application do you want to create?
│ type "Hello World" Worker
│
╰ Do you want to use TypeScript?  // [!code focus]
  Yes / No  // [!code focus]
```

Your project will be set up in a few minutes.
After that, you will be asked whether you want to use git for version control, choose `Yes` if you want the repo to be initialized automatically or `No` if you want to initialize it by yourself later.

Here we choose `Yes`:

```ansi{36}
using create-cloudflare version 2.17.1

╭ Create an application with Cloudflare Step 1 of 3
│
├ In which directory do you want to create your application?
│ dir ./grammybot
│
├ What type of application do you want to create?
│ type "Hello World" Worker
│
├ Do you want to use TypeScript?
│ yes typescript
│
├ Copying template files
│ files copied to project directory
│
├ Updating name in `package.json`
│ updated `package.json`
│
├ Installing dependencies
│ installed via `npm install`
│
╰ Application created

╭ Configuring your application for Cloudflare Step 2 of 3
│
├ Installing @cloudflare/workers-types
│ installed via npm
│
├ Adding latest types to `tsconfig.json`
│ added @cloudflare/workers-types/2023-07-01
│
├ Retrieving current workerd compatibility date
│ compatibility date 2024-04-05
│
╰ Do you want to use git for version control?  // [!code focus]
  Yes / No  // [!code focus]
```

Finally, you will be asked whether you want to deploy your worker, choose `No`, since we are going to deploy it when we have a working Telegram bot:

```ansi{49}
using create-cloudflare version 2.17.1

╭ Create an application with Cloudflare Step 1 of 3
│
├ In which directory do you want to create your application?
│ dir ./grammybot
│
├ What type of application do you want to create?
│ type "Hello World" Worker
│
├ Do you want to use TypeScript?
│ yes typescript
│
├ Copying template files
│ files copied to project directory
│
├ Updating name in `package.json`
│ updated `package.json`
│
├ Installing dependencies
│ installed via `npm install`
│
╰ Application created

╭ Configuring your application for Cloudflare Step 2 of 3
│
├ Installing @cloudflare/workers-types
│ installed via npm
│
├ Adding latest types to `tsconfig.json`
│ added @cloudflare/workers-types/2023-07-01
│
├ Retrieving current workerd compatibility date
│ compatibility date 2024-04-05
│
├ Do you want to use git for version control?
│ yes git
│
├ Initializing git repo
│ initialized git
│
├ Committing new files
│ git commit
│
╰ Application configured

╭ Deploy with Cloudflare Step 3 of 3
│
╰ Do you want to deploy your application?  // [!code focus]
  Yes / No  // [!code focus]
```

## Install Dependencies

`cd` into `grammybot` (replace this by your worker's name you set above), install `grammy`, and other packages you might need:

```sh
npm install grammy
```

## Creating Your Bot

Edit `src/index.js` or `src/index.ts`, and write this code inside:

```ts{11,28-29,38,40-42,44}
/**
 * Welcome to Cloudflare Workers! This is your first worker.
 *
 * - Run `npm run dev` in your terminal to start a development server
 * - Open a browser tab at http://localhost:8787/ to see your worker in action
 * - Run `npm run deploy` to publish your worker
 *
 * Learn more at https://developers.cloudflare.com/workers/
 */

import { Bot, Context, webhookCallback } from "grammy";

export interface Env {
  // Example binding to KV. Learn more at https://developers.cloudflare.com/workers/runtime-apis/kv/
  // MY_KV_NAMESPACE: KVNamespace;
  //
  // Example binding to Durable Object. Learn more at https://developers.cloudflare.com/workers/runtime-apis/durable-objects/
  // MY_DURABLE_OBJECT: DurableObjectNamespace;
  //
  // Example binding to R2. Learn more at https://developers.cloudflare.com/workers/runtime-apis/r2/
  // MY_BUCKET: R2Bucket;
  //
  // Example binding to a Service. Learn more at https://developers.cloudflare.com/workers/runtime-apis/service-bindings/
  // MY_SERVICE: Fetcher;
  //
  // Example binding to a Queue. Learn more at https://developers.cloudflare.com/queues/javascript-apis/
  // MY_QUEUE: Queue;
  BOT_INFO: string;
  BOT_TOKEN: string;
}

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext,
  ): Promise<Response> {
    const bot = new Bot(env.BOT_TOKEN, { botInfo: JSON.parse(env.BOT_INFO) });

    bot.command("start", async (ctx: Context) => {
      await ctx.reply("Hello, world!");
    });

    return webhookCallback(bot, "cloudflare-mod")(request);
  },
};
```

Here, we first import `Bot`, `Context` and `webhookCallback` from `grammy`.

Inside the interface `Env`, we add a variable `BOT_INFO`, this is an environment variable that stores your bot info, you can get your bot info by calling Telegram Bot API with `getMe` method.
Open this link in your web browser:

```ansi:no-line-numbers
https://api.telegram.org/bot<BOT_TOKEN>/getMe
```

Replace `<BOT_TOKEN>` with your bot token.
If successful, you will see a JSON response similar to this:

```json{3-12}
{
    "ok": true,
    "result": {
        "id": 1234567890,
        "is_bot": true,
        "first_name": "mybot",
        "username": "MyBot",
        "can_join_groups": true,
        "can_read_all_group_messages": false,
        "supports_inline_queries": true,
        "can_connect_to_business": false
    }
}
```

Now, open `wrangler.toml` in the root of your project and add an environment variable `BOT_INFO` under `[vars]` section with the value from `result` object you get above like this:

```toml
[vars]
BOT_INFO = """{
    "id": 1234567890,
    "is_bot": true,
    "first_name": "mybot",
    "username": "MyBot",
    "can_join_groups": true,
    "can_read_all_group_messages": false,
    "supports_inline_queries": true,
    "can_connect_to_business": false
}"""
```

Replace the bot info with what you get from the web browser.
Pay attention to the three double quotation marks `"""` at the beginning and end.

In addition to `BOT_INFO`, we also add a variable `BOT_TOKEN`, this is an environment variable that stores your bot token that is used to create your bot.

You may notice that we just define the variable `BOT_TOKEN`, but didn't assign it yet.
Usually you need to store your environment variable in `wrangler.toml`, however, this is not safe in our case, since the bot token should be kept secret.
Cloudflare Workers provide us a safe way to store sensitive information like API keys and auth tokens in environment variable: [secrets](https://developers.cloudflare.com/workers/configuration/secrets/#secrets-on-deployed-workers)!

::: tip
Secret values are not visible within Wrangler or the Cloudflare dashboard after you define them.
:::

You can add a secret to your project using the following command:

```sh
npx wrangler secret put BOT_TOKEN
```

Follow the instruction and input your bot token, your bot token will be uploaded and encrypted.

::: tip
You can change to whatever name you want for the environment variables, but keep in mind that you do the same in following steps.
:::

Inside the function `fetch()`, we create a bot with `BOT_TOKEN` which replies "Hello, world!" when it receives `/start`.

## Deploying Your Bot

Now, you can deploy your bot using the following command:

```sh
npm run deploy
```

## Setting Your Webhook

We need to tell Telegram where to send updates to.
Open your browser and visit this URL:

```ansi:no-line-numbers
https://api.telegram.org/bot<BOT_TOKEN>/setWebhook?url=https://<MY_BOT>.<MY_SUBDOMAIN>.workers.dev/
```

Replace `<BOT_TOKEN>` with your bot token, replace `<MY_BOT>` with the name of your worker, replace `<MY_SUBDOMAIN>` with your worker subdomain configured on the Cloudflare dashboard.

If the setup is successful, you'll see a JSON response like this:

```json
{
  "ok": true,
  "result": true,
  "description": "Webhook was set"
}
```

## Testing Your Bot

Open your Telegram app, and start your bot.
If it responds, it means you're good to go!

## Debugging Your Bot

For testing and debugging purposes, you can run a local or remote development server before deploying your bot to production.

In a development environment, your bot doesn't have access to your secret environment variables.
So, [according to Cloudflare](https://developers.cloudflare.com/workers/configuration/secrets/#local-development-with-secrets), you can create a `.dev.vars` file in the root of your project to define secrets:

```env
BOT_TOKEN=<your_bot_token>  # <- replace this with your bot token.
```

Don't forget to add `BOT_INFO` for development as well.
Click [here](https://developers.cloudflare.com/workers/configuration/environment-variables/) and [here](https://developers.cloudflare.com/workers/configuration/secrets/) for more details about environment variables and secrets.

Replace `BOT_INFO` and `BOT_TOKEN` with your value if you change the environment variable name in the previous step.

::: tip
You can use a different bot token for development to ensure it doesn't affect production.
:::

Now, you can run the following command to start a development server:

```sh
npm run dev
```

Once the development server has started, you can test your bot by sending sample updates to it using tools like `curl`, [Insomnia](https://insomnia.rest), or [Postman](https://postman.com).
Refer to [here](https://core.telegram.org/bots/webhooks#testing-your-bot-with-updates) for update examples and [here](https://core.telegram.org/bots/api#update) for more information on the update structure.

If you don't want to construct the update, or if you want to test with a real update, you can get the update from Telegram Bot API with `getUpdates` method.
To do that, you will need to delete the webhook first.
Open your web browser and visit this link:

```ansi:no-line-numbers
https://api.telegram.org/bot<BOT_TOKEN>/deleteWebhook
```

Replace `<BOT_TOKEN>` with your bot token, you will see a JSON response like this:

```json
{
  "ok": true,
  "result": true,
  "description": "Webhook was deleted"
}
```

Then, open your Telegram client and send something to the bot, e.g. send `/start`.

Now visit this link in your web browser to get the updates:

```ansi:no-line-numbers
https://api.telegram.org/bot<BOT_TOKEN>/getUpdates
```

Again, replace `<BOT_TOKEN>` with your bot token, if successful, you will see a JSON response similar to this:

```json{4-29}
{
    "ok": true,
    "result": [
        {
            "update_id": 123456789,
            "message": {
                "message_id": 123,
                "from": {
                    "id": 987654321,
                    "is_bot": false,
                    "first_name": "",
                    "language_code": "en"
                },
                "chat": {
                    "id": 987654321,
                    "first_name": "",
                    "type": "private"
                },
                "date": 1712803046,
                "text": "/start",
                "entities": [
                    {
                        "offset": 0,
                        "length": 6,
                        "type": "bot_command"
                    }
                ]
            }
        }
    ]
}
```

`result` is an array of update objects (above only contains one update object), you should only copy one object and test your bot by post this object to the development server with the tools mentioned above.

If you want to ignore outdated updates (e.g., ignore all updates during development before deploying to production environment), you can add a parameter `offset` to the `getUpdates` method like this:

```ansi:no-line-numbers
https://api.telegram.org/bot<BOT_TOKEN>/getUpdates?offset=<update_id>
```

Replace `<BOT_TOKEN>` with your bot token, and replace `<update_id>` with the `update_id` of the latest update you received (the one with largest number), you will then only receive updates later than that update and will never be able to get the updates from earlier.

Now, you can test your bot with real update objects in your local development environment!

You can also expose your local development server to the public internet using some reverse proxy services like [Ngrok](https://ngrok.com/) and set the webhook to the URL you get from them, or you can set up your own reverse proxy if you have a public IP address, a domain name and a SSL certificate, but that is beyond the of scope of this guide.
For more information about setting up a reverse proxy, see the documentation for the software you are using.

::: warning
Using a third-party reverse proxy may result in information leakage!
:::

::: tip
Don't forget to [set the webhook back](#setting-your-webhook) when you deploy to production environment.
:::
</file>

<file path="site/docs/hosting/cloudflare-workers.md">
---
prev: false
next: false
---

# Hosting: Cloudflare Workers (Deno)

[Cloudflare Workers](https://workers.cloudflare.com) is a public serverless computing platform that offers a convenient and simple solution for running small workloads at the [edge](https://en.wikipedia.org/wiki/Edge_computing).

This guide will take you through the process of hosting your bot on Cloudflare Workers.

::: tip Looking for the Node.js Version?
This tutorial explains how to deploy a Telegram bot to Cloudflare Workers using Deno.
If you're looking for the Node.js version, please check out [this tutorial](./cloudflare-workers-nodejs) instead.
:::

## Prerequisites

To follow along, please make sure that you have a [Cloudflare account](https://dash.cloudflare.com/login) with your workers subdomain [configured](https://dash.cloudflare.com/?account=workers).

## Setting Things Up

Make sure you have [Deno](https://deno.com) and [Denoflare](https://denoflare.dev) installed.

Create a new directory, and create a new file `.denoflare` in that directory.
Put the following contents in the file:

> Note: The "$schema" key in the following JSON code specifies a fixed version in its URL ("v0.5.12").
> At the time of writing, this was the latest version available.
> You should update them to the [newest version](https://github.com/skymethod/denoflare/releases).

```json{2,9,17-18}
{
  "$schema": "https://raw.githubusercontent.com/skymethod/denoflare/v0.5.12/common/config.schema.json",
  "scripts": {
    "my-bot": {
      "path": "bot.ts",
      "localPort": 3030,
      "bindings": {
        "BOT_TOKEN": {
          "value": "YOUR_BOT_TOKEN"
        }
      },
      "workersDev": true
    }
  },
  "profiles": {
    "account1": {
      "accountId": "YOUR_ACCOUNT_ID",
      "apiToken": "YOUR_API_TOKEN"
    }
  }
}
```

Make sure to replace `YOUR_ACCOUNT_ID`, `YOUR_API_TOKEN`, and `YOUR_BOT_TOKEN` appropriately.
When creating your API token, you can choose the `Edit Cloudflare Workers` preset from the pre-configured permissions.

## Creating Your Bot

Create a new file named `bot.ts` and put the following contents in it:

```ts
import { Bot, webhookCallback } from "https://deno.land/x/grammy/mod.ts";
import { UserFromGetMe } from "https://deno.land/x/grammy/types.ts";

interface Environment {
  BOT_TOKEN: string;
}

let botInfo: UserFromGetMe | undefined = undefined;

export default {
  async fetch(request: Request, env: Environment) {
    try {
      const bot = new Bot(env.BOT_TOKEN, { botInfo });

      if (botInfo === undefined) {
        await bot.init();
        botInfo = bot.botInfo;
      }

      bot.command("start", (ctx) => ctx.reply("Welcome! Up and running."));
      bot.on("message", (ctx) => ctx.reply("Got another message!"));

      const cb = webhookCallback(bot, "cloudflare-mod");

      return await cb(request);
    } catch (e) {
      return new Response(e.message);
    }
  },
};
```

## Deploying Your Bot

It's as easy as running:

```sh
denoflare push my-bot
```

The output of the above command will provide you with the host the worker is running on.
Watch out for a line containing something like `<MY_BOT>.<MY_SUBDOMAIN>.workers.dev`.
That's the host where your bot is waiting to be called.

## Setting Your Webhook

We need to tell Telegram where to send updates to.
Open your browser and visit this URL:

```text
https://api.telegram.org/bot<BOT_TOKEN>/setWebhook?url=https://<MY_BOT>.<MY_SUBDOMAIN>.workers.dev/
```

Replace `<BOT_TOKEN>`, `<MY_BOT>`, and `<MY_SUBDOMAIN>` with your values.
If the setup is successful, you'll see a JSON response like this:

```json
{
  "ok": true,
  "result": true,
  "description": "Webhook was set"
}
```

## Testing Your Bot

Open your Telegram app, and start your bot.
If it responds, it means you're good to go!

## Debugging Your Bot

For testing and debugging purposes, you can run a local or remote development server before deploying your bot to production.
Simply run the following command:

```sh
denoflare serve my-bot
```

Once the development server has started, you can test your bot by sending sample updates to it using tools like `curl`, [Insomnia](https://insomnia.rest), or [Postman](https://postman.com).
Refer to [here](https://core.telegram.org/bots/webhooks#testing-your-bot-with-updates) for update examples and [here](https://core.telegram.org/bots/api#update) for more information on the update structure.
</file>

<file path="site/docs/hosting/comparison.md">
---
prev: false
next: false
---

# Comparison of Hosting Providers

There are many different hosting providers that allow you to run your bot.
It can sometimes be hard to keep track of how much they cost and how good their performance is.
This is why the grammY community is collecting their experiences on this page.

## What Is a Hosting Provider?

In order to keep a bot online 24 hours a day, you need to run a computer 24 hours a day.
As [mentioned in the introduction](../guide/introduction#how-to-keep-a-bot-running), you most likely don't want to do that with your laptop or home computer.
Instead, you can ask a company to run the bot in the cloud.

In other words, you just run it on someone else's computer.

## Comparison Tables

> Please click the edit button at the bottom of the page to add more providers or to edit existing ones!

We have two comparison tables: one for [serverless hosting and PaaS](#serverless-and-paas) and one for [VPS](#vps).

### Serverless and PaaS

Serverless means that you do not control a single machine on which your bot is run.
Instead, these hosting providers will rather allow you to upload your code, and then start and stop different machines as necessary to make sure that your bot always works.

The main thing to know about them is that on serverless infrastructures you are required to use [webhooks](../guide/deployment-types).
Most of providers below will have issues when you try running your bot with polling (`bot.start()` or [grammY runner](../plugins/runner)) on them.

On the other hand, PaaS (Platform as a Service) provides a similar but more controllable solution.
You can choose how many machine instances will be serving your bot, and when they are running.
Using [polling](../guide/deployment-types) is also possible with PaaS if the provider you choose lets you keep exactly single instance running at all times.

Serverless and PaaS have a downside that doesn't provide you with a persistent storage by default, such as a local file system.
Instead, you will often have to have a database separately and connect to it if you need to store data permanently.

| Name                   | Min. price | Pricing                                                                                                    | Limits                                                                                             | Node.js                                                                                  | Deno                                           | Web                                               | Notes                                                                                            |
| ---------------------- | ---------- | ---------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- | ---------------------------------------------- | ------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| Deno Deploy            | Free       | $20/mo subscription for 5M req and 100 GB; $2/1M req, $0.5/GB network                                      | [1M req/mo, 100 GB/mo, 10 ms CPU-time limit](https://deno.com/deploy/pricing)                      | ❌                                                                                       | ✅                                             | ❌                                                |                                                                                                  |
| Fly                    | Free       | $1.94/mo subscription for shared-cpu-1x and 256 MB RAM, $0.02/GB network                                   | [3 shared-cpu-1x 256mb VMs, 160GB/mo, 3GB storage](https://fly.io/docs/about/pricing/)             | ✅                                                                                       | ✅                                             | ❓                                                |                                                                                                  |
| DigitalOcean Functions | Free       | $1.85/100K GB-s                                                                                            | [90K GB-s/mo](https://docs.digitalocean.com/products/functions/details/pricing/)                   | ✅                                                                                       | ❌                                             | ❓                                                |                                                                                                  |
| Cloudflare Workers     | Free       | $5/10M req                                                                                                 | [Up to 30 s of CPU time per request](https://workers.cloudflare.com/)                              | ❌                                                                                       | [✅](https://denoflare.dev/)                   | ✅                                                |                                                                                                  |
| Vercel                 | Free       | $20/mo subscription                                                                                        | [Unlimited invocations, 100 GB-h, 10 s time limit](https://vercel.com/pricing)                     | [✅](https://vercel.com/docs/functions/runtimes/node-js)                                 | [✅](https://github.com/vercel-community/deno) | [✅](https://vercel.com/docs/frameworks)          |                                                                                                  |
| Scaleway Functions     | Free       | €0.15/1M req, €1.2/100K GB-s                                                                               | [1M requests, 400K GB-s/mo](https://www.scaleway.com/en/pricing/serverless/#serverless-functions)  | ❓                                                                                       | ❓                                             | ❓                                                |                                                                                                  |
| Scaleway Containers    | Free       | €0.10/100K GB-s, €1.0/100K vCPU-s                                                                          | [400K GB-s, 200K vCPU-s/mo](https://www.scaleway.com/en/pricing/serverless/#serverless-containers) | ❓                                                                                       | ❓                                             | ❓                                                |                                                                                                  |
| Vercel Edge Functions  | Free       | $20/mo subscription for 500K                                                                               | [100K req/day](https://vercel.com/pricing)                                                         | [✅](https://vercel.com/docs/functions/runtimes/edge-runtime#compatible-node.js-modules) | ❓                                             | [✅](https://vercel.com/templates/edge-functions) |                                                                                                  |
| serverless.com         | Free       |                                                                                                            |                                                                                                    | ❓                                                                                       | ❓                                             | ❓                                                |                                                                                                  |
| Heroku                 | $5         | $5 for 1,000 [dyno hours](https://devcenter.heroku.com/articles/usage-and-billing#dyno-usage-and-costs)/mo | [512MB RAM, sleeps after 30 mins of inactivity](https://www.heroku.com/pricing)                    | ✅                                                                                       | ✅                                             | ❓                                                | Deno is supported by a [third-party buildpack](https://github.com/chibat/heroku-buildpack-deno). |
| DigitalOcean Apps      | $5         |                                                                                                            |                                                                                                    | ❓                                                                                       | ❓                                             | ❓                                                | Not tested                                                                                       |
| Fastly Compute@Edge    |            |                                                                                                            |                                                                                                    | ❓                                                                                       | ❓                                             | ❓                                                |                                                                                                  |
| Zeabur                 | $5         | $5/mo subscription                                                                                         | 2GB RAM, Unlimited invocations                                                                     | ✅                                                                                       | ✅                                             | ✅                                                |                                                                                                  |

### VPS

A virtual private server is a virtual machine that you have full control over.
You can usually access it via [SSH](https://en.wikipedia.org/wiki/Secure_Shell).
You can install any software there, and you are responsible for system upgrades and so on.

On a VPS, you can run bots using both long polling or webhooks.

Check out the [tutorial](./vps) on how to host grammY bots on a VPS.

| Name          | Min. price | Ping to Bot API                           | Cheapest option                    |
| ------------- | ---------- | ----------------------------------------- | ---------------------------------- |
| Hostinger     | $14        |                                           | 1 vCPU, 4 GB RAM, 50 GB SSD, 1 TB  |
| Contabo       |            | 15 ms :de: Nuremberg                      |                                    |
| DigitalOcean  | $5         | 1-15 ms :netherlands: AMS, 19 ms :de: FRA | 1 vCPU, 1 GB RAM, 25 GB SSD, 1 TB  |
| Hetzner Cloud | €4.15      | ~42 ms :de:                               | 1 vCPU, 2 GB RAM, 20 GB SSD, 20 TB |
| IONOS VPS     | €1 or $2   | 15 ms :de: Baden-Baden                    | 1 vCPU, 0.5 GB RAM, 8 GB SSD       |
| Scaleway      | €~7        |                                           | 2 cores, 2 GB RAM, 20 GB SSD       |
| MVPS          | €4         | 6-9 ms :de: Germany                       | 1 core, 2 GB RAM, 25 GB SSD, 2 TB  |

## Unit Explanations

### Base Units

| Unit | In Words    | Explanation                                               |
| ---- | ----------- | --------------------------------------------------------- |
| K    | thousand    | 1,000 of something.                                       |
| M    | million     | 1,000,000 of something.                                   |
| €    | Euro        | The currency EUR.                                         |
| $    | US-Dollar   | The currency USD.                                         |
| req  | request     | Number of HTTP requests.                                  |
| vCPU | virtual CPU | Computing power of one virtual CPU, a part of a real CPU. |
| ms   | millisecond | 0.001 seconds.                                            |
| s    | second      | One second (SI unit for time).                            |
| min  | minute      | One minute, 60 seconds.                                   |
| h    | hours       | One hour, 60 minutes.                                     |
| day  | day         | One day, 24 hours.                                        |
| mo   | month       | One month, approximately 30 days.                         |
| GB   | gigabytes   | 1,000,000,000 bytes of storage.                           |

### Example Unit Combinations

| Unit        | Quantity                 | In Words                               | Explanation                                              |
| ----------- | ------------------------ | -------------------------------------- | -------------------------------------------------------- |
| $/mo        | cost                     | US-Dollars per month                   | Monthly cost.                                            |
| €/M req     | cost                     | Euros per million requests             | Cost for handling one million requests.                  |
| req/min     | throughput               | requests per minute                    | Number of requests handled in one minute.                |
| GB/s        | throughput               | gigabytes per second                   | Number of gigabytes transferred in one second.           |
| GB-s        | memory usage             | gigabyte seconds                       | One gigabyte used for one second.                        |
| GB-h        | memory usage             | gigabyte hours                         | One gigabyte used for one hour.                          |
| h/mo        | time fraction            | hours per month                        | Number of hours in one month.                            |
| K vCPU-s/mo | processing time fraction | thousand virtual CPU seconds per month | Monthly seconds of processing time with one virtual CPU. |
</file>

<file path="site/docs/hosting/deno-deploy.md">
---
prev: false
next: false
---

# Hosting: Deno Deploy

This guide tells you about the ways you can host your grammY bots on [Deno Deploy](https://deno.com/deploy).

Please note that this guide is only for Deno users, and you need to have a [GitHub](https://github.com) account for creating a [Deno Deploy](https://deno.com/deploy) account.

Deno Deploy is ideal for most simple bots, and you should note that not all Deno features are available for apps running on Deno Deploy.
For example, the platform only supports a [limited set](https://docs.deno.com/deploy/api/runtime-fs) of the file system APIs available in Deno.
It's just like the other many serverless platforms, but dedicated for Deno apps.

The result of this tutorial [can be seen in our example bots repository](https://github.com/grammyjs/examples/tree/main/setups/deno-deploy).

## Preparing Your Code

> Remember that you need to [run your bot on webhooks](../guide/deployment-types#how-to-use-webhooks), so you should use `webhookCallback` and not call `bot.start()` in your code.

1. Make sure that you have a file which exports your `Bot` object, so that you can import it later to run it.
2. Create a file named `main.ts` or `main.js`, or actually any name you like (but you should be remembering and using this as the main file to deploy), with the following content:

```ts
import { webhookCallback } from "https://deno.land/x/grammy/mod.ts";
// You might modify this to the correct way to import your `Bot` object.
import bot from "./bot.ts";

const handleUpdate = webhookCallback(bot, "std/http");

Deno.serve(async (req) => {
  if (req.method === "POST") {
    const url = new URL(req.url);
    if (url.pathname.slice(1) === bot.token) {
      try {
        return await handleUpdate(req);
      } catch (err) {
        console.error(err);
      }
    }
  }
  return new Response();
});
```

We advise you to have your handler on some secret path rather than the root (`/`).
Here, we are using the bot token (`/<bot token>`).

## Deploying

### Method 1: With GitHub

> This is the recommended method, and the easiest one to go with.
> The main advantage of following this method is that Deno Deploy will watch for changes in your repository which includes your bot code, and it will deploy new versions automatically.

1. Create a repository on GitHub, it can be either private or public.
2. Push your code.

   > It is recommended that you have a single stable branch and you do your testing stuff in other branches, so that you won't get some unexpected things happen.

3. Visit your [Deno Deploy dashboard](https://dash.deno.com/account/overview).
4. Click on "New Project".
5. Install the GitHub app on your account or organization, and choose your repository.
6. Select the branch you want to deploy.
7. Select the entrypoint file `main.ts`, and click "Deploy Project" to deploy.

### Method 2: With `deployctl`

> This is a method for more advanced users or if you don't want to upload your code to GitHub.
> It allows you to deploy the project via the command line or GitHub Actions.

1. Install [`deployctl`](https://github.com/denoland/deployctl).
2. Create an access token from the "Access Tokens" section in [account settings](https://dash.deno.com/account).
3. Go to your project directory and run the following command:

   ```sh:no-line-numbers
   deployctl deploy --project=<project> --entrypoint=./main.ts --prod --token=<token>
   ```

   ::: tip Setting environment variables
   Environment variables can be set by heading to your project's settings after deploying.

   But this is possible from the command line, as well:

   1. You can assign environment variables from a dotenv file by adding the `--env-file=<file>` argument.
   2. You can also specify them individually by using the `--env=<key=value>` argument.

   :::
4. To set up GitHub Actions, refer to [this](https://github.com/denoland/deployctl/blob/main/action/README.md).

Check out the [deployctl documentation](https://docs.deno.com/deploy/manual/deployctl) for more information.

### Note

After getting your app running, you should configure your bot's webhook settings to point to your app.
To do that, send a request to

```sh:no-line-numbers
curl https://api.telegram.org/bot<token>/setWebhook?url=<url>
```

replacing `<token>` with your bot token, and `<url>` with the full URL of your app along with the path to the webhook handler.
</file>

<file path="site/docs/hosting/firebase.md">
---
prev: false
next: false
---

# Hosting: Firebase Functions

This tutorial will guide you through the process of deploying your bot to [Firebase Functions](https://firebase.google.com/docs/functions).

## Prerequisites

To follow along, you will need to have a Google account.
If you don't already have one, you can create it [here](https://accounts.google.com/signup).

## Setup

This section guides you through the setup process.
If you need more detailed explanations on each step that you'll take, refer to the [official Firebase documentation](https://firebase.google.com/docs/functions/get-started).

### Creating a Firebase Project

1. Go to the [Firebase console](https://console.firebase.google.com/) and click **Add Project**.
2. If prompted, review and accept the Firebase terms.
3. Click **Continue**.
4. Decide on whether you want to share analytics or not.
5. Click **Create Project**.

### Setting Things Up

To write functions and deploy them to the Firebase Functions runtime, you'll need to set up a Node.js environment and install the Firebase CLI.

> It's important to note that only the Node.js versions 14, 16, and 18 are currently supported by Firebase Functions.
> For more on the supported Node.js versions, refer to [here](https://firebase.google.com/docs/functions/manage-functions#set_nodejs_version).

Once you have Node.js and npm installed, install Firebase CLI globally:

```sh
npm install -g firebase-tools
```

### Initializing the Project

1. Run `firebase login` to open your browser and authenticate Firebase CLI with your account.
2. `cd` into your project's directory.
3. Run `firebase init functions`, and type `y` when asked whether you want to initialize a new codebase.
4. Choose `use existing project` and select the project you created in Step 1.
5. The CLI gives you two options for language support:
   - JavaScript
   - TypeScript
6. Optionally, you can select ESLint.
7. The CLI asks you if you want to install the dependencies with npm.
   If you use another package manager like `yarn` or `pnpm` you can decline.
   In that case, you have to `cd` into the `functions` directory and install the dependencies manually.
8. Open `./functions/package.json` and look for the key: `"engines": {"node": "16"}`.
   The `node` version should match your installed version of Node.js.
   Otherwise, the project might not run.

## Preparing Your Code

You can use this short example bot as a starting point:

```ts
import * as functions from "firebase-functions";
import { Bot, webhookCallback } from "grammy";

const bot = new Bot("");

bot.command("start", (ctx) => ctx.reply("Welcome! Up and running."));
bot.command("ping", (ctx) => ctx.reply(`Pong! ${new Date()}`));

// During development, you can trigger your function from https://localhost/<firebase-projectname>/us-central1/helloWorld
export const helloWorld = functions.https.onRequest(webhookCallback(bot));
```

## Local Development

During development, you can use the firebase emulator suite to run your code locally.
This is way faster than deploying every change to Firebase.
To install the emulators, run:

```sh
firebase init emulators
```

The functions emulator should be selected already.
(If it isn't, navigate to it using the arrow keys, and select it using `space`.)
For the questions about which port to use for each emulator, simply press `enter`.

To start the emulators and run your code, use:

```sh
npm run serve
```

::: tip
For some reason the standard configuration of the npm script does not start the TypeScript compiler in watch mode.
Therefore, if you use TypeScript, you also have to run:

```sh
npm run build:watch
```

:::

After the emulators start, you should find a line in the console output that looks like this:

```sh
+  functions[us-central1-helloWorld]: http function initialized (http://127.0.0.1:5001/<firebase-projectname>/us-central1/helloWorld).
```

That is the local URL of your cloud function.
However, your function is only available to the localhost on your computer.
To actually test your bot, you need to expose your function to the internet so that the Telegram API can send updates to your bot.
There are several services, such as [localtunnel](https://localtunnel.me) or [ngrok](https://ngrok.com), that can help you with that.
In this example, we will be using localtunnel.

First, let's install localtunnel:

```sh
npm i -g localtunnel
```

After that, you can forward the port `5001`:

```sh
lt --port 5001
```

localtunnel should give you a unique URL, such as `https://modern-heads-sink-80-132-166-120.loca.lt`.

All that's left to do is to tell Telegram where to send the updates.
You can do this by calling `setWebhook`.
For example, open a new tab in your browser and visit this URL:

```text
https://api.telegram.org/bot<BOT_TOKEN>/setWebhook?url=<WEBHOOK_URL>/<firebase-projectname>/us-central1/helloWorld
```

Replace `<BOT_TOKEN>` with your real bot token, and `<WEBHOOK_URL>` with your own URL you got from localtunnel.

You should now see this in your browser window.

```json
{
  "ok": true,
  "result": true,
  "description": "Webhook was set"
}
```

Your bot is now ready for deployment testing.

## Deploying

To deploy your function, just run:

```sh
firebase deploy
```

The Firebase CLI will give you the URL of your function once the deployment is completed.
It should look something like `https://<REGION>.<MY_PROJECT.cloudfunctions.net/helloWorld`.
For a more detailed explanation you can take a look at step 8 of the [get started guide](https://firebase.google.com/docs/functions/get-started#deploy-functions-to-a-production-environment).

After deploying, you need to tell Telegram where to send updates to your bot by calling the `setWebhook` method.
To do this, open a new browser tab and visit this URL:

```text
https://api.telegram.org/bot<BOT_TOKEN>/setWebhook?url=https://<REGION>.<MY_PROJECT>.cloudfunctions.net/helloWorld
```

Replace `<BOT_TOKEN>` with your actual bot token, `<REGION>` with the name of the region where you deployed your function, and `<MY_PROJECT>` with the name of your Firebase project.
The Firebase CLI should provide you with the full URL of your cloud function, so you can simply paste it after the `?url=` parameter in the `setWebhook` method.

If everything is set up correctly, you should see this response in your browser window:

```json
{
  "ok": true,
  "result": true,
  "description": "Webhook was set"
}
```

That's it, your bot is ready to go.
Head over to Telegram and watch it respond to messages!
</file>

<file path="site/docs/hosting/fly.md">
---
prev: false
next: false
---

# Hosting: Fly

This guide tells you about the ways you can host your grammY bots on [Fly](https://fly.io), either using Deno or Node.js.

## Preparing Your Code

You can run your bot using both [webhooks or long polling](../guide/deployment-types).

### Webhooks

> Remember that you should not call `bot.start()` in your code when using webhooks.

1. Make sure that you have a file which exports your `Bot` object, so that you can import it later to run it.
2. Create a file named `app.ts` or `app.js`, or actually any name you like (but you should be remembering and using this as the main file to deploy), with the following content:

::: code-group

```ts{11} [Deno]
import { webhookCallback } from "https://deno.land/x/grammy/mod.ts";
// You might modify this to the correct way to import your `Bot` object.
import { bot } from "./bot.ts";

const port = 8000;
const handleUpdate = webhookCallback(bot, "std/http");

Deno.serve({ port }, async (req) => {
  const url = new URL(req.url);
  if (req.method === "POST" && url.pathname.slice(1) === bot.token) {
    try {
      return await handleUpdate(req);
    } catch (err) {
      console.error(err);
    }
  }
  return new Response();
});
```

```ts{10} [Node.js]
import express from "express";
import { webhookCallback } from "grammy";
// You might modify this to the correct way to import your `Bot` object.
import { bot } from "./bot";

const port = 8000;
const app = express();

app.use(express.json());
app.use(`/${bot.token}`, webhookCallback(bot, "express"));
app.use((_req, res) => res.status(200).send());

app.listen(port, () => console.log(`listening on port ${port}`));
```

:::

We advise you to have your handler on some secret path rather than the root (`/`).
As shown in the highlighted line above, we are using the bot token (`/<bot token>`) as the secret path.

### Long Polling

Create a file named `app.ts` or `app.js`, or actually any name you like (but you should be remembering and using this as the main file to deploy), with the following content:

::: code-group

```ts{4} [Deno]
import { Bot } from "https://deno.land/x/grammy/mod.ts";

const token = Deno.env.get("BOT_TOKEN");
if (!token) throw new Error("BOT_TOKEN is unset");

const bot = new Bot(token); 

bot.command(
  "start",
  (ctx) => ctx.reply("I'm running on Fly using long polling!"),
);

Deno.addSignalListener("SIGINT", () => bot.stop());
Deno.addSignalListener("SIGTERM", () => bot.stop());

bot.start();
```

```ts{4} [Node.js]
import { Bot } from "grammy";

const token = process.env.BOT_TOKEN;
if (!token) throw new Error("BOT_TOKEN is unset");

const bot = new Bot(token);

bot.command(
  "start",
  (ctx) => ctx.reply("I'm running on Fly using long polling!"),
);

process.once("SIGINT", () => bot.stop());
process.once("SIGTERM", () => bot.stop());

bot.start();
```

:::

As you can see in the highlighted line above, we take some sensitive values (your bot token) from environment variables.
Fly allow us to store that secret by running this command:

```sh
flyctl secrets set BOT_TOKEN="AAAA:12345"
```

You can specify other secrets in the same way.
For more information about this _secrets_, see <https://fly.io/docs/apps/secrets/>.

## Deploying

### Method 1: With `flyctl`

This is the easiest method to go with.

1. Install [flyctl](https://fly.io/docs/flyctl/install/) and [sign in](https://fly.io/docs/getting-started/sign-up-sign-in/).
2. Run `flyctl launch` to generate a `Dockerfile` and `fly.toml` file for deployment.
   But **DO NOT** deploy.

   ::: code-group

   ```sh [Deno]
   flyctl launch
   ```

   ```log{10} [Log]
   Creating app in /my/telegram/bot
   Scanning source code
   Detected a Deno app
   ? App Name (leave blank to use an auto-generated name): grammy
   Automatically selected personal organization: CatDestroyer
   ? Select region: ams (Amsterdam, Netherlands)
   Created app grammy in organization personal
   Wrote config file fly.toml
   ? Would you like to set up a Postgresql database now? No
   ? Would you like to deploy now? No
   Your app is ready. Deploy with `flyctl deploy`
   ```

   :::

   ::: code-group

   ```sh [Node.js]
   flyctl launch
   ```

   ```log{12} [Log]
   Creating app in /my/telegram/bot
   Scanning source code
   Detected a NodeJS app
   Using the following build configuration:
         Builder: heroku/buildpacks:20
   ? App Name (leave blank to use an auto-generated name): grammy
   Automatically selected personal organization: CatDestroyer
   ? Select region: ams (Amsterdam, Netherlands)
   Created app grammy in organization personal
   Wrote config file fly.toml
   ? Would you like to set up a Postgresql database now? No
   ? Would you like to deploy now? No
   Your app is ready. Deploy with `flyctl deploy`
   ```

   :::

3. **Deno**: Change the Deno version and remove `CMD` if exist within the `Dockerfile` file.
   For example, in this case, we update `DENO_VERSION` to `1.25.2`.

   **Node.js**: To change the Node.js version, you need to insert a `"node"` property inside an `"engines"` property inside `package.json`.
   For instance, we update the Node.js version to `16.14.0` in the example below.

   ::: code-group

   ```dockerfile{2,26} [Deno]
   # Dockerfile
   ARG DENO_VERSION=1.25.2
   ARG BIN_IMAGE=denoland/deno:bin-${DENO_VERSION}
   FROM ${BIN_IMAGE} AS bin

   FROM frolvlad/alpine-glibc:alpine-3.13

   RUN apk --no-cache add ca-certificates

   RUN addgroup --gid 1000 deno \
   && adduser --uid 1000 --disabled-password deno --ingroup deno \
   && mkdir /deno-dir/ \
   && chown deno:deno /deno-dir/

   ENV DENO_DIR /deno-dir/
   ENV DENO_INSTALL_ROOT /usr/local

   ARG DENO_VERSION
   ENV DENO_VERSION=${DENO_VERSION}
   COPY --from=bin /deno /bin/deno

   WORKDIR /deno-dir
   COPY . .

   ENTRYPOINT ["/bin/deno"]
   # CMD is removed
   ```

   ```json [Node.js]{19}
   // package.json
   {
     "name": "grammy",
     "version": "1.0.0",
     "description": "grammy",
     "main": "app.js",
     "author": "itsmeMario",
     "license": "MIT",
     "dependencies": {
       "express": "^4.18.1",
       "grammy": "^1.11.0"
     },
     "devDependencies": {
       "@types/express": "^4.17.14",
       "@types/node": "^18.7.18",
       "typescript": "^4.8.3"
     },
     "engines": {
       "node": "16.14.0"
     }
   }
   ```

   :::

4. Edit `app` inside the `fly.toml` file.
   The path `./app.ts` (or `./app.js` for Node.js) in the example below refers to the main file directory.
   You might modify them to match with your project's directory.
   If you are using webhooks, make sure the port is same as the one in your [configuration](#webhooks) (`8000`).

   ::: code-group

   ```toml [Deno (Webhooks)]{7,11,12}
   # fly.toml
   app = "grammy"
   kill_signal = "SIGINT"
   kill_timeout = 5

   [processes]
   app = "run --allow-net ./app.ts"

   [[services]]
   http_checks = []
   internal_port = 8000
   processes = ["app"]
   protocol = "tcp"
   script_checks = []
   [services.concurrency]
      hard_limit = 25
      soft_limit = 20
      type = "connections"

   [[services.ports]]
      force_https = true
      handlers = ["http"]
      port = 80

   [[services.ports]]
      handlers = ["tls", "http"]
      port = 443

   [[services.tcp_checks]]
      grace_period = "1s"
      interval = "15s"
      restart_limit = 0
      timeout = "2s"
   ```

   ```toml [Deno (Long Polling)]{7}
   # fly.toml
   app = "grammy"
   kill_signal = "SIGINT"
   kill_timeout = 5

   [processes]
   app = "run --allow-net ./app.ts"

   # Simply omitting the whole [[services]] section 
   # since we are not listening to HTTP
   ```

   ```toml [Node.js (Webhooks)]{7,11,18,19}
   # fly.toml
   app = "grammy"
   kill_signal = "SIGINT"
   kill_timeout = 5

   [processes]
   app = "node ./build/app.js"

   # Adjust the NODE_ENV environment variable to suppress the warning
   [build.args]
   NODE_ENV = "production"

   [build]
   builder = "heroku/buildpacks:20"

   [[services]]
   http_checks = []
   internal_port = 8000
   processes = ["app"]
   protocol = "tcp"
   script_checks = []
   [services.concurrency]
      hard_limit = 25
      soft_limit = 20
      type = "connections"

   [[services.ports]]
      force_https = true
      handlers = ["http"]
      port = 80

   [[services.ports]]
      handlers = ["tls", "http"]
      port = 443

   [[services.tcp_checks]]
      grace_period = "1s"
      interval = "15s"
      restart_limit = 0
      timeout = "2s"
   ```

   ```toml [Node.js (Long polling)]{7,11,22,23}
   # fly.toml
   app = "grammy"
   kill_signal = "SIGINT"
   kill_timeout = 5

   [processes]
   app = "node ./build/app.js"

   # Adjust the NODE_ENV environment variable to suppress the warning
   [build.args]
   NODE_ENV = "production"

   [build]
   builder = "heroku/buildpacks:20"

   # Simply omitting the whole of the [[services]] section since we are not listening to HTTP.
   ```

   :::

5. Run `flyctl deploy` to deploy your code.

### Method 2: With GitHub Actions

The main advantage of following method is that Fly will watch for changes in your repository which includes your bot code, and it will deploy new versions automatically.
Visit <https://fly.io/docs/launch/continuous-deployment-with-github-actions/> for more detailed instructions.

1. Install [flyctl](https://fly.io/docs/flyctl/install/) and [sign in](https://fly.io/docs/getting-started/sign-up-sign-in/).
2. Get a Fly API token by running `flyctl auth token`.
3. Create a repository on GitHub, it can be either private or public.
4. Go to Settings, choose Secrets and create a secret called `FLY_API_TOKEN` with the value of the token from step 2.
5. Create `.github/workflows/main.yml` with these contents:

   ```yml
   name: Fly Deploy
   on: [push]
   env:
   FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
   jobs:
   deploy:
     name: Deploy app
     runs-on: ubuntu-latest
     steps:
       - uses: actions/checkout@v2
       - uses: superfly/flyctl-actions/setup-flyctl@master
       - run: flyctl deploy --remote-only
   ```

6. Follow steps 2 until 4 from [Method 1](#method-1-with-flyctl) above.
   Remember to skip the last step (step 5) since we are not deploying the code directly.
7. Commit your changes and push them up to GitHub.
8. This is where the magic happens---the push will have triggered a deploy and from now on, whenever you push a change, the app will automatically be redeployed.

### Setting the Webhook URL

If you are using webhooks, after getting your app running, you should configure your bot's webhook settings to point to your app.
To do that, send a request to

```text
https://api.telegram.org/bot<token>/setWebhook?url=<url>
```

replacing `<token>` with your bot token, and `<url>` with the full URL of your app along with the path to the webhook handler.

### Dockerfile Optimization

When our `Dockerfile` is run, it copies everything from the directory over to the Docker image.
For Node.js applications, some directories like `node_modules` are going to be rebuilt anyway so there's no need to copy them.
Create a `.dockerignore` file and add `node_modules` to it to do this.
You can also use `.dockerignore` to not copy any other files which aren't needed at runtime.

## Reference

- <https://fly.io/docs/js/frameworks/deno/>
- <https://fly.io/docs/js/>
</file>

<file path="site/docs/hosting/heroku.md">
---
prev: false
next: false
---

# Hosting: Heroku

> We assume that you have the basic knowledge about creating bots using grammY.
> If you are not ready yet, don't hesitate to head over to our friendly [Guide](../guide/)! :rocket:

This tutorial will guide you how to deploy a Telegram bot to [Heroku](https://heroku.com/) by using either [webhooks](../guide/deployment-types#how-to-use-webhooks) or [long polling](../guide/deployment-types#how-to-use-long-polling).
We also assume that you have a Heroku account already.

## Prerequisites

First, install some dependencies:

```sh
# Create a project directory.
mkdir grammy-bot
cd grammy-bot
npm init --y

# Install main dependencies.
npm install grammy express

# Install development dependencies.
npm install -D typescript @types/express @types/node

# Create TypeScript config.
npx tsc --init
```

We will store our TypeScript files inside a folder `src`, and our compiled files in a folder `dist`.
Create the folders in the project's root directory.
Then, inside folder `src`, create a new file named `bot.ts`.
Our folder structure should now look like this:

```asciiart:no-line-numbers
.
├── node_modules/
├── dist/
├── src/
│   └── bot.ts
├── package.json
├── package-lock.json
└── tsconfig.json
```

After that, open `tsconfig.json` and change it to use this configuration:

```json
{
  "compilerOptions": {
    "target": "ESNEXT",
    "module": "ESNext", // [!code hl] // changed from commonjs to esnext
    "lib": ["ES2021"],
    "outDir": "./dist/",
    "strict": true,
    "moduleResolution": "node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"]
}
```

Because the `module` option above has been set from `commonjs` to `esnext`, we have to add `"type": "module"` to our `package.json`.
Our `package.json` should now be similar to this:

```json{6}
{
  "name": "grammy-bot",
  "version": "0.0.1",
  "description": "",
  "main": "dist/app.js",
  "type": "module", // [!code hl] // add property of "type": "module"
  "scripts": {
    "dev-build": "tsc"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "grammy": "^1.2.0",
    "express": "^4.17.1"
  },
  "devDependencies": {
    "typescript": "^4.3.5",
    "@types/express": "^4.17.13",
    "@types/node": "^16.3.1"
  },
  "keywords": []
}
```

As mentioned earlier, we have two options for receiving data from Telegram: webhooks and long polling.
You can learn more about the both advantages and then decide which ones is suitable in these [awesome tips](../guide/deployment-types)!

## Webhooks

> If you decide to use long polling instead, you can skip this section and jump down to the [section about long polling](#long-polling). :rocket:

In short, unlike long polling, webhook do not run continuously for checking incoming messages from Telegram.
This will reduce server load and save us a lot of [dyno hours](https://devcenter.heroku.com/articles/eco-dyno-hours), especially when you are using the Eco plan. :grin:

Okay, let us continue!
Remember we have created `bot.ts` earlier?
We will not dump all the code there, and leave coding the bot up to you.
Instead, we are going to make `app.ts` our main entry point.
That means every time Telegram (or anyone else) visits our site, `express` decides which part of your server will be responsible for handling the request.
This is useful when you are deploying both website and bot in the same domain.
Also, by splitting codes to different files, it make our code look tidy. :sparkles:

### Express and Its Middleware

Now create `app.ts` inside folder `src` and write this code inside:

```ts
import express from "express";
import { webhookCallback } from "grammy";
import { bot } from "./bot.js";

const domain = String(process.env.DOMAIN);
const secretPath = String(process.env.BOT_TOKEN);
const app = express();

app.use(express.json());
app.use(`/${secretPath}`, webhookCallback(bot, "express"));

app.listen(Number(process.env.PORT), async () => {
  // Make sure it is `https` not `http`!
  await bot.api.setWebhook(`https://${domain}/${secretPath}`);
});
```

Let's take a look at our code above:

- `process.env`: Remember, NEVER store credentials in our code!
  For creating [environment variables](https://www.freecodecamp.org/news/using-environment-variables-the-right-way/) in Heroku, head over to this [guide](https://devcenter.heroku.com/articles/config-vars).
- `secretPath`: It could be our `BOT_TOKEN` or any random string.
  It is best practice to hide our bot path as [explained by Telegram](https://core.telegram.org/bots/api#setwebhook).

::: tip ⚡ Optimization (optional)
`bot.api.setWebhook` at line 14 will always run when Heroku starts your server again.
For low traffic bots, this will be for every request.
However, we do not need this code to run every time a request is coming.
Therefore, we can delete this part completely, and execute the `GET` only once manually.
Open this link on your web browser after deploying our bot:

```asciiart:no-line-numbers
https://api.telegram.org/bot<bot_token>/setWebhook?url=<webhook_url>
```

Note that some browsers require you to manually [encode](https://en.wikipedia.org/wiki/Percent-encoding#Reserved_characters) the `webhook_url` before passing it.
For instance, if we have bot token `abcd:1234` and URL `https://grammybot.herokuapp.com/secret_path`, then our link should look like this:

```asciiart:no-line-numbers
https://api.telegram.org/botabcd:1234/setWebhook?url=https%3A%2F%2Fgrammybot.herokuapp.com%2Fsecret_path
```

:::

::: tip ⚡ Optimization (optional)
Use [Webhook Reply](../guide/deployment-types#webhook-reply) for more efficiency.
:::

### Creating `bot.ts` (Webhooks)

Next step, head over to `bot.ts`:

```ts
import { Bot } from "grammy";

const token = process.env.BOT_TOKEN;
if (!token) throw new Error("BOT_TOKEN is unset");

export const bot = new Bot(token);

bot.command("start", (ctx) => ctx.reply("Hello there!"));
bot.on("message", (ctx) => ctx.reply("Got another message!"));
```

Good!
We have now finished coding our main files.
But before we go to the deployment steps, we can optimize our bot a little bit.
As usual, this is optional.

::: tip ⚡ Optimization (optional)
Every time your server starts up, grammY will request [information about the bot](https://core.telegram.org/bots/api#getme) from Telegram in order to provide it on the [context object](../guide/context) under `ctx.me`.
We can set the [bot information](/ref/core/botconfig#botinfo) to prevent excessive `getMe` calls.

1. Open this link `https://api.telegram.org/bot<bot_token>/getMe` in your favorite web browser. [Firefox](https://www.mozilla.org/en-US/firefox/) is recommended since it displays `json` format nicely.
2. Change our code at line 4 above and fill the value according to the results from `getMe`:

   ```ts
   const token = process.env.BOT_TOKEN;
   if (!token) throw new Error("BOT_TOKEN is unset");

   export const bot = new Bot(token, {
     botInfo: {
       id: 111111111,
       is_bot: true,
       first_name: "xxxxxxxxx",
       username: "xxxxxxbot",
       can_join_groups: true,
       can_read_all_group_messages: false,
       supports_inline_queries: false,
     },
   });
   ```

:::

Cool!
It's time to prepare our deployment environment!
Straight to [Deployment Section](#deployment) everyone! :muscle:

## Long Polling

::: warning Your Script Will Run Continuously When Using Long Polling
Unless you know how to handle this behavior, make sure you have enough [dyno hours](https://devcenter.heroku.com/articles/eco-dyno-hours).
:::

> Consider using webhooks?
> Jump up to the [webhooks section](#webhooks). :rocket:

Using long polling on your server is not always a bad idea.
Sometimes, it is suitable for data gathering bots that don't need to respond quickly and handle lots of data.
If you want to do this once an hour, you can do that easily.
That's something you cannot control with webhooks.
If your bot gets flooded with messages, you will see a lot of webhooks requests, however, you can more easily limit the rate of updates to process with long polling.

### Creating `bot.ts` (Long Polling)

Let's open the `bot.ts` file that we have created earlier.
Have it contain these lines of code:

```ts
import { Bot } from "grammy";

const token = process.env.BOT_TOKEN;
if (!token) throw new Error("BOT_TOKEN is unset");

const bot = new Bot(token);

bot.command(
  "start",
  (ctx) => ctx.reply("I'm running on Heroku using long polling!"),
);

bot.start();
```

That's it!
We are ready to deploy it.
Pretty simple, right? :smiley:
If you think it is too easy, check out our [Deployment Checklist](../advanced/deployment#long-polling)! :rocket:

## Deployment

Nope… our _Rocket Bot_ is not ready to launch yet.
Complete these stages first!

### Compile Files

Run this code in your terminal to compile the TypeScript files to JavaScript:

```sh
npx tsc
```

If it runs successfully and does not print any errors, our compiled files should be in the `dist` folder with `.js` extensions.

### Set up `Procfile`

For the time being, `Heroku` has several [types of dynos](https://devcenter.heroku.com/articles/dynos#use-cases).
Two of them are:

- **Web dynos**:

  _Web dynos_ are dynos of the "web" process that receive HTTP traffic from routers.
  This kind of dyno has a timeout of 30 seconds for executing code.
  Also, it will sleep if there is no request to handle within a 30 minutes period.
  This type of dyno is quite suitable for _webhooks_.

- **Worker dynos**:

  _Worker dynos_ are typically used for background jobs.
  It does NOT have a timeout, and will NOT sleep if it does not handle any web requests.
  It fits _long polling_.

Create file named `Procfile` without a file extension in the root directory of our project.
For example, `Procfile.txt` and `procfile` are not valid.
Then write this single line code format:

```procfile
<dynos type>: <command for executing our main entry file>
```

For our case it should be:

::: code-group

```procfile [Webhook]
web: node dist/app.js
```

```procfile [Long Polling]
worker: node dist/bot.js
```

:::

### Set up Git

We are going to deploy our bot using [Git and Heroku Cli](https://devcenter.heroku.com/articles/git).
Here is the link for the installation:

- [Git installation instructions](https://git-scm.com/download)
- [Heroku CLI installation instructions](https://devcenter.heroku.com/articles/heroku-cli#install-the-heroku-cli)

Assuming that you already have them in your machine, and you have a terminal open in the root of our project's directory.
Now initialize a local git repository by running this code in your terminal:

```sh
git init
```

Next, we need to prevent unnecessary files from reaching our production server, in this case `Heroku`.
Create a file named `.gitignore` in root of our project's directory.
Then add this list:

```text
node_modules/
src/
tsconfig.json
```

Our final folder structure should now look like this:

::: code-group

```asciiart:no-line-numbers [Webhook]
.
├── .git/
├── node_modules/
├── dist/
│   ├── bot.js
│   └── app.js
├── src/
│   ├── bot.ts
│   └── app.ts
├── package.json
├── package-lock.json
├── tsconfig.json
├── Procfile
└── .gitignore
```

```asciiart:no-line-numbers [Long Polling]
.
├── .git/
├── node_modules/
├── dist/
│   └── bot.js
├── src/
│   └── bot.ts
├── package.json
├── package-lock.json
├── tsconfig.json
├── Procfile
└── .gitignore
```

:::

Commit files to our git repository:

```sh
git add .
git commit -m "My first commit"
```

### Set Up a Heroku Remote

If you have already created [Heroku app](https://dashboard.heroku.com/apps/), pass your `Existing app`'s name in `<myApp>` below, then run the code.
Otherwise, run `New app`.

::: code-group

```sh [New app]
heroku create
git remote -v
```

```sh [Existing app]
heroku git:remote -a <myApp>
```

:::

### Deploying Code

Finally, press the _red button_ and liftoff! :rocket:

```sh
git push heroku main
```

If it doesn't work, it's probably our git branch is not `main` but `master`.
Press this _blue button_ instead:

```sh
git push heroku master
```
</file>

<file path="site/docs/hosting/supabase.md">
---
prev: false
next: false
---

# Hosting: Supabase Edge Functions

This guide tells you how you can host your grammY bots on [Supabase](https://supabase.com/).

Please note that you need to have a [GitHub](https://github.com) account before you can use [Supabase Edge Functions](https://supabase.com/docs/guides/functions/quickstart).
Moreover, Supabase Edge Functions are based on [Deno Deploy](https://deno.com/deploy), so just like [our Deno Deploy guide](./deno-deploy), this guide is only for Deno users of grammY.

Supabase Edge Functions is ideal for most simple bots, and you should note that not all Deno features are available for apps running on Supabase Edge Functions.
For example, there is no file system on Supabase Edge Functions.
It's just like the other many serverless platforms, but dedicated for Deno apps.

The result of this tutorial [can be seen in our example bots repository](https://github.com/grammyjs/examples/tree/main/setups/supabase-edge-functions).

## Setup

In order to deploy a Supabase Edge Function, you will need to create a Supabase account, install their CLI, and create a Supabase project.
You should first [follow their documentation](https://supabase.com/docs/guides/functions/quickstart#initialize-a-project) to set things up.

Create a new Supabase Function by running this command:

```sh
supabase functions new telegram-bot
```

Once you have created a Supabase Function project, you can write your bot.

## Preparing Your Code

> Remember that you need to [run your bot on webhooks](../guide/deployment-types#how-to-use-webhooks), so you should use `webhookCallback` and not call `bot.start()` in your code.

You can use this short example bot as a starting point.

```ts
import { Bot, webhookCallback } from "https://deno.land/x/grammy/mod.ts";

const token = Deno.env.get("BOT_TOKEN");
if (!token) throw new Error("BOT_TOKEN is unset");

const bot = new Bot(token);

bot.command("start", (ctx) => ctx.reply("Welcome! Up and running."));
bot.command("ping", (ctx) => ctx.reply(`Pong! ${new Date()}`));

const handleUpdate = webhookCallback(bot, "std/http");

Deno.serve(async (req) => {
  try {
    const url = new URL(req.url);
    if (url.searchParams.get("secret") !== bot.token) {
      return new Response("not allowed", { status: 405 });
    }
    return await handleUpdate(req);
  } catch (err) {
    console.error(err);
  }
  return new Response();
});
```

## Deploying

You can now deploy your bot to Supabase.
Note that you will have to disable JWT authorization because Telegram uses a different way to make sure the requests are coming from Telegram.
You can deploy the function using this command.

```sh
supabase functions deploy --no-verify-jwt telegram-bot
```

Next, you need to give your bot token to Supabase so that your code has access to it as an environment variable.

```sh
# Replace 123:aBcDeF-gh with your real bot token.
supabase secrets set BOT_TOKEN=123:aBcDeF-gh
```

Your Supabase Function is now working.
All that's left to do is to tell Telegram where to send the updates.
You can do this by calling `setWebhook`.
For example, open a new tab in your browser and visit this URL:

```text
https://api.telegram.org/bot<BOT_TOKEN>/setWebhook?url=https://<PROJECT_REFERENCE_ID>.supabase.co/functions/v1/telegram-bot?secret=<BOT_TOKEN>
```

Replace `<BOT_TOKEN>` with your real bot token.
Also, replace the second occurrence of `<BOT_TOKEN>` with your real bot token.
Replace `<PROJECT_REFERENCE_ID>` with the reference ID of your Supabase project.

You should now see this in your browser window.

```json
{ "ok": true, "result": true, "description": "Webhook was set" }
```

Done!
Your bot is working now.
Head over to Telegram and watch it respond to messages!
</file>

<file path="site/docs/hosting/vercel.md">
---
prev: false
next: false
---

# Hosting: Vercel Serverless Functions

This tutorial will guide you on how to deploy your bot to [Vercel](https://vercel.com/) by using [Vercel Serverless Functions](https://vercel.com/docs/functions), assuming that you already have a [Vercel](https://vercel.com) account.

## Project Structure

The only prerequisite to get started with **Vercel Serverless Functions** is to move your code to the `api/` directory as shown below.
You can also see [Vercel's documentation](https://vercel.com/docs/functions/quickstart) for more on this.

```asciiart:no-line-numbers
.
├── node_modules/
├── build/
├── api/
│   └── bot.ts
├── package.json
├── package-lock.json
└── tsconfig.json
```

If you are using TypeScript, you might as well want to install `@vercel/node` as a dev dependency, but it is not mandatory for following this guide.

## Configuring Vercel

The next step is to create a `vercel.json` file at the top level of your project.
For our example structure, its content would be:

```json
{
  "functions": {
    "api/bot.ts": {
      "memory": 1024,
      "maxDuration": 10
    }
  }
}
```

> If you want to use Vercel's free subscription, your `memory` and `maxDuration` configurations might look like above to not bypass its limits.

If you want to learn more about the `vercel.json` configuration file, see [its documentation](https://vercel.com/docs/projects/project-configuration).

## Configuring TypeScript

In our `tsconfig.json`, we have to specify our output directory as `build/`, and our root directory as `api/`.
This is important since we will specify them in Vercel's deploy options.

```json{5,8}
{
  "compilerOptions": {
    "target": "ES2019",
    "module": "commonjs",
    "rootDir": "./api",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "outDir": "./build",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true
  }
}
```

## The Main File

Regardless of using TypeScript or JavaScript, we should have a source file through which our bot runs.
It should look roughly like this:

```ts
import { Bot, webhookCallback } from "grammy";

const token = process.env.BOT_TOKEN;
if (!token) throw new Error("BOT_TOKEN is unset");

const bot = new Bot(token);

export default webhookCallback(bot, "https");
```

::: tip [Vercel Edge Functions](https://vercel.com/docs/functions) provides limited support for grammY
You can still use the core grammY package and a number of plugins, but others may be incompatible due to Node.js-only dependencies that might not be supported by Vercel's [Edge Runtime](https://edge-runtime.vercel.app).

Currently, we don't have a comprehensive list of compatible plugins, so you need to test it by yourself.

Use this snippet below if you want to switch to Edge Functions:

```ts
import { Bot, webhookCallback } from "grammy";

const token = process.env.BOT_TOKEN;
if (!token) throw new Error("BOT_TOKEN is unset");

const bot = new Bot(token);

export const config = {
  runtime: "edge",
};

export default webhookCallback(bot, "std/http");
```

:::

## In Vercel's Dashboard

Assuming that you already have a Vercel account your GitHub is connected to, add a new project and select your bot's repository.
In _Build & Development Settings_:

- Output directory: `build`
- Install command: `npm install`

Don't forget to add the secrets such as your bot token as environment variables in the settings.
Once you have done that, you can deploy it!

## Setting the Webhook

The last step is to connect your Vercel app with Telegram.
Modify the below URL to your credentials and visit it from your browser:

```text
https://api.telegram.org/bot<BOT_TOKEN>/setWebhook?url=<HOST_URL>
```

The `HOST_URL` is a little tricky, because you need to use your **Vercel app domain following with the route to the bot code**, for example `https://appname.vercel.app/api/bot`.
Where `bot` is referring to your `bot.ts` or `bot.js` file.

You should then see a response like this:

```json
{
  "ok": true,
  "result": true,
  "description": "Webhook was set"
}
```

Congratulations!
Your bot should now be up and running.
</file>

<file path="site/docs/hosting/vps.md">
---
prev: false
next: false
---

<!-- markdownlint-disable no-duplicate-heading -->

# Hosting: VPS

A virtual private server, mostly known as VPS, is a virtual machine running in the cloud with you, the developer, having full control over the system.

## Server Rental

> To be able to follow this guide, you first need to rent a VPS.
> This section will explain how to do that.
> If you already have a VPS to work on, skip to the [next section](#starting-the-bot).

In this guide, we will use the services of [Hostinger](https://hostinger.com).

> You are free to choose the provider of your choice.
> All providers provide the same services, so you won't have any problems with the technical part of this article.
> You can take this part as an overview of how the server rental operation works.
> If you are a beginner, you can use this guide to rent your first ever server!

::: tip Analog of a Server
If you cannot or do not want to rent a server but you still want to play around with running a bot on a VPS, you can follow this tutorial on a virtual machine instead.
To do this, use an application such as [VirtualBox](https://virtualbox.org).
Create a virtual machine with the desired Linux distribution to simulate a Linux server.
:::

Go to the [VPS Hosting page](https://hostinger.com/vps-hosting).
We will use the "KVM 1" plan.
The resources of "KVM 1" are enough for bots with a large audience, and even more so for our test bot.

Click the "Add to cart" button.
You will be automatically redirected to the checkout page, where you will also immediately register with Hostinger.

::: warning Change the Rental Term!
The typical lease term is 1-2 year (a marketing ploy), and it costs a lot of money.
You probably don't need it, so you can start by renting a server for a month, which is much cheaper.

In any case, Hostinger provides a 30-day money-back guarantee.
:::

After making your payment, you will be able to set up your server:

1. **Location.**
   We recommend that you [choose the location](../guide/api#choosing-a-data-center-location) closest to Amsterdam.
   The main Bot API server is located in Amsterdam.
   If you use your [own Bot API server](../guide/api#running-a-local-bot-api-server), choose the closest location to it instead.
2. **Server type.**
   Choose the option "Clean OS."
3. **Operating system.**
   We will use Ubuntu 22.04.
   If you choose a different system, some steps may be different, so be careful.
4. **Server name.**
   Pick any name you like.
5. **Root password.**
   Make a strong password and keep it in a safe place!
6. **SSH key**.
   Skip this step.
   We will set up SSH keys [later](#ssh-keys).

After the server is created, you can connect to it using SSH:

> SSH (_Secure Shell_) is a network protocol that can be used to remotely control a computer.

```sh
ssh root@<ip-address>
```

Replace `<ip-address>` with the IP address of your server which you can find on the server management page.

::: tip Configuring SSH
It can be difficult and tedious to remember which IP address and whose name you need to connect to a server.
To eliminate these routine steps and improve your server experience, you can configure SSH by creating a `~/.ssh/config` (<https://linuxhandbook.com/ssh-config-file>) file on your computer that stores all the data you need to connect to the server under certain arbitrary identifiers.
This is beyond the scope of this article, so you'll have to configure it yourself.
:::

::: tip Separate User for Each Application
In this guide, all actions with the server will be performed as the root user.
This is done on purpose to simplify this guide.
However, in reality, the root user should only be responsible for general services (web server, database, etc.), and applications should be run by individual non-root users.
This approach ensures the security of confidential data and prevents hacking of the entire system.
At the same time, it imposes some inconveniences.
Describing all these points unnecessarily increases the complexity of the article, which we try to avoid.
:::

## Starting the Bot

We now have a server at our disposal where we can run the bot to keep it running around the clock.

To simplify the beginning of the article, we skipped the step of delivering the code to the server automatically each time after pushing your code, but it is described [below](#ci-cd).

For now, you can copy local files to a remote server using the following command.
Note that `-r` copies recursively, so you only need to specify the root directory of your project:

```sh
scp -r <path-to-local-project-root> root@<ip-address>:<path-to-remote-directory>
```

Replace `<path-to-local-project-root>` with the path to the project directory on your local disk, `<ip-address>` with the IP address of your server, and `<path-to-remote-directory>` with the path to the directory where the bot's source code should be stored on the server.

As mentioned above, you should now be able to open a remote terminal on your VPS by starting an SSH session.

```sh
ssh root@<ip-address>
```

Note how your command prompt changes.
This indicates that you are now connected to the remote machine.
Every command you type will be run on your VPS.
Try running `ls` to confirm that you have successfully copied over your source files.

The remainder of this page will assume that you are able to connect to your VPS.
All following commands need to be run in an SSH session.

:::tip Don't forget to install the runtime!
To run the bot, you need to install Node.js or Deno on the server, depending on the runtime in which the bot will run.
This is beyond the scope of this article, so you will need to do it yourself.
You probably already did this when [getting started](../guide/getting-started), so you should be familiar with the steps. :wink:
:::

Below are two ways you can keep your bot running smoothly: using [systemd](#systemd) or [PM2](#pm2).

### systemd

systemd is a powerful service manager which is pre-installed on many Linux distributions, mainly Debian-based ones such as Ubuntu.

#### Getting the Start Command

1. Get the absolute path to your runtime:

   ::: code-group

   ```sh [Deno]
   which deno
   ```

   ```sh [Node.js]
   which node
   ```

   :::

2. You should have the absolute path to your bot's directory.

3. Your start command should look like the following:

   ```sh
   <runtime_path> <options> <entry_file_relative_path>

   # Path to the bot directory: /home/user/bot1/

   # Deno example:
   # /home/user/.deno/bin/deno --allow-all run mod.ts

   # Node.js example:
   # /home/user/.nvm/versions/node/v16.9.1/bin/node index.js
   ```

#### Creating the Service

1. Go to the services directory:

   ```sh
   cd /etc/systemd/system
   ```

2. Open your new service file with an editor:

   ```sh
   nano <app-name>.service
   ```

   > Replace `<app-name>` with any identifier.
   > `<app-name>.service` will be the name of your service.

3. Add the following content:

   ```text
   [Unit]
   After=network.target

   [Service]
   WorkingDirectory=<bot-directory-path>
   ExecStart=<start-command>
   Restart=on-failure

   [Install]
   WantedBy=multi-user.target
   ```

   Replace `<bot-directory-path>` with the absolute path to your bot's directory and `<start-command>` with the command you received [above](#getting-the-start-command).

   Here is a brief explanation of the service configuration:

   - `After=network.target` --- indicates that the application should be launched after the Internet module is loaded.
   - `WorkingDirectory=<bot-directory-path>` --- sets the current working directory of the process.
     This allows you to use relative assets, such as the `.env` file, which contains all the necessary environment variables.
   - `ExecStart=<start-command>` --- sets the startup command.
   - `Restart=on-failure` --- indicates that the application should restart after a crash.
   - `WantedBy=multi-user.target` --- defines the system state in which the service should be launched.
     `multi-user.target` --- is a typical value for servers.

   > For more information on the unit files, read [this](https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/9/html/using_systemd_unit_files_to_customize_and_optimize_your_system/assembly_working-with-systemd-unit-files_working-with-systemd).

4. Reload systemd whenever you edit the service:

   ```sh
   systemctl daemon-reload
   ```

#### Managing the Service

```sh
# Replace `<service-name>` with the file name of the service you created.

# To start the service
systemctl start <service-name>

# To view the service logs
journalctl -u <service-name>

# To restart the service
systemctl restart <service-name>

# To stop the service
systemctl stop <service-name>

# To enable the service to start when the server boots
systemctl enable <service-name>

# To disable service startup when the server boots
systemctl disable <service-name>
```

Starting the service should now launch your bot!

### PM2

[PM2](https://pm2.keymetrics.io) is a daemon process manager for Node.js that will help you manage and keep your app online 24/7.

PM2 is designed specifically to manage applications written in Node.js.
However, it can also be used to manage applications written in other languages or runtimes.

#### Installing

::: code-group

```sh [NPM]
npm install -g pm2
```

```sh [Yarn]
yarn global add pm2
```

```sh [pnpm]
pnpm add -g pm2
```

:::

#### Creating an Application

PM2 offers two ways to create an application:

1. Use the command line interface.
2. Use the [configuration file](https://pm2.keymetrics.io/docs/usage/application-declaration).

The first method is convenient when getting to know PM2.
However, during deployment, you should use the second method, which is what we did in our case.

Create a `ecosystem.config.js` file on the server in the directory where the bot build is stored with the following content:

```js
module.exports = {
  apps: [{
    name: "<app-name>",
    script: "<start-command>",
  }],
};
```

Replace `<app-name>` with any identifier and `<start command>` with the command to start the bot.

#### Managing the Application

Below are the commands you can use to control the application.

```sh
# If the `ecosystem.config.js` file is in the current directory,
# you can specify nothing to start the application.
# If the application is already running, this command will restart it.
pm2 start

# All of the following commands require you to specify the name of the application
# or the `ecosystem.config.js` file.
# To apply the action to all applications, specify `all`.

# To restart the app
pm2 restart <app-name>

# To reload the app
pm2 reload <app-name>

# To stop the app
pm2 stop <app-name>

# To delete an app
pm2 delete <app-name>
```

#### Saving the Application Operation

If the server reboots, your bot will not resume working.
For the bot to resume work, you need to prepare PM2 for this.

On the server in the terminal, run the following command:

```sh
pm2 startup
```

You will be provided with a command that you must execute to make PM2 automatically start after the server reboots.

Then run one more command:

```sh
pm2 save
```

This command will save the list of current applications so that they can be launched after a server reboot.

If you have created a new application and want to save it as well, simply run `pm2 save` again.

## Running the Bot on Webhooks

To run a bot on webhooks, you will need to use a web framework and **NOT** call `bot.start()`.

Here is a sample code to run the bot on webhooks that should be added to the main bot file:

::: code-group

```ts [Node.js]
import { webhookCallback } from "grammy";
import { fastify } from "fastify";

const server = fastify();

server.post(`/${bot.token}`, webhookCallback(bot, "fastify"));

server.listen();
```

```ts [Deno]
import { webhookCallback } from "https://deno.land/x/grammy/mod.ts";

const handleUpdate = webhookCallback(bot, "std/http");

Deno.serve(async (req) => {
  if (req.method === "POST") {
    const url = new URL(req.url);
    if (url.pathname.slice(1) === bot.token) {
      try {
        return await handleUpdate(req);
      } catch (err) {
        console.error(err);
      }
    }
  }
  return new Response();
});
```

:::

### Domain Rental

To connect a bot running on webhooks to the outside world, you need to purchase a domain.
We are going to explain this with Hostinger again, but there are many other services, too, and they all work similarly.

Go to the [domain name search page](https://www.hostinger.com/domain-name-search).
In the text input field, enter a domain name of the form `<name>.<zone>`.
For example, `example.com`.

If the desired domain is free, click the Add button next to it.
You will be automatically redirected to the checkout page, where you will also immediately register with Hostinger if you are not already registered.
Pay for the domain.

#### Domain Pointing to VPS

Before your domain can work with your VPS, you need to point the domain to your server.
To do this, in the [Hostinger Control Panel](https://hpanel.hostinger.com), click the "Manage" button next to your domain.
Next, go to the DNS record management page by clicking on the "DNS / Name Servers" button in the menu on the left.

> First, find out the IP address of your VPS.

In the list of DNS records, find the record of type `A` with the name `@`.
Edit this record by changing the IP address in the "Points to" field to the IP address of your VPS, and set the TTL to 3600.

Next, find and delete the record of type `CNAME` with the name `www`.
Instead, create a new record of type `A` with the name `www`, pointing to the IP address of your VPS, and set the TTL to 3600.

> If you run into problems, use the other method described in the [knowledge base](https://support.hostinger.com/en/articles/1583227-how-to-point-a-domain-to-your-vps).

### Setting up a Web Server

For the website to work and the bot to start receiving updates from Telegram, you need to set up a web server.
We will use [Caddy](https://caddyserver.com).

Caddy is a powerful open source web server with automatic HTTPS.

::: tip Web Server
We use Caddy because, unlike mainstream web servers like Nginx or Apache, it automatically configures SSL certificates.
This makes the article much easier.
However, you are free to choose any web server you want.
:::

#### Installation

The following five commands will download and automatically start Caddy as a systemd service called `caddy`.

```sh
apt install -y debian-keyring debian-archive-keyring apt-transport-https curl
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list
apt update
apt install caddy
```

> See the [Caddy installation guide](https://caddyserver.com/docs/install) for other installation options.

Check the status of Caddy:

```sh
systemctl status caddy
```

::: details Troubleshooting
Some hosting providers provide VPS with a pre-installed web server, for example, [Apache](https://httpd.apache.org).
Multiple web servers cannot run on the same machine at the same time.
For Caddy to work, you need to stop and shut down another web server:

```sh
systemctl stop <service-name>
systemctl disable <service-name>
```

Replace `service-name` with the name of the web server service that is interfering with Caddy.

:::

Now, if you open your server's IP address in a browser, you will see a typical page with instructions on how to set up Caddy.

#### Configuring

In order for Caddy to process requests coming to our domain, we need to change the Caddy configuration.

Run the following command to open the Caddy configuration file:

```sh
nano /etc/caddy/Caddyfile
```

You will see the following default configuration:

```text
# The Caddyfile is an easy way to configure your Caddy web server.
#
# Unless the file starts with a global options block, the first
# uncommented line is always the address of your site.
#
# To use your own domain name (with automatic HTTPS), first make
# sure your domain's A/AAAA DNS records are properly pointed to
# this machine's public IP, then replace ":80" below with your
# domain name.

:80 {
  # Set this path to your site's directory.
  root * /usr/share/caddy

  # Enable the static file server.
  file_server

  # Another common task is to set up a reverse proxy:
  # reverse_proxy localhost:8080

  # Or serve a PHP site through php-fpm:
  # php_fastcgi localhost:9000
}

# Refer to the Caddy docs for more information:
# https://caddyserver.com/docs/caddyfile
```

For the bot to work, make the configuration look like this:

```text
<domain> {
  reverse_proxy /<token> localhost:<port>
}
```

Replace `<domain>` with your domain, `<token>` with your bot token, and `<port>` with the port on which you want to run your bot.

Reload Caddy every time you change the site's configuration file using the following command:

```sh
systemctl reload caddy
```

Now all requests to the address `https://<domain>/<token>` will be redirected to the address `http://localhost:<port>/<token>`, where the bot's webhook is running.

#### Connecting a Webhook to Telegram

All you have to do is tell Telegram where to send the updates.
To do this, open your browser and visit the page at the following link:

```text
https://api.telegram.org/bot<token>/setWebhook?url=https://<domain>/<token>
```

Replace `<token>` with your bot token and `<domain>` with your domain.

## CI/CD

[CI/CD](https://about.gitlab.com/topics/ci-cd) is an important part of the modern software development process.
This guide covers almost all of the [CI/CD pipeline](https://about.gitlab.com/topics/ci-cd/cicd-pipeline).

We will focus on writing scripts for GitHub and GitLab.
You can easily adapt the examples below to your CI/CD service of choice, such as Jenkins, Buddy, etc., if needed.

### SSH Keys

To deliver files to the server, you need to set up passwordless authentication, which is implemented using SSH keys.

The following commands should be run on your personal computer.

Change to the directory with the SSH keys:

```sh
cd ~/.ssh
```

Generate a new key pair:

::: code-group

```sh [GitHub]
ssh-keygen -t rsa -m PEM
```

```sh [GitLab]
ssh-keygen -t ed25519
```

:::

This command will generate a public and private key of the type and format you want for GitHub and GitLab.
You can also specify a custom key name if you wish.

Next, send the **public** key to the server:

```sh
ssh-copy-id -i <key-name>.pub root@<ip-address>
```

Replace `<key-name>` with the name of the generated key and `<ip-address>` with the IP address of your server.

Note that the **public** key can be located on many servers, and the **private** key should be only with you and GitHub or GitLab.

You can now connect to the server without having to enter a password.

### Example Workflows

#### Node.js (GitHub)

Use

```yml
name: Main

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v3
        with:
          node-version: "latest"
      - run: npm ci
      - name: Build
        run: npm run build
      - uses: actions/upload-artifact@v3
        with:
          name: source
          path: |
            dist/*.js
            package.json
            package-lock.json
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v3
        with:
          name: source
          path: dist/
      - name: Deploy
        uses: easingthemes/ssh-deploy@v4
        env:
          SOURCE: "dist package.json package-lock.json"
          ARGS: "--delete -az"
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          TARGET: "<target-directory>"
          SCRIPT_AFTER: |
            cd <target-directory>
            npm i --omit=dev
            <start-command>
```

where `<target-directory>` is replaced with the name of the directory where the bot build is stored on the server, and `<start-command>` with the command to start your bot, which can for example be a call to `pm2` or `systemctl`.

This script sequentially performs two tasks: `build` and `deploy`.
After `build` is executed, the artifact of this task, namely the `dist` directory containing the bot build, is passed to the `deploy` task.

Files are delivered to the server using the `rsync` utility, which is implemented by `easingthemes/ssh-deploy`.
After the files are delivered to the server, the command described in the `SCRIPT_AFTER` environment variable is executed.
In our case, after the files are delivered, we go to the bot directory, where we install all the dependencies except `devDependencies`, and restart the bot.

Note that you need to add three [secret environment variables](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions):

1. `SSH_PRIVATE_KEY`---this is where the private SSH key you created in the [previous step](#ssh-keys) should be stored.
2. `REMOTE_HOST`---the IP address of your server should be stored here.
3. `REMOTE_USER`---the name of the user on whose behalf the bot is launched should be stored here.

#### Node.js (GitLab)

Use

```yml
image: node:latest

stages:
  - build
  - deploy

Build:
  stage: build
  before_script: npm ci
  script: npm run build
  artifacts:
    paths:
      - dist/

Deploy:
  stage: deploy
  before_script:
    - "command -v ssh-agent >/dev/null || ( apt-get update -y && apt-get install openssh-client -y )"
    - "command -v rsync >/dev/null || ( apt-get update -y && apt-get install rsync -y )"
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan "$REMOTE_HOST" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - rsync --delete -az dist package.json package-lock.json $REMOTE_USER@$REMOTE_HOST:<target-directory>
    - ssh $REMOTE_USER@$REMOTE_HOST "cd <target-directory> && npm i --omit=dev && <start-command>"
```

where `<target-directory>` is replaced with the name of the directory where the bot build is stored on the server, and `<start-command>` with the command to start your bot, which can for example be a call to `pm2` or `systemctl`.

This script sequentially performs two tasks: `build` and `deploy`.
After `build` is executed, the artifact of this task, namely the `dist` directory containing the bot build, is passed to the `deploy` task.

The files are delivered to the server using the `rsync` utility, which we must install before executing the main script.
After the files are delivered, we connect to the server using SSH to run a command to install all dependencies except `devDependencies` and restart the application.

Note that you need to add three [environment variables](https://docs.gitlab.com/ee/ci/variables):

1. `SSH_PRIVATE_KEY`---this is where the private SSH key you created in the [previous step](#ssh-keys) should be stored.
2. `REMOTE_HOST`---the IP address of your server should be stored here.
3. `REMOTE_USER`---the name of the user on whose behalf the bot is launched should be stored here.

#### Deno (GitHub)

Use

```yml
name: Main

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Deploy
        uses: easingthemes/ssh-deploy@v4
        env:
          SOURCE: "src deno.jsonc deno.lock"
          ARGS: "--delete -az"
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          TARGET: "<target-directory>"
          SCRIPT_AFTER: |
            cd <target-directory>
            <start-command>
```

where `<target-directory>` is replaced with the name of the directory where the bot build is stored on the server, and `<start-command>` with the command to start your bot, which can for example be a call to `pm2` or `systemctl`.

This script sends files to the server using the `rsync` utility, which is implemented by `easingthemes/ssh-deploy`.
After the files are delivered to the server, the command described in the `SCRIPT_AFTER` environment variable is executed.
In our case, after the files are delivered, we go to the bot's directory and restart the bot.

Note that you need to add three [secret environment variables](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions):

1. `SSH_PRIVATE_KEY`---this is where the private SSH key you created in the [previous step](#ssh-keys) should be stored.
2. `REMOTE_HOST`---the IP address of your server should be stored here.
3. `REMOTE_USER`---the name of the user on whose behalf the bot is launched should be stored here.

#### Deno (GitLab)

Use

```yml
image: denoland/deno:latest

stages:
  - deploy

Deploy:
  stage: deploy
  before_script:
    - "command -v ssh-agent >/dev/null || ( apt-get update -y && apt-get install openssh-client -y )"
    - "command -v rsync >/dev/null || ( apt-get update -y && apt-get install rsync -y )"
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan "$REMOTE_HOST" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - rsync --delete -az src deno.jsonc deno.lock $REMOTE_USER@$REMOTE_HOST:<target-directory>
    - ssh $REMOTE_USER@$REMOTE_HOST "cd <target-directory> && npm i --omit=dev && <start-command>"
```

where `<target-directory>` is replaced with the name of the directory where the bot build is stored on the server, and `<start-command>` with the command to start your bot, which can for example be a call to `pm2` or `systemctl`.

This script sends files to the server using `rsync`, which has to be installed previously.
After the files are copied, we connect to the server using SSH to restart the bot.

Note that you need to add three [environment variables](https://docs.gitlab.com/ee/ci/variables):

1. `SSH_PRIVATE_KEY`---this is where the private SSH key you created in the [previous step](#ssh-keys) should be stored.
2. `REMOTE_HOST`---the IP address of your server should be stored here.
3. `REMOTE_USER`---the name of the user on whose behalf the bot is launched should be stored here.

You should now see how every code push to the `main` branch will automatically be deployed to your VPS.
Development go brrrrr :rocket:
</file>

<file path="site/docs/hosting/zeabur-deno.md">
---
prev: false
next: false
---

# Hosting: Zeabur (Deno)

[Zeabur](https://zeabur.com) is a platform that allows you to deploy your full-stack applications with ease.
It supports various programming languages and frameworks, including Deno and grammY.

This tutorial will guide you how to deploy your grammY bots with Deno to [Zeabur](https://zeabur.com).

::: tip Looking for the Node.js Version?
This tutorial explains how to deploy a Telegram bot to Zeabur using Deno.
If you're looking for the Node.js version, please check out [this tutorial](./zeabur-nodejs) instead.
:::

## Prerequisites

To follow along, you need to have [GitHub](https://github.com) and [Zeabur](https://zeabur.com) accounts.

### Method 1: Create a New Project from Scratch

> Make sure you have Deno installed on your local machine.

Initialize your project and install some necessary dependencies:

```sh
# Initialize the project.
mkdir grammy-bot
cd grammy-bot

# Create main.ts file
touch main.ts

# Create deno.json file to generate lock file
touch deno.json
```

Then modify `main.ts` file with the following code:

```ts
import { Bot } from "https://deno.land/x/grammy/mod.ts";

const token = Deno.env.get("TELEGRAM_BOT_TOKEN");
if (!token) throw new Error("TELEGRAM_BOT_TOKEN is unset");

const bot = new Bot(token);

bot.command("start", (ctx) => ctx.reply("Hello from Deno & grammY!"));

bot.on("message", (ctx) => ctx.reply("How can I help you?"));

bot.start();
```

> Note: Get your bot token with [@BotFather](https://t.me/BotFather) on Telegram, and set is as an environment variable `TELEGRAM_BOT_TOKEN` in Zeabur.
>
> You can check out [this tutorial](https://zeabur.com/docs/en-US/deploy/variables) for setting environment variables in Zeabur.

Then run the following command to start your bot:

```sh
deno -IN main.ts
```

Deno will automatically download the dependencies, generate the lock file, and start your bot.

### Method 2: Use Zeabur's Template

Zeabur has already provided a template for you to use.
You can find it [here](https://github.com/zeabur/deno-telegram-bot-starter).

You can just use the template and start writing your bot's code.

## Deploying

### Method 1: Deploy from GitHub in Zeabur's Dashboard

1. Create a repository on GitHub, it can be public or private and push your code to it.
2. Go to [Zeabur dashboard](https://dash.zeabur.com).
3. Click on the `New Project` button, and click on the `Deploy New Service` button, choose `GitHub` as the source and select your repository.
4. Go to `Variables` tab to add your environment variables like `TELEGRAM_BOT_TOKEN`.
5. Your service will be deployed automatically.

### Method 2: Deploy with Zeabur CLI

`cd` into your project directory and run the following command:

```sh
npx @zeabur/cli deploy
```

Follow the instructions to select a region to deploy, and your bot will be deployed automatically.
</file>

<file path="site/docs/hosting/zeabur-nodejs.md">
---
prev: false
next: false
---

# Hosting: Zeabur (Node.js)

[Zeabur](https://zeabur.com) is a platform that allows you to deploy your full-stack applications with ease.
It supports various programming languages and frameworks, including Node.js and grammY.

This tutorial will guide you how to deploy your grammY bots with Node.js to [Zeabur](https://zeabur.com).

::: tip Looking for the Deno Version?
This tutorial explains how to deploy a Telegram bot to Zeabur using Node.js.
If you're looking for the Deno version, please check out [this tutorial](./zeabur-deno) instead.
:::

## Prerequisites

To follow along, you need to have [GitHub](https://github.com) and [Zeabur](https://zeabur.com) accounts.

### Method 1: Create a New Project from Scratch

Initialize your project and install some necessary dependencies:

```sh
# Initialize the project.
mkdir grammy-bot
cd grammy-bot
npm init -y

# Install main dependencies.
npm install grammy

# Install development dependencies.
npm install -D typescript ts-node @types/node

# Initialize TypeScript.
npx tsc --init
```

Then, `cd` into `src/`, and create a file named `bot.ts`.
It is where you will write your bot's code.

Now, you can start writing your bot's code in `src/bot.ts`.

```ts
import { Bot } from "grammy";

const token = process.env.TELEGRAM_BOT_TOKEN;
if (!token) throw new Error("TELEGRAM_BOT_TOKEN is unset");

const bot = new Bot(token);

bot.on("message:text", async (ctx) => {
  console.log("Message: ", ctx.message.text);

  const response = "Hello, I'm a bot!";

  await ctx.reply(response);
});

bot.start();
```

> Note: Get your bot token with [@BotFather](https://t.me/BotFather) on Telegram, and set is as an environment variable `TELEGRAM_BOT_TOKEN` in Zeabur.
>
> You can check out [this tutorial](https://zeabur.com/docs/en-US/deploy/variables) for setting environment variables in Zeabur.

Now your project's root directory should now look like this:

```asciiart:no-line-numbers
.
├── node_modules/
├── src/
│   └── bot.ts
├── package.json
├── package-lock.json
└── tsconfig.json
```

And then we have to add `start` scripts to our `package.json`.
Our `package.json` should now be similar to this:

```json
{
  "name": "telegram-bot-starter",
  "version": "1.0.0",
  "description": "Telegram Bot Starter with TypeScript and grammY",
  "scripts": {
    "start": "ts-node src/bot.ts" // [!code focus]
  },
  "author": "MichaelYuhe",
  "license": "MIT",
  "dependencies": {
    "grammy": "^1.21.1"
  },
  "devDependencies": {
    "@types/node": "^20.14.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.5"
  }
}
```

Now, you can run your bot locally by running:

```sh
npm run start
```

### Method 2: Use Zeabur's Template

Zeabur has already provided a template for you to use.
You can find it [here](https://github.com/zeabur/telegram-bot-starter).

You can just use the template and start writing your bot's code.

## Deploying

### Method 1: Deploy From GitHub in Zeabur's Dashboard

1. Create a repository on GitHub, it can be public or private and push your code to it.
2. Go to [Zeabur dashboard](https://dash.zeabur.com).
3. Click on the `New Project` button, and click on the `Deploy New Service` button, choose `GitHub` as the source and select your repository.
4. Go to `Variables` tab to add your environment variables like `TELEGRAM_BOT_TOKEN`.
5. Your service will be deployed automatically.

### Method 2: Deploy With Zeabur CLI

`cd` into your project directory and run the following command:

```sh
npx @zeabur/cli deploy
```

Follow the instructions to select a region to deploy, and your bot will be deployed automatically.
</file>

<file path="site/docs/plugins/auto-retry.md">
---
prev: false
next: false
---

# Retry API Requests (`auto-retry`)

The auto-retry plugin is everything you need to handle [flood limits](../advanced/flood), i.e. errors with code 429.
It can be used for every bot during normal operation, but it will come especially handy during [broadcasting](../advanced/flood#how-to-broadcast-messages).

This plugin is an [API transformer function](../advanced/transformers), which means that it let's you intercept and modify outgoing HTTP requests on the fly.
More specifically, this plugin will automatically detect if an API requests fails with a `retry_after` value, i.e. because of rate limiting.
It will then catch the error, wait the specified period of time, and then retry the request.

In addition to handling flood limits, this plugin will retry a request if it fails with an internal server error, i.e. errors with code 500 or larger.
Networking errors (those that [throw an `HttpError`](../guide/errors#the-httperror-object) in grammY) will cause a retry, too.
Retrying such requests is more or less the only sane strategy to handle these two types of errors.
Since neither of them provide a `retry_after` value, the plugin employs exponential backoff starting at 3 seconds and capped at one hour.

## Installation

You can install this plugin on the `bot.api` object:

::: code-group

```ts [TypeScript]
import { autoRetry } from "@grammyjs/auto-retry";

// Use the plugin.
bot.api.config.use(autoRetry());
```

```js [JavaScript]
const { autoRetry } = require("@grammyjs/auto-retry");

// Use the plugin.
bot.api.config.use(autoRetry());
```

```ts [Deno]
import { autoRetry } from "https://deno.land/x/grammy_auto_retry/mod.ts";

// Use the plugin.
bot.api.config.use(autoRetry());
```

:::

If you now call e.g. `sendMessage` and run into a rate limit, it will look like the request just takes unusually long.
Under the hood, multiple HTTP requests are being performed, with the appropriate delays in between.

## Configuration

You may pass an options object that specifies a maximum number of retries (`maxRetryAttempts`), or a threshold for a maximum time to wait (`maxDelaySeconds`).

### Limiting Retries

As soon as the maximum number of retries is exhausted, subsequent errors for the same request will not be retried again.
Instead, the error object from Telegram is passed on, effectively failing the request with a [`GrammyError`](../guide/errors#the-grammyerror-object).

Similarly, if the request ever fails with `retry_after` larger than what is specified by the option `maxDelaySeconds`, the request will fail immediately.

```ts
autoRetry({
  maxRetryAttempts: 1, // only repeat requests once
  maxDelaySeconds: 5, // fail immediately if we have to wait >5 seconds
});
```

### Rethrowing Internal Server Errors

You can use `rethrowInternalServerErrors` to opt out of handling internal server errors as described [above](#retry-api-requests-auto-retry).
Again, the error object from Telegram is passed on, effectively failing the request with a [`GrammyError`](../guide/errors#the-grammyerror-object).

```ts
autoRetry({
  rethrowInternalServerErrors: true, // do not handle internal server errors
});
```

### Rethrowing Networking Errors

You can use `rethrowHttpErrors` to opt out of handling networking errors as described [above](#retry-api-requests-auto-retry).
If enabled, the thrown [`HttpError`](../guide/errors#the-httperror-object) instances are passed on, failing the request.

```ts
autoRetry({
  rethrowHttpErrors: true, // do not handle networking errors
});
```

## Plugin Summary

- Name: `auto-retry`
- [Source](https://github.com/grammyjs/auto-retry)
- [Reference](/ref/auto-retry/)
</file>

<file path="site/docs/plugins/autoquote.md">
---
prev: false
next: false
---

# Always Replying to Messages

It is sometimes necessary to always send messages as replies, especially for bots that are meant to be used in groups.
We usually do this by adding `reply_parameters` to the methods that send the message: `sendText`, `reply`, `sendPhoto`, `replyWithPhoto` and etc.
However, if you're doing this for every single message, it can get messy and boring.

This plugin sets the properties of `reply_parameters` for all `reply*` and `send*` methods that support it to make every message a reply to the message and chat that triggered it.

You can pass an options object with a `allowSendingWithoutReply` property to both `addReplyParam` and `autoQuote` functions, which will allow your bot to send messages even if the message being replied to does not exist anymore.

## Usage

### In a Specific Context

If you want all messages sent within a specific context (like a specific command), you can specifically apply the plugin to them:

::: code-group

```ts [TypeScript]
import { Bot } from "grammy";
import { addReplyParam } from "@roziscoding/grammy-autoquote";

const bot = new Bot("");

bot.command("demo", async (ctx) => {
  ctx.api.config.use(addReplyParam(ctx));
  await ctx.reply("Demo command!"); // this is going to quote the user's message
});

bot.start();
```

```js [JavaScript]
const { Bot } = require("grammy");
const { addReplyParam } = require("@roziscoding/grammy-autoquote");

const bot = new Bot("");

bot.command("demo", async (ctx) => {
  ctx.api.config.use(addReplyParam(ctx));
  await ctx.reply("Demo command!"); // this is going to quote the user's message
});

bot.start();
```

```ts [Deno]
import { Bot } from "https://deno.land/x/grammy/mod.ts";
import { addReplyParam } from "https://deno.land/x/grammy_autoquote/mod.ts";

const bot = new Bot("");

bot.command("demo", async (ctx) => {
  ctx.api.config.use(addReplyParam(ctx));
  await ctx.reply("Demo command!"); // this is going to quote the user's message
});

bot.start();
```

:::

### In Every Context

If you want every sent message to reply the messages that triggered them, you can apply the plugin this way:

::: code-group

```ts [TypeScript]
import { Bot } from "grammy";
import { autoQuote } from "@roziscoding/grammy-autoquote";

const bot = new Bot("");

bot.use(autoQuote());

bot.command("demo", async (ctx) => {
  await ctx.reply("Demo command!"); // this is going to quote the user's message
});

bot.command("hello", async (ctx) => {
  await ctx.reply("Hi there :)"); // this quotes the user's message, too
});

bot.start();
```

```js [JavaScript]
const { Bot } = require("grammy");
const { autoQuote } = require("@roziscoding/grammy-autoquote");

const bot = new Bot("");

bot.use(autoQuote());

bot.command("demo", async (ctx) => {
  await ctx.reply("Demo command!"); // this is going to quote the user's message
});

bot.command("hello", async (ctx) => {
  await ctx.reply("Hi there :)"); // this quotes the user's message, too
});

bot.start();
```

```ts [Deno]
import { Bot } from "https://deno.land/x/grammy/mod.ts";
import { autoQuote } from "https://deno.land/x/grammy_autoquote/mod.ts";

const bot = new Bot("");

bot.use(autoQuote());

bot.command("demo", async (ctx) => {
  await ctx.reply("Demo command!"); // this is going to quote the user's message
});

bot.command("hello", async (ctx) => {
  await ctx.reply("Hi there :)"); // this quotes the user's message, too
});

bot.start();
```

:::

## Plugin Summary

- Name: Autoquote
- [Source](https://github.com/roziscoding/grammy-autoquote)
</file>

<file path="site/docs/plugins/chat-members.md">
---
prev: false
next: false
---

# Chat Members Plugin (`chat-members`)

Automatically store information about users in a chat and retrieve it easily.
Track group and channel members, and list them.

## Introduction

In many situations, it is necessary for a bot to have information about all the users of a given chat.
Currently, though, the Telegram Bot API exposes no method that allows us to retrieve this information.

This plugin comes to the rescue: automatically listening to `chat_member` events and storing all `ChatMember` objects.

## Usage

### Storing Chat Members

You can use a valid grammY [storage adapter](./session#known-storage-adapters) or an instance of any class that implements the [`StorageAdapter`](/ref/core/storageadapter) interface.

Please note that as per the [official Telegram docs](https://core.telegram.org/bots/api#getupdates), your bot needs to specify the `chat_member` update in the `allowed_updates` array, as shown in the example below.
This means you also need to specify any other events you'd like to receive.

::: code-group

```ts [TypeScript]
import { Bot, type Context, MemorySessionStorage } from "grammy";
import { type ChatMember } from "grammy/types";
import { chatMembers, type ChatMembersFlavor } from "@grammyjs/chat-members";

type MyContext = Context & ChatMembersFlavor;

const adapter = new MemorySessionStorage<ChatMember>();

const bot = new Bot<MyContext>("");

bot.use(chatMembers(adapter));

bot.start({
  // Make sure to specify the desired update types
  allowed_updates: ["chat_member", "message"],
});
```

```js [JavaScript]
import { Bot, MemorySessionStorage } from "grammy";
import { chatMembers } from "@grammyjs/chat-members";

const adapter = new MemorySessionStorage();

const bot = new Bot("");

bot.use(chatMembers(adapter));

bot.start({
  // Make sure to specify the desired update types
  allowed_updates: ["chat_member", "message"],
});
```

```ts [Deno]
import {
  Bot,
  type Context,
  MemorySessionStorage,
} from "https://deno.land/x/grammy/mod.ts";
import { type ChatMember } from "https://deno.land/x/grammy/types.ts";
import {
  chatMembers,
  type ChatMembersFlavor,
} from "https://deno.land/x/grammy_chat_members/mod.ts";

type MyContext = Context & ChatMembersFlavor;

const adapter = new MemorySessionStorage<ChatMember>();

const bot = new Bot<MyContext>("");

bot.use(chatMembers(adapter));

bot.start({
  // Make sure to specify the desired update types
  allowed_updates: ["chat_member", "message"],
});
```

:::

### Reading Chat Members

This plugin also adds a new `ctx.chatMembers.getChatMember` function that will check the storage for information about a chat member before querying Telegram for it.
If the chat member exists in the storage, it will be returned.
Otherwise, `ctx.api.getChatMember` will be called and the result will be saved to the storage, making subsequent calls faster and removing the need to call Telegram again for that user and chat in the future.

Here's an example:

```ts
bot.on("message", async (ctx) => {
  const chatMember = await ctx.chatMembers.getChatMember();

  return ctx.reply(
    `Hello, ${chatMember.user.first_name}! I see you are a ${chatMember.status} of this chat!`,
  );
});
```

This function accepts the following optional parameters:

- `chatId`:
  - Default: `ctx.chat.id`
  - The chat identifier
- `userId`:
  - Default: `ctx.from.id`
  - The user identifier

You can pass them like so:

```ts
bot.on("message", async (ctx) => {
  const chatMember = await ctx.chatMembers.getChatMember(
    ctx.chat.id,
    ctx.from.id,
  );
  return ctx.reply(
    `Hello, ${chatMember.user.first_name}! I see you are a ${chatMember.status} of this chat!`,
  );
});
```

Please notice that, if you don't provide a chat identifier and there's no `chat` property inside the context (for example, on inline query updates), this will throw an error.
The same will happen if there's no `ctx.from` in the context.

## Aggressive Storage

The `enableAggressiveStorage` config option will install middleware to cache chat members without depending on the `chat_member` event.
For every update, the middleware checks if `ctx.chat` and `ctx.from` exist.
If they both do, it then proceeds to call `ctx.chatMembers.getChatMember` to add the chat member information to the storage in case it doesn't exist.

Please note that this means the storage will be called for **every update**, which may be a lot, depending on how many updates your bot receives.
This has the potential to impact the performance of your bot drastically.
Only use this if you _really_ know what you're doing and are okay with the risks and consequences.

## Plugin Summary

- Name: `chat-members`
- [Source](https://github.com/grammyjs/chat-members)
- [Reference](/ref/chat-members/)
</file>

<file path="site/docs/plugins/commands.md">
---
prev: false
next: false
---

# Commands (`commands`)

Command handling on steroids.

This plugin provides various features related to command handling that are not contained in the [command handling done by the core library](../guide/commands).
Here is a quick overview of what you get with this plugin:

- Better code readability by encapsulating middleware with command definitions
- User command menu synchronization via `setMyCommands`
- Improved command grouping and organization
- Ability to scope command reach, e.g: only accessible to group admins or
  channels, etc
- Defining command translations
- `Did you mean ...?` feature that finds the nearest existing command to a given
  user miss-input
- Case-insensitive command matching
- Setting custom behavior for commands that explicitly mention your bot's user,
  like: `/start@your_bot`
- Custom command prefixes, e.g: `+`, `?` or any symbol instead of `/`
- Support for commands that are not in the beginning of the message
- RegExp Commands!

All of these features are made possible because you will define one or more central command structures that define your bot's commands.

## Basic Usage

Before we dive in, take a look at how you can register and handle a command with the plugin:

```ts
const myCommands = new CommandGroup();

myCommands.command("hello", "Say hello", (ctx) => ctx.reply(`Hello, world!`));

bot.use(myCommands);
```

This registers a new `/hello` command to your bot that will be handled by the given middleware.

Now, let's get into some of the extra tools this plugin has to offer.

## Importing

First of all, here's how you can import all the necessary types and classes the plugin provides.

::: code-group

```ts [TypeScript]
import {
  CommandGroup,
  commandNotFound,
  commands,
  type CommandsFlavor,
} from "@grammyjs/commands";
```

```js [JavaScript]
const { CommandGroup, commands, commandNotFound } = require(
  "@grammyjs/commands",
);
```

```ts [Deno]
import {
  CommandGroup,
  commandNotFound,
  commands,
  type CommandsFlavor,
} from "https://deno.land/x/grammy_commands/mod.ts";
```

:::

Now that the imports are settled, let's see how we can make our commands visible to our users.

## User Command Menu Setting

Once you defined your commands with an instance of the `CommandGroup` class, you can call the `setCommands` method, which will register all the defined commands to your bot.

```ts
const myCommands = new CommandGroup();

myCommands.command("hello", "Say hello", (ctx) => ctx.reply("Hi there!"));
myCommands.command("start", "Start the bot", (ctx) => ctx.reply("Starting..."));

bot.use(myCommands);

await myCommands.setCommands(bot);
```

This will make it so every command you registered is displayed on the menu of a private chat with your bot, or whenever users type `/` on a chat your bot is a member of.

### Context Shortcut

What if you want some commands to be displayed only to certain users? For example, imagine you have a `login` and a `logout` command.
The `login` command should only appear for logged out users, and vice versa.
This is how you can do that with the commands plugin:

::: code-group

```ts [TypeScript]
// Use the flavor to create a custom context
type MyContext = Context & CommandsFlavor;

// Use the new context to instantiate your bot
const bot = new Bot<MyContext>("token");

// Register the context shortcut
bot.use(commands());

const loggedOutCommands = new CommandGroup();
const loggedInCommands = new CommandGroup();

loggedOutCommands.command(
  "login",
  "Start your session with the bot",
  async (ctx) => {
    await ctx.setMyCommands(loggedInCommands);
    await ctx.reply("Welcome! Session started!");
  },
);

loggedInCommands.command(
  "logout",
  "End your session with the bot",
  async (ctx) => {
    await ctx.setMyCommands(loggedOutCommands);
    await ctx.reply("Goodbye :)");
  },
);

bot.use(loggedInCommands);
bot.use(loggedOutCommands);

// By default, users are not logged in,
// so you can set the logged out commands for everyone
await loggedOutCommands.setCommands(bot);
```

```js [JavaScript]
// Register the context shortcut
bot.use(commands());

const loggedOutCommands = new CommandGroup();
const loggedInCommands = new CommandGroup();

loggedOutCommands.command(
  "login",
  "Start your session with the bot",
  async (ctx) => {
    await ctx.setMyCommands(loggedInCommands);
    await ctx.reply("Welcome! Session started!");
  },
);

loggedInCommands.command(
  "logout",
  "End your session with the bot",
  async (ctx) => {
    await ctx.setMyCommands(loggedOutCommands);
    await ctx.reply("Goodbye :)");
  },
);

bot.use(loggedInCommands);
bot.use(loggedOutCommands);

// By default, users are not logged in,
// so you can set the logged out commands for everyone
await loggedOutCommands.setCommands(bot);
```

:::

This way when a user calls `/login`, they'll have their command list changed to contain only the `logout` command.
Neat, right?

::: danger Command Name Restrictions
As stated in the [Telegram Bot API documentation](https://core.telegram.org/bots/api#botcommand), command names can only be form out of:

> 1-32 characters.
> Can contain only lowercase English letters, digits and underscores.

Therefore calling `setCommands` or `setMyCommands` with anything but lower_c4s3_commands will throw an exception.
Commands not following this rules can still be registered, used and handled, but will never be displayed on the user menu as such.
:::

**Be aware** that `setCommands` and `setMyCommands` only affects the commands displayed in the user's commands menu, and not the actual access to them.
You will learn how to implement restricted command access in the [Scoped Commands](#scoped-commands) section.

### Grouping Commands

Since we can split and group our commands into different instances, it allows for a much more idiomatic command file organization.

Let's say we want to have developer-only commands.
We can achieve that with the following code structure:

```ascii
src/
├─ commands/
│  ├─ admin.ts
│  ├─ users/
│  │  ├─ group.ts
│  │  ├─ say-hi.ts
│  │  ├─ say-bye.ts
│  │  ├─ ...
├─ bot.ts
├─ types.ts
tsconfig.json
```

The following code group exemplifies how we could implement a developer only command group, and update the Telegram client Command menu accordingly.
Make sure you take notice of the different patterns being use in the `admin.ts` and `group.ts` file-tabs.

::: code-group

```ts [types.ts]
export type MyContext = Context & CommandsFlavor<MyContext>;
```

```ts [bot.ts]
import { devCommands } from "./commands/admin.ts";
import { userCommands } from "./commands/users/group.ts";
import type { MyContext } from "./types.ts";

export const bot = new Bot<MyContext>("MyBotToken");

bot.use(commands());

bot.use(userCommands);
bot.use(devCommands);
```

```ts [admin.ts]
import { userCommands } from './users/group.ts'
import type { MyContext } from '../types.ts'

export const devCommands = new CommandGroup<MyContext>()

devCommands.command('devlogin', 'Greetings', async (ctx, next) => {
   if (ctx.from?.id === ctx.env.DEVELOPER_ID) {
      await ctx.reply('Hi to me')
      await ctx.setMyCommands(userCommands, devCommands)
   } else {
     await next()
   }
})

devCommands.command('usercount', 'Greetings', async (ctx, next) => {
   if (ctx.from?.id === ctx.env.DEVELOPER_ID) {
      await ctx.reply(
        `Active users: ${/** Your business logic */}`
    )
   } else {
     await next()
   }
})

devCommands.command('devlogout', 'Greetings', async (ctx, next) => {
    if (ctx.from?.id === ctx.env.DEVELOPER_ID) {
       await ctx.reply('Bye to me')
       await ctx.setMyCommands(userCommands)
   } else {
     await next()
   }
 })
```

```ts [group.ts]
import sayHi from "./say-hi.ts";
import sayBye from "./say-bye.ts";
import etc from "./another-command.ts";
import type { MyContext } from "../../types.ts";

export const userCommands = new CommandGroup<MyContext>()
  .add([sayHi, sayBye]);
```

```ts [say-hi.ts]
import type { MyContext } from "../../types.ts";

export default new Command<MyContext>("sayhi", "Greetings", async (ctx) => {
  await ctx.reply("Hello little User!");
});
```

:::

Did you notice it is possible to register single initialized Commands via the `.add` method into the `CommandGroup` instance or also directly through the `.command(...)` method?
This allows for a one-file-only structure, like in the `admin.ts` file, or a more distributed file structure like in the `group.ts` file.

::: tip Always Use Command Groups
When creating and exporting commands using the `Command` constructor, it's mandatory to register them onto a `CommandGroup` instance via the `.add` method.
On their own they are useless, so make sure you do that at some point.
:::

The plugin also enforce you to have the same Context-type for a given `CommandGroup` and their respective `Commands` so you avoid at first glance that kind of silly mistake!

Combining this knowledge with the following section will get your Command-game to the next level.

## Scoped Commands

Did you know you can allow different commands to be shown on different chats depending on the chat type, the language, and even the user status in a chat group? That's what Telegram calls [**Command Scopes**](https://core.telegram.org/bots/features#command-scopes).

Now, Command Scopes are a cool feature, but using it by hand can get really messy, since it's hard to keep track of all the scopes and what commands they present.
Plus, by using Command Scopes on their own, you have to do manual filtering inside each command to ensure they'll only run for the correct scopes.
Syncing those two things up can be a nightmare, and that's why this plugin exists.
Check how it's done.

The `Command` class returned by the `command` method exposes a method called `addToScope`.
This method takes in a [BotCommandScope](/ref/types/botcommandscope) together with one or more handlers, and registers those handlers to be ran at that specific scope.

You don't even need to worry about calling `filter`, the `addToScope` method will guarantee that your handler only gets called if the context is right.

Here's an example of a scoped command:

```ts
const myCommands = new CommandGroup();

myCommands
  .command("start", "Initializes bot configuration")
  .addToScope(
    { type: "all_private_chats" },
    (ctx) => ctx.reply(`Hello, ${ctx.chat.first_name}!`),
  )
  .addToScope(
    { type: "all_group_chats" },
    (ctx) => ctx.reply(`Hello, members of ${ctx.chat.title}!`),
  );
```

The `start` command can now be called from both private and group chats, and it will give a different response depending on where it gets called from.
Now if you call `myCommands.setCommands`, the `start` command will be registered to both private and group chats.

Here's an example of a command that's only accessible to group admins.

```js
adminCommands
  .command("secret", "Admin only")
  .addToScope(
    { type: "all_chat_administrators" },
    (ctx) => ctx.reply("Free cake!"),
  );
```

And here is an example of a command that's only accessible in groups

```js
myCommands
  .command("fun", "Laugh")
  .addToScope(
    { type: "all_group_chats" },
    (ctx) => ctx.reply("Haha"),
  );
```

Notice that when you call the `command` method, it opens up a new command.
If you give it a handler, that handler will apply to the `default` scope of that command.
Calling `addToScope` on that command will then add a new handler, which will be filtered to that scope.
Take a look at this example.

```ts
myCommands
  .command(
    "default",
    "Default command",
    // This will be called when not on a group chat, or when the user is not an admin
    (ctx) => ctx.reply("Hello from default scope"),
  )
  .addToScope(
    { type: "all_group_chats" },
    // This will only be called for non-admin users in a group
    (ctx) => ctx.reply("Hello, group chat!"),
  )
  .addToScope(
    { type: "all_chat_administrators" },
    // This will be called for group admins, when inside that group
    (ctx) => ctx.reply("Hello, admin!"),
  );
```

## Command Translations

Another powerful feature is the ability to set different names for the same command, and their respective descriptions based on the user language.
The commands plugin makes that easy by providing the `localize` method.
Check it out:

```js
myCommands
  // You need to set a default name and description
  .command("hello", "Say hello")
  // And then you can set the localized ones
  .localize("pt", "ola", "Dizer olá");
```

Add as many as you want! The plugin will take care of registering them for you when you call `myCommands.setCommands`.

For convenience, grammY exports a `LanguageCodes` enum-like object that you can use for a more idiomatic approach:

::: code-group

```ts [TypeScript]
import { LanguageCodes } from "grammy/types";

myCommands.command(
  "chef",
  "Steak delivery",
  (ctx) => ctx.reply("Steak on the plate!"),
)
  .localize(
    LanguageCodes.Spanish,
    "cocinero",
    "Bife a domicilio",
  );
```

```js [JavaScript]
const { LanguageCodes } = require("grammy/types");

myCommands.command(
  "chef",
  "Steak delivery",
  (ctx) => ctx.reply("Steak on the plate!"),
)
  .localize(
    LanguageCodes.Spanish,
    "cocinero",
    "Bife a domicilio",
  );
```

```ts [Deno]
import { LanguageCodes } from "https://deno.land/x/grammy/types.ts";

myCommands.command(
  "chef",
  "Steak delivery",
  (ctx) => ctx.reply("Steak on the plate!"),
)
  .localize(
    LanguageCodes.Spanish,
    "cocinero",
    "Bife a domicilio",
  );
```

:::

### Localizing Commands With the Internationalization Plugin

If you are looking to have your localized command names and descriptions bundle inside your `.ftl` files, you could make use of the following idea:

```ts
function addLocalizations(command: Command) {
  i18n.locales.forEach((locale) => {
    command.localize(
      locale,
      i18n.t(locale, `${command.name}.command`),
      i18n.t(locale, `${command.name}.description`),
    );
  });
  return command;
}

myCommands.commands.forEach(addLocalizations);
```

## Finding the Nearest Command

Even though Telegram is capable of auto completing the registered commands, sometimes users do type them manually and, in some cases, happen to make mistakes.
The commands plugin helps you deal with that by allowing you to suggest a command that might be what the user wanted in the first place.
It is compatible with custom prefixes, so you don't have to worry about that, and its usage is quite straightforward:

::: code-group

```ts [TypeScript]
// Use the flavor to create a custom context
type MyContext = Context & CommandsFlavor;

// Use the new context to instantiate your bot
const bot = new Bot<MyContext>("token");
const myCommands = new CommandGroup<MyContext>();

// ... Register the commands

bot
  // Check if there is a command
  .filter(commandNotFound(myCommands))
  // If so, that means it wasn't handled by any of our commands.
  .use(async (ctx) => {
    if (ctx.commandSuggestion) {
      // We found a potential match
      await ctx.reply(
        `Hmm... I don't know that command. Did you mean ${ctx.commandSuggestion}?`,
      );
      return;
    }
    // Nothing seems to come close to what the user typed
    await ctx.reply("Oops... I don't know that command :/");
  });
```

```js [JavaScript]
// Use the new context to instantiate your bot
const bot = new Bot("token");
const myCommands = new CommandGroup();

// ... Register the commands

bot
  // Check if there is a command
  .filter(commandNotFound(myCommands))
  // If so, that means it wasn't handled by any of our commands.
  .use(async (ctx) => {
    if (ctx.commandSuggestion) {
      // We found a potential match
      await ctx.reply(
        `Hmm... I don't know that command. Did you mean ${ctx.commandSuggestion}?`,
      );
      return;
    }
    // Nothing seems to come close to what the user typed
    await ctx.reply("Oops... I don't know that command :/");
  });
```

:::

Behind the scenes, `commandNotFound` will use the `getNearestCommand` context method which by default will prioritize commands that correspond to the user language.
If you want to opt-out of this behavior, you can pass the `ignoreLocalization` flag set to true.
It is possible to search across multiple CommandGroup instances, and `ctx.commandSuggestion` will be the most similar command, if any, across them all.
It also allows to set the `ignoreCase` flag, which will ignore casing while looking for a similar command and the `similarityThreshold` flag, which controls how similar a command name has to be to the user input for it to be recommended.

The `commandNotFound` function will only trigger for updates which contain command-like text similar to your registered commands.
For example, if you only have registered [commands with a custom prefix](#prefix) like `?`, it will trigger the handler for anything that looks like your commands, e.g: `?sayhi` but not `/definitely_a_command`.
Same goes the other way, if you only have commands with the default prefix, it will only trigger on updates that look like `/regular` `/commands`.

The recommended commands will only come from the `CommandGroup` instances you pass to the function. So you could defer the checks into multiple, separate filters.

Let's use the previous knowledge to inspect the next example:

```ts
const myCommands = new CommandGroup();
myCommands.command("dad", "calls dad", () => {}, { prefix: "?" })
  .localize("es", "papa", "llama a papa")
  .localize("fr", "pere", "appelle papa");

const otherCommands = new CommandGroup();
otherCommands.command("bread", "eat a toast", () => {})
  .localize("es", "pan", "come un pan")
  .localize("fr", "pain", "manger du pain");

// Register each language-specific command group

// Let's assume the user is French and typed /Papi
bot
  // this filter will trigger for any command-like as '/regular' or '?custom'
  .filter(commandNotFound([myCommands, otherCommands], {
    ignoreLocalization: true,
    ignoreCase: true,
  }))
  .use(async (ctx) => {
    ctx.commandSuggestion === "?papa"; // evaluates to true
  });
```

If the `ignoreLocalization` was falsy instead we would have gotten "`ctx.commandSuggestion` equals `/pain`".
We could add more filters like the above, with different parameters or `CommandGroups` to check against.
There are a lot of possibilities!

## Command Options

There are a few options that can be specified per command, per scope, or globally for a `CommandGroup` instance.
These options allow you to further customize how your bot handles commands, giving you more flexibility.

### ignoreCase

By default commands will match the user input in a case-sensitive manner.
Having this flag set, for example, in a command named `/dandy` will match `/DANDY` the same as `/dandY` or any other case-only variation.

### targetedCommands

When users invoke a command, they can optionally tag your bot, like so: `/command@bot_username`.
You can decide what to do with these commands by using the `targetedCommands` config option.
With it you can choose between three different behaviors:

- `ignored`: Ignores commands that mention your bot's user
- `optional`: Handles both commands that do and that don't mention the bot's user
- `required`: Only handles commands that mention the bot's user

### `prefix`

Currently, only commands starting with `/` are recognized by Telegram and, thus, by the [command handling done by the grammY core library](../guide/commands).
In some occasions, you might want to change that and use a custom prefix for your bot.
That is made possible by the `prefix` option, which will tell the commands plugin to look for that prefix when trying to identify a command.

If you ever need to retrieve `botCommand` entities from an update and need them to be hydrated with the custom prefix you have registered, there is a method specifically tailored for that, called `ctx.getCommandEntities(yourCommands)`, which returns the same interface as `ctx.entities('bot_command')`

::: tip
Commands with custom prefixes cannot be shown in the Commands Menu.
:::

### `matchOnlyAtStart`

When [handling commands](../guide/commands), the grammY core library will only recognize commands that start on the first character of a message.
The commands plugin, however, allows you to listen for commands in the middle of the message text, or in the end, it doesn't matter!
All you have to do is set the `matchOnlyAtStart` option to `false`, and the rest will be done by the plugin.

## RegExp Commands

This feature is for those who are really looking to go wild, it allows you to create command handlers based on regular expressions instead of static strings, a basic example would look like:

```ts
myCommands
  .command(
    /delete_([a-zA-Z]+)/,
    (ctx) => ctx.reply(`Deleting ${ctx.msg?.text?.split("_")[1]}`),
  );
```

This command handler will trigger on `/delete_me` the same as in `/delete_you`, and it will reply "Deleting me" in the first case and "Deleting you" in the later, but will not trigger on `/delete_` nor `/delete_123xyz`, passing through as if it wasn't there.

## Plugin Summary

- Name: `commands`
- [Source](https://github.com/grammyjs/commands)
- [Reference](/ref/commands/)
</file>

<file path="site/docs/plugins/console-time.md">
---
prev: false
next: false
---

# Console Logging While Debugging

If you are familiar with JavaScript/TypeScript you probably used [`console.log`](https://developer.mozilla.org/en-US/docs/Web/API/console/log_static) or [`console.time`](https://developer.mozilla.org/en-US/docs/Web/API/console/time_static) to check what is happening while debugging something.
While working on your bot or middleware you might want to check something similar: What happened, and how long took it?

This plugin is interested in individual requests to debug individual problems.
While being in a production environment, you probably want something opposite in order to get a rough overview.
For example: while debugging why `/start` fails you will check the individual Telegram update.
In a production context you are more interested in all `/start` messages that are happening.
This library is intended to help with individual updates.

## Debug Your Implementation

```ts
import { generateUpdateMiddleware } from "telegraf-middleware-console-time";

if (process.env.NODE_ENV !== "production") {
  bot.use(generateUpdateMiddleware());
}

// Your implementation
bot.command("start" /* , ... */);
```

which will output stuff like this:

```text
2020-03-31T14:32:36.974Z 490af message text Edgar 6 /start: 926.247ms
2020-03-31T14:32:57.750Z 490ag message text Edgar 6 /start: 914.764ms
2020-03-31T14:33:01.188Z 490ah message text Edgar 5 /stop: 302.666ms
2020-03-31T14:46:11.385Z 490ai message text Edgar 6 /start: 892.452ms
```

The `490af` is the `update_id`.

The number before the commands is the total length of the content.
This is helpful when considering max length for stuff like callback data.

The content itself is shortened in order to prevent log spamming.

## Debug Your Middleware

When you create your own middleware or assume slow timings of another middleware you can use these middlewares to create a timing profile.

```ts
import {
  generateAfterMiddleware,
  generateBeforeMiddleware,
} from "telegraf-middleware-console-time";

const bot = new Bot("");

// Use BeforeMiddleware before loading the tested middleware.
bot.use(generateBeforeMiddleware("foo"));

// Middleware to be tested
bot.use(); /* ... */

// Use AfterMiddleware after loading the middleware you are testing (with the same label).
bot.use(generateAfterMiddleware("foo"));

// Other middleware/implementations (they will take the "inner" amount of time when used).
bot.use(); /* ... */
bot.on("message" /* ... */);
```

This will output something like this:

```text
490ai foo before: 304.185ms
490ai foo inner: 83.122ms
490ai foo after: 501.028ms
490ai foo total: 891.849ms
```

This indicates the checked middleware alone took 800ms and isn't as performant as maybe needed.

## Plugin Summary

- [Source](https://github.com/EdJoPaTo/telegraf-middleware-console-time)
</file>

<file path="site/docs/plugins/conversations.md">
---
prev: false
next: false
---

# Conversations (`conversations`)

Create powerful conversational interfaces with ease.

## Quickstart

Conversations let you wait for messages.
Use this plugin if your bot has multiple steps.

> Conversations are unique because they introduce a novel concept that you won't find elsewhere in the world.
> They provide an elegant solution, but you will need to read a bit about how they work before you understand what your code actually does.

Here is a quickstart to let you play around with the plugin before we get to the interesting parts.

:::code-group

```ts [TypeScript]
import { Bot, type Context } from "grammy";
import {
  type Conversation,
  type ConversationFlavor,
  conversations,
  createConversation,
} from "@grammyjs/conversations";

const bot = new Bot<ConversationFlavor<Context>>(""); // <-- put your bot token between the "" (https://t.me/BotFather)
bot.use(conversations());

/** Defines the conversation */
async function hello(conversation: Conversation, ctx: Context) {
  await ctx.reply("Hi there! What is your name?");
  const { message } = await conversation.waitFor("message:text");
  await ctx.reply(`Welcome to the chat, ${message.text}!`);
}
bot.use(createConversation(hello));

bot.command("enter", async (ctx) => {
  // Enter the function "hello" you declared.
  await ctx.conversation.enter("hello");
});

bot.start();
```

```js [JavaScript]
const { Bot } = require("grammy");
const { conversations, createConversation } = require(
  "@grammyjs/conversations",
);

const bot = new Bot(""); // <-- put your bot token between the "" (https://t.me/BotFather)
bot.use(conversations());

/** Defines the conversation */
async function hello(conversation, ctx) {
  await ctx.reply("Hi there! What is your name?");
  const { message } = await conversation.waitFor("message:text");
  await ctx.reply(`Welcome to the chat, ${message.text}!`);
}
bot.use(createConversation(hello));

bot.command("enter", async (ctx) => {
  // Enter the function "hello" you declared.
  await ctx.conversation.enter("hello");
});

bot.start();
```

```ts [Deno]
import { Bot, type Context } from "https://deno.land/x/grammy/mod.ts";
import {
  type Conversation,
  type ConversationFlavor,
  conversations,
  createConversation,
} from "https://deno.land/x/grammy_conversations/mod.ts";

const bot = new Bot<ConversationFlavor<Context>>(""); // <-- put your bot token between the "" (https://t.me/BotFather)
bot.use(conversations());

/** Defines the conversation */
async function hello(conversation: Conversation, ctx: Context) {
  await ctx.reply("Hi there! What is your name?");
  const { message } = await conversation.waitFor("message:text");
  await ctx.reply(`Welcome to the chat, ${message.text}!`);
}
bot.use(createConversation(hello));

bot.command("enter", async (ctx) => {
  // Enter the function "hello" you declared.
  await ctx.conversation.enter("hello");
});

bot.start();
```

:::

When you enter the above conversation `hello`, it will send a message, then wait for a text message by the user, and then send another message.
Finally, the conversation completes.

Let's now get to the interesting parts.

## How Conversations Work

Take a look at the following example of traditional message handling.

```ts
bot.on("message", async (ctx) => {
  // handle one message
});
```

In regular message handlers, you only have a single context object at all times.

Compare this with conversations.

```ts
async function hello(conversation: Conversation, ctx0: Context) {
  const ctx1 = await conversation.wait();
  const ctx2 = await conversation.wait();
  // handle three messages
}
```

In this conversation, you have three context objects available!

Like regular handlers, the conversations plugin only receives a single context object from the [middleware system](../guide/middleware).
Now suddenly it makes three context objects available to you.
How is this possible?

**Conversation builder functions are not executed like normal functions**.
(Even though we can program them that way.)

### Conversations Are Replay Engines

Conversation builder functions are not executed like normal functions.

When a conversation is entered, it will only be executed up until the first wait call.
The function is then interrupted and won't be executed any further.
The plugin remembers that the wait call has been reached and stores this information.

When the next update arrives, the conversation will be executed again from the start.
However, this time, none of the API calls are performed, which makes your code run very fast and not have any effects.
This is called a _replay_.
As soon as the previously reached wait call is reached once again, function execution resumes normally.

::: code-group

```ts [Enter]
async function hello( //                      |
  conversation: Conversation, //              |
  ctx0: Context, //                           |
) { //                                        |
  await ctx0.reply("Hi there!"); //           |
  const ctx1 = await conversation.wait(); //  A
  await ctx1.reply("Hello again!"); //
  const ctx2 = await conversation.wait(); //
  await ctx2.reply("Goodbye!"); //
} //
```

```ts [Replay]
async function hello( //                      .
  conversation: Conversation, //              .
  ctx0: Context, //                           .
) { //                                        .
  await ctx0.reply("Hi there!"); //           .
  const ctx1 = await conversation.wait(); //  A
  await ctx1.reply("Hello again!"); //        |
  const ctx2 = await conversation.wait(); //  B
  await ctx2.reply("Goodbye!"); //
} //
```

```ts [Replay 2]
async function hello( //                      .
  conversation: Conversation, //              .
  ctx0: Context, //                           .
) { //                                        .
  await ctx0.reply("Hi there!"); //           .
  const ctx1 = await conversation.wait(); //  A
  await ctx1.reply("Hello again!"); //        .
  const ctx2 = await conversation.wait(); //  B
  await ctx2.reply("Goodbye!"); //            |
} //                                          —
```

:::

1. When the conversation is entered, the function will run until `A`.
2. When the next update arrives, the function will be replayed until `A`, and run normally from `A` until `B`.
3. When the last update arrives, the function will be replayed until `B`, and run normally until the end.

This means that each line of code you write will be executed many times---once normally, and many more times during replays.
As a result, you have to make sure that your code behaves the same way during replays as it did when it was first executed.

If you perform any API calls via `ctx.api` (including `ctx.reply`), the plugin takes care of them automatically.
In contrast, your own database communication needs special treatment.

This is done as follows.

### The Golden Rule of Conversations

Now that [we know how conversations are executed](#conversations-are-replay-engines), we can define one rule that applies to the code you write inside a conversation builder function.
You must follow it if you want your code to behave correctly.

::: warning THE GOLDEN RULE

**Code behaving differently between replays must be wrapped in [`conversation.external`](/ref/conversations/conversation#external).**

:::

This is how to apply it:

```ts
// BAD
const response = await accessDatabase();
// GOOD
const response = await conversation.external(() => accessDatabase());
```

Escaping a part of your code via [`conversation.external`](/ref/conversations/conversation#external) signals to the plugin that this part of the code should be skipped during replays.
The return value of the wrapped code is stored by the plugin and reused during subsequent replays.
In the above example, this prevents repeated database access.

USE `conversation.external` when you ...

- read or write to files, databases/sessions, the network, or global state,
- call `Math.random()` or `Date.now()`,
- perform API calls on `bot.api` or other independent instances of `Api`.

DO NOT USE `conversation.external` when you ...

- call `ctx.reply` or other [context actions](../guide/context#available-actions),
- call `ctx.api.sendMessage` or other methods of the [Bot API](https://core.telegram.org/bots/api) via `ctx.api`.

The conversations plugin provides a few convenience methods around `conversation.external`.
This not only simplifies using `Math.random()` and `Date.now()`, but it also simplifies debugging by providing a way to suppress logs during a replay.

```ts
// await conversation.external(() => Math.random());
const rnd = await conversation.random();
// await conversation.external(() => Date.now());
const now = await conversation.now();
// await conversation.external(() => console.log("abc"));
await conversation.log("abc");
```

How can `conversation.wait` and `conversation.external` recover the original values when a replay happens?
The plugin has to somehow remember this data, right?

Yes.

### Conversations Store State

Two types of data are being stored in a database.
By default, it uses a lightweight in-memory database that is based on a `Map`, but you can [use a persistent database](#persisting-conversations) easily.

1. The conversations plugin stores all updates.
2. The conversations plugin stores all return values of `conversation.external` and the results of all API calls.

This is not an issue if you only have a few dozen updates in a conversation.
(Remember that during long polling, every call to `getUpdates` retrieves up to 100 updates, too.)

However, if your conversation never exits, this data will accumulate and slow down your bot.
**Avoid infinite loops.**

### Conversational Context Objects

When a conversation is executed, it uses the persisted updates to generate new context objects from scratch.
**These context objects are different from the context object in the surrounding middleware.**
For TypeScript code, this also means that you now have two [flavors](../guide/context#context-flavors) of context objects.

- **Outside context objects** are the context objects that your bot uses in middleware.
  They give you access to `ctx.conversation.enter`.
  For TypeScript, they will at least have `ConversationFlavor` installed.
  Outside context objects will also have other properties defined by plugins that you installed via `bot.use`.
- **Inside context objects** (also called **conversational context objects**) are the context objects created by the conversations plugin.
  They can never have access to `ctx.conversation.enter`, and by default, they also don't have access to any plugins.
  If you want to have custom properties on inside context objects, [scroll down](#using-plugins-inside-conversations).

You have to pass both the outside and the inside context types to the conversation.
The TypeScript setup therefore typically looks as follows:

::: code-group

```ts [Node.js]
import { Bot, type Context } from "grammy";
import {
  type Conversation,
  type ConversationFlavor,
} from "@grammyjs/conversations";

// Outside context objects (knows all middleware plugins)
type MyContext = ConversationFlavor<Context>;
// Inside context objects (knows all conversation plugins)
type MyConversationContext = Context;

// Use the outside context type for your bot.
const bot = new Bot<MyContext>(""); // <-- put your bot token between the "" (https://t.me/BotFather)

// Use both the outside and the inside type for your conversation.
type MyConversation = Conversation<MyContext, MyConversationContext>;

// Define your conversation.
async function example(
  conversation: MyConversation,
  ctx0: MyConversationContext,
) {
  // All context objects inside the conversation are
  // of type `MyConversationContext`.
  const ctx1 = await conversation.wait();

  // The outside context object can be accessed
  // via `conversation.external` and it is inferred to be
  // of type `MyContext`.
  const session = await conversation.external((ctx) => ctx.session);
}
```

```ts [Deno]
import { Bot, type Context } from "https://deno.land/x/grammy/mod.ts";
import {
  type Conversation,
  type ConversationFlavor,
} from "https://deno.land/x/grammy_conversations/mod.ts";

// Outside context objects (knows all middleware plugins)
type MyContext = ConversationFlavor<Context>;
// Inside context objects (knows all conversation plugins)
type MyConversationContext = Context;

// Use the outside context type for your bot.
const bot = new Bot<MyContext>(""); // <-- put your bot token between the "" (https://t.me/BotFather)

// Use both the outside and the inside type for your conversation.
type MyConversation = Conversation<MyContext, MyConversationContext>;

// Define your conversation.
async function example(
  conversation: MyConversation,
  ctx0: MyConversationContext,
) {
  // All context objects inside the conversation are
  // of type `MyConversationContext`.
  const ctx1 = await conversation.wait();

  // The outside context object can be accessed
  // via `conversation.external` and it is inferred to be
  // of type `MyContext`.
  const session = await conversation.external((ctx) => ctx.session);
}
```

:::

> In the above example, there are no plugins installed in the conversation.
> As soon as you start [installing](#using-plugins-inside-conversations) them, the definition of `MyConversationContext` will no longer be the bare type `Context`.

Naturally, if you have several conversations and you want the context types to differ between them, you can define several conversational context types.

Congrats!
If you have understood all of the above, the hard parts are over.
The rest of the page is about the wealth of features that this plugin provides.

## Entering Conversations

Conversations can be entered from a normal handler.

By default, a conversation has the same name as the [name](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) of the function.
Optionally, you can rename it when installing it on your bot.

Optionally, you can pass arguments to the conversation.
Note that the arguments will be stored as a JSON string, so you need to make sure they can be safely passed to `JSON.stringify`.

Conversations can also be entered from within other conversations by doing a normal JavaScript function call.
In that case, they get access to a potential return value of the called conversation.
This isn't available when you enter a conversation from inside middleware.

:::code-group

```ts [TypeScript]
/**
 * Returns the answer to life, the universe, and everything.
 * This value is only accessible when the conversation
 * is called from another conversation.
 */
async function convo(conversation: Conversation, ctx: Context) {
  await ctx.reply("Computing answer");
  return 42;
}
/** Accepts two arguments (must be JSON-serializable) */
async function args(
  conversation: Conversation,
  ctx: Context,
  answer: number,
  config: { text: string },
) {
  const truth = await convo(conversation, ctx);
  if (answer === truth) {
    await ctx.reply(config.text);
  }
}
bot.use(createConversation(convo, "new-name"));
bot.use(createConversation(args));

bot.command("enter", async (ctx) => {
  await ctx.conversation.enter("new-name");
});
bot.command("enter_with_arguments", async (ctx) => {
  await ctx.conversation.enter("args", 42, { text: "foo" });
});
```

```js [JavaScript]
/**
 * Returns the answer to life, the universe, and everything.
 * This value is only accessible when the conversation
 * is called from another conversation.
 */
async function convo(conversation, ctx) {
  await ctx.reply("Computing answer");
  return 42;
}
/** Accepts two arguments (must be JSON-serializable) */
async function args(conversation, ctx, answer, config) {
  const truth = await convo(conversation, ctx);
  if (answer === truth) {
    await ctx.reply(config.text);
  }
}
bot.use(createConversation(convo, "new-name"));
bot.use(createConversation(args));

bot.command("enter", async (ctx) => {
  await ctx.conversation.enter("new-name");
});
bot.command("enter_with_arguments", async (ctx) => {
  await ctx.conversation.enter("args", 42, { text: "foo" });
});
```

:::

::: warning Missing Type Safety for Arguments

Double-check that you used the right type annotations for the parameters of your conversation, and that you passed matching arguments to it in your `enter` call.
The plugin is not able to check any types beyond `conversation` and `ctx`.

:::

Remember that [the order of your middleware matters](../guide/middleware).
You can only enter conversations that have been installed prior to the handler that calls `enter`.

## Waiting for Updates

The most basic kind of wait call just waits for any update.

```ts
const ctx = await conversation.wait();
```

It simply returns a context object.
All other wait calls are based on this.

### Filtered Wait Calls

If you want to wait for a specific type of update, you can use a filtered wait call.

```ts
// Match a filter query like with `bot.on`.
const message = await conversation.waitFor("message");
// Wait for text like with `bot.hears`.
const hears = await conversation.waitForHears(/regex/);
// Wait for commands like with `bot.command`.
const start = await conversation.waitForCommand("start");
// etc
```

Take a look at the API reference to see [all the available ways to filter wait calls](/ref/conversations/conversation#wait).

Filtered wait calls are guaranteed to return only update that match the respective filter.
If the bot receives an update that does not match, it will be dropped.
You can pass a callback function that will be invoked in this case.

```ts
const message = await conversation.waitFor(":photo", {
  otherwise: (ctx) => ctx.reply("Please send a photo!"),
});
```

All filtered wait calls can be chained to filter for several things at once.

```ts
// Wait for a photo with a specific caption
let photoWithCaption = await conversation.waitFor(":photo")
  .andForHears("XY");
// Handle each case with a different otherwise function:
photoWithCaption = await conversation
  .waitFor(":photo", { otherwise: (ctx) => ctx.reply("No photo") })
  .andForHears("XY", { otherwise: (ctx) => ctx.reply("Bad caption") });
```

If you only specify `otherwise` in one of the chained wait calls, then it will only be invoked if that specific filter drops the update.

### Inspecting Context Objects

It is very common to [destructure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) the received context objects.
You can then perform further checks on the received data.

```ts
const { message } = await conversation.waitFor("message");
if (message.photo) {
  // Handle photo message
}
```

Conversations are also an ideal place to use [has checks](../guide/context#probing-via-has-checks).

## Exiting Conversations

The easiest way to exit a conversation is to return from it.
Throwing an error also terminates the conversation.

If this is not enough, you can manually halt the conversation at any moment.

```ts
async function convo(conversation: Conversation, ctx: Context) {
  // All branches exit the conversation:
  if (ctx.message?.text === "return") {
    return;
  } else if (ctx.message?.text === "error") {
    throw new Error("boom");
  } else {
    await conversation.halt(); // never returns
  }
}
```

You can also exit a conversation from your middleware.

```ts
bot.use(conversations());
bot.command("clean", async (ctx) => {
  await ctx.conversation.exit("convo");
});
```

You can even do this _before_ the targeted conversation is installed on your middleware system.
It is enough to have the conversations plugin itself installed.

## It's Just JavaScript

With [side-effects out of the way](#the-golden-rule-of-conversations), conversations are just regular JavaScript functions.
They might be executed in weird ways, but when developing a bot, you can usually forget this.
All the regular JavaScript syntax just works.

Most the things in this section are obvious if you have used conversations for some time.
However, if you are new, some of these things could surprise you.

### Variables, Branching, and Loops

You can use normal variables to store state between updates.
You can use branching with `if` or `switch`.
Loops via `for` and `while` work, too.

```ts
await ctx.reply("Send me your favorite numbers, separated by commas!");
const { message } = await conversation.waitFor("message:text");
const numbers = message.text.split(",");
let sum = 0;
for (const str of numbers) {
  const n = parseInt(str.trim(), 10);
  if (!isNaN(n)) {
    sum += n;
  }
}
await ctx.reply("The sum of these numbers is: " + sum);
```

It's just JavaScript.

### Functions and Recursion

You can split a conversation into multiple functions.
They can call each other and even do recursion.
(In fact, the plugin does not even know that you used functions.)

Here is the same code as above, refactored to functions.

:::code-group

```ts [TypeScript]
/** A conversation to add numbers */
async function sumConvo(conversation: Conversation, ctx: Context) {
  await ctx.reply("Send me your favorite numbers, separated by commas!");
  const { message } = await conversation.waitFor("message:text");
  const numbers = message.text.split(",");
  await ctx.reply("The sum of these numbers is: " + sumStrings(numbers));
}

/** Converts all given strings to numbers and adds them up */
function sumStrings(numbers: string[]): number {
  let sum = 0;
  for (const str of numbers) {
    const n = parseInt(str.trim(), 10);
    if (!isNaN(n)) {
      sum += n;
    }
  }
  return sum;
}
```

```js [JavaScript]
/** A conversation to add numbers */
async function sumConvo(conversation, ctx) {
  await ctx.reply("Send me your favorite numbers, separated by commas!");
  const { message } = await conversation.waitFor("message:text");
  const numbers = message.text.split(",");
  await ctx.reply("The sum of these numbers is: " + sumStrings(numbers));
}

/** Converts all given strings to numbers and adds them up */
function sumStrings(numbers) {
  let sum = 0;
  for (const str of numbers) {
    const n = parseInt(str.trim(), 10);
    if (!isNaN(n)) {
      sum += n;
    }
  }
  return sum;
}
```

:::

It's just JavaScript.

### Modules and Classes

JavaScript has higher-order functions, classes, and other ways of structuring your code into modules.
Naturally, all of them can be turned into conversations.

Here is the above code once again, refactored to a module with simple dependency injection.

::: code-group

```ts [TypeScript]
/**
 * A module that can ask the user for numbers, and that
 * provides a way to add up numbers sent by the user.
 *
 * Requires a conversation handle to be injected.
 */
function sumModule(conversation: Conversation) {
  /** Converts all given strings to numbers and adds them up */
  function sumStrings(numbers) {
    let sum = 0;
    for (const str of numbers) {
      const n = parseInt(str.trim(), 10);
      if (!isNaN(n)) {
        sum += n;
      }
    }
    return sum;
  }

  /** Asks the user for numbers */
  async function askForNumbers(ctx: Context) {
    await ctx.reply("Send me your favorite numbers, separated by commas!");
  }

  /** Waits for the user to send numbers, and replies with their sum */
  async function sumUserNumbers() {
    const ctx = await conversation.waitFor(":text");
    const sum = sumStrings(ctx.msg.text);
    await ctx.reply("The sum of these numbers is: " + sum);
  }

  return { askForNumbers, sumUserNumbers };
}

/** A conversation to add numbers */
async function sumConvo(conversation: Conversation, ctx: Context) {
  const mod = sumModule(conversation);
  await mod.askForNumbers(ctx);
  await mod.sumUserNumbers();
}
```

```js [JavaScript]
/**
 * A module that can ask the user for numbers, and that
 * provides a way to add up numbers sent by the user.
 *
 * Requires a conversation handle to be injected.
 */
function sumModule(conversation: Conversation) {
  /** Converts all given strings to numbers and adds them up */
  function sumStrings(numbers) {
    let sum = 0;
    for (const str of numbers) {
      const n = parseInt(str.trim(), 10);
      if (!isNaN(n)) {
        sum += n;
      }
    }
    return sum;
  }

  /** Asks the user for numbers */
  async function askForNumbers(ctx: Context) {
    await ctx.reply("Send me your favorite numbers, separated by commas!");
  }

  /** Waits for the user to send numbers, and replies with their sum */
  async function sumUserNumbers() {
    const ctx = await conversation.waitFor(":text");
    const sum = sumStrings(ctx.msg.text);
    await ctx.reply("The sum of these numbers is: " + sum);
  }

  return { askForNumbers, sumUserNumbers };
}

/** A conversation to add numbers */
async function sumConvo(conversation: Conversation, ctx: Context) {
  const mod = sumModule(conversation);
  await mod.askForNumbers(ctx);
  await mod.sumUserNumbers();
}
```

:::

This is clearly overkill for such a simple task as adding up a few numbers.
However, it illustrates a broader point.

You guessed it:
It's just JavaScript.

## Persisting Conversations

By default, all data stored by the conversations plugin is kept in memory.
This means that when your process dies, all conversations are exited and will have to be restarted.

If you want to persist the data across server restarts, you need to connect the conversations plugin to a database.
We have built [a lot of different storage adapters](https://github.com/grammyjs/storages/tree/main/packages#grammy-storages) to make this simple.
(They are the same adapters that the [session plugin uses](./session#known-storage-adapters).)

Let's say you want to store data on disk in a directory called `convo-data`.
This means that you need the [`FileAdapter`](https://github.com/grammyjs/storages/tree/main/packages/file#installation).

::: code-group

```ts [Node.js]
import { FileAdapter } from "@grammyjs/storage-file";

bot.use(conversations({
  storage: new FileAdapter({ dirName: "convo-data" }),
}));
```

```ts [Deno]
import { FileAdapter } from "https://deno.land/x/grammy_storages/file/src/mod.ts";

bot.use(conversations({
  storage: new FileAdapter({ dirName: "convo-data" }),
}));
```

:::

Done!

You can use any storage adapter that is able to store data of type [`VersionedState`](/ref/conversations/versionedstate) of [`ConversationData`](/ref/conversations/conversationdata).
Both types can be imported from the conversations plugin.
In other words, if you want to extract the storage to a variable, you can use the following type annotation.

```ts
const storage = new FileAdapter<VersionedState<ConversationData>>({
  dirName: "convo-data",
});
```

Naturally, the same types can be used with any other storage adapter.

### Versioning Data

If you persist the state of the conversation in a database and then update the source code, there is a mismatch between the stored data and the conversation builder function.
This is a form of data corruption and will break the replay.

You can prevent this by specifying a version of your code.
Every time you change your conversation, you can increment the version.
The conversations plugin will then detect a version mismatch and migrate all data automatically.

```ts
bot.use(conversations({
  storage: {
    type: "key",
    version: 42, // can be number or string
    adapter: storageAdapter,
  },
}));
```

If you do not specify a version, it defaults to `0`.

::: tip Forgot to Change the Version? Don't Worry!

The conversations plugin already has good protections in place that should catch most cases of data corruption.
If this is detected, an error is thrown somewhere inside the conversation, which causes the conversation to crash.
Assuming that you don't catch and suppress that error, the conversation will therefore wipe the bad data and restart correctly.

That being said, this protection does not cover 100 % of the cases, so you should definitely make sure to update the version number in the future.

:::

### Non-serializable Data

[Remember](#conversations-store-state) that all data returned from [`conversation.external`](/ref/conversations/conversation#external) will be stored.
This means that all data returned from `conversation.external` must be serializable.

If you want to return data that cannot be serialized, such as classes or [`BigInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt), you can provide a custom serializer to fix this.

```ts
const largeNumber = await conversation.external({
  // Call an API that returns a BigInt (cannot be converted to JSON).
  task: () => 1000n ** 1000n,
  // Convert bigint to string for storage.
  beforeStore: (n) => String(n),
  // Convert string back to bigint for usage.
  afterLoad: (str) => BigInt(str),
});
```

If you want to throw an error from the task, you can specify additional serialization functions for error objects.
Check out [`ExternalOp`](/ref/conversations/externalop) in the API reference.

### Storage Keys

By default, conversation data is stored per chat.
This is identical to [how the session plugin works](./session#session-keys).

As a result, a conversation cannot handle updates from multiple chats.
If this is desired, you can [define your own storage key function](/ref/conversations/conversationoptions#storage).
As with sessions, it is [not recommended](./session#session-keys) to use this option in serverless environments due to potential race conditions.

Also, just like with sessions, you can store your conversations data under a namespace using the `prefix` option.
This is especially useful if you want to use the same storage adapter for both your session data and your conversations data.
Storing the data in namespaces will prevent it from clashing.

You can specify both options as follows.

```ts
bot.use(conversations({
  storage: {
    type: "key",
    adapter: storageAdapter,
    getStorageKey: (ctx) => ctx.from?.id.toString(),
    prefix: "convo-",
  },
}));
```

If a conversation is entered for a user with user identifier `424242`, the storage key will now be `convo-424242`.

Check out the API reference for [`ConversationStorage`](/ref/conversations/conversationstorage) to see more details about storing data with the conversations plugin.
Among other things, it will explain how to store data without a storage key function at all using `type: "context"`.

## Using Plugins Inside Conversations

[Remember](#conversational-context-objects) that the context objects inside conversations are independent from the context objects in the surrounding middleware.
This means that they will have no plugins installed on them by default---even if the plugins are installed on your bot.

Fortunately, all grammY plugins [except sessions](#accessing-sessions-inside-conversations) are compatible with conversations.
For example, this is how you can install the [hydrate plugin](./hydrate) for a conversation.

::: code-group

```ts [TypeScript]
// Only install the conversations plugin outside.
type MyContext = ConversationFlavor<Context>;
// Only install the hydrate plugin inside.
type MyConversationContext = HydrateFlavor<Context>;

bot.use(conversations());

// Pass the outside and the inside context object.
type MyConversation = Conversation<MyContext, MyConversationContext>;
async function convo(conversation: MyConversation, ctx: MyConversationContext) {
  // The hydrate plugin is installed on the parameter `ctx` here.
  const other = await conversation.wait();
  // The hydrate plugin is installed on the variable `other` here, too.
}
bot.use(createConversation(convo, { plugins: [hydrate()] }));

bot.command("enter", async (ctx) => {
  // The hydrate plugin is NOT installed on `ctx` here.
  await ctx.conversation.enter("convo");
});
```

```js [JavaScript]
bot.use(conversations());

async function convo(conversation, ctx) {
  // The hydrate plugin is installed on `ctx` here.
  const other = await conversation.wait();
  // The hydrate plugin is installed on `other` here, too.
}
bot.use(createConversation(convo, { plugins: [hydrate()] }));

bot.command("enter", async (ctx) => {
  // The hydrate plugin is NOT installed on `ctx` here.
  await ctx.conversation.enter("convo");
});
```

:::

In regular [middleware](../guide/middleware), plugins get to run some code on the current context object, then call `next` to wait for downstream middleware, and then they get to run some code again.

Conversations are not middleware, and plugins cannot interact with conversations in the same way as with middleware.
When a [context object is created](#conversational-context-objects) by the conversation, it will be passed to the plugins which can process it normally.
To the plugins, it will look like only the plugins are installed and no downstream handlers exist.
After all plugins are done, the context object is made available to the conversation.

As a result, any cleanup work done by plugins is performed before the conversation builder function runs.
All plugins except sessions work well with this.
If you want to use sessions, [scroll down](#accessing-sessions-inside-conversations).

### Default Plugins

If you have a lot of conversations that all need the same set of plugins, you can define default plugins.
Now, you no longer have to pass `hydrate` to `createConversation`.

::: code-group

```ts [TypeScript]
// TypeScript needs some help with the two context types
// so you often have to specify them to use plugins.
bot.use(conversations<MyContext, MyConversationContext>({
  plugins: [hydrate()],
}));
// The following conversation will have hydrate installed.
bot.use(createConversation(convo));
```

```js [JavaScript]
bot.use(conversations({
  plugins: [hydrate()],
}));
// The following conversation will have hydrate installed.
bot.use(createConversation(convo));
```

:::

Make sure to install the context flavors of all default plugins on the inside context types of all conversations.

### Using Transformer Plugins Inside Conversations

If you install a plugin via `bot.api.config.use`, then you cannot pass it to the `plugins` array directly.
Instead, you have to install it on the `Api` instance of each context object.
This is done easily from inside a regular middleware plugin.

```ts
bot.use(createConversation(convo, {
  plugins: [async (ctx, next) => {
    ctx.api.config.use(transformer);
    await next();
  }],
}));
```

Replace `transformer` by whichever plugin you want to install.
You can install several transformers in the same call to `ctx.api.config.use`.

### Accessing Sessions Inside Conversations

Due to the way [how plugins work inside conversations](#using-plugins-inside-conversations), the [session plugin](./session) cannot be installed inside a conversation in the same way as other plugins.
You cannot pass it to the `plugins` array because it would:

1. read data,
2. call `next` (which resolves immediately),
3. write back the exact same data, and
4. hand over the context to the conversation.

Note how the session gets saved before you change it.
This means that all changes to the session data get lost.

Instead, you can use `conversation.external` to get [access to the outside context object](#conversational-context-objects).
It has the session plugin installed.

```ts
// Read session data inside a conversation.
const session = await conversation.external((ctx) => ctx.session);

// Change the session data inside a conversation.
session.count += 1;

// Save session data inside a conversation.
await conversation.external((ctx) => {
  ctx.session = session;
});
```

In a sense, using the session plugin can be seen as a way of performing side-effects.
After all, sessions access a database.
Given that we must follow [The Golden Rule](#the-golden-rule-of-conversations), it only makes sense that session access needs to be wrapped inside `conversation.external`.

## Conversational Menus

You can define a menu with the [menu plugin](./menu) outside a conversation, and then pass it to the `plugins` array [like any other plugin](#using-plugins-inside-conversations).

However, this means that the menu does not have access to the conversation handle `conversation` in its button handlers.
As a result, you cannot wait for updates from inside a menu.

Ideally, when a button is clicked, it should be possible to wait for a message by the user, and then perform menu navigation when the user replies.
This is made possible by `conversation.menu()`.
It lets you define _conversational menus_.

```ts
let email = "";

const emailMenu = conversation.menu()
  .text("Get current email", (ctx) => ctx.reply(email || "empty"))
  .text(() => email ? "Change email" : "Set email", async (ctx) => {
    await ctx.reply("What is your email?");
    const response = await conversation.waitFor(":text");
    email = response.msg.text;
    await ctx.reply(`Your email is ${email}!`);
    ctx.menu.update();
  })
  .row()
  .url("About", "https://grammy.dev");

const otherMenu = conversation.menu()
  .submenu("Go to email menu", emailMenu, async (ctx) => {
    await ctx.reply("Navigating");
  });

await ctx.reply("Here is your menu", {
  reply_markup: otherMenu,
});
```

`conversation.menu()` returns a menu that can be built up by adding buttons the same way the menu plugin does.
If fact, if you look at [`ConversationMenuRange`](/ref/conversations/conversationmenurange) in the API reference, you will find it to be very similar to [`MenuRange`](/ref/menu/menurange) from the menu plugin.

Conversational menus stay active only as long as the conversation active.
You should call `ctx.menu.close()` for all menus before exiting the conversation.

If you want to prevent the conversation from exiting, you can simply use the following code snippet at the end of your conversation.
However, [remember](#conversations-store-state) that is it a bad idea to let your conversation live forever.

```ts
// Wait forever.
await conversation.waitUntil(() => false, {
  otherwise: (ctx) => ctx.reply("Please use the menu above!"),
});
```

Finally, note that conversational menus are guaranteed to never interfere with outside menus.
In other words, an outside menu will never handle the update of a menu inside a conversation, and vice-versa.

### Menu Plugin Interoperability

When you define a menu outside a conversation and use it to enter a conversation, you can define a conversational menu that takes over as long as the conversation is active.
When the conversation completes, the outside menu will take control again.

You first have to give the same menu identifier to both menus.

```ts
// Outside conversation (menu plugin):
const menu = new Menu("my-menu");
// Inside conversation (conversations plugin):
const menu = conversation.menu("my-menu");
```

In order for this to work, you must ensure that both menus have the exact same structure when you transition the control in or out of the conversation.
Otherwise, when a button is clicked, the menu will be [detected as outdated](./menu#outdated-menus-and-fingerprints), and the button handler will not be called.

The structure is based on the following two things.

- The shape of the menu (number of rows, or number of buttons in any row).
- The label on the button.

It is usually advisable to first edit the menu to a shape that makes sense inside the conversation as soon as you enter the conversation.
The conversation can then define a matching menu which will be active immediately.

Similarly, if the conversation leaves behind any menus (by not closing them), outside menus can take over control again.
Again, the structure of the menus has to match.

An example of this interoperability can be found in the [example bots repository](https://github.com/grammyjs/examples?tab=readme-ov-file#menus-with-conversation-menu-with-conversation).

## Conversational Forms

Oftentimes, conversations are used to build forms in the chat interface.

All wait calls return context objects.
However, when you wait for a text message, you may only want to get the message text and not interact with the rest of the context object.

Conversation forms give you a way to combine update validation with extracting data from the context object.
This resembles a field in a form.
Consider the following example.

```ts
await ctx.reply("Please send a photo for me to scale down!");
const photo = await conversation.form.photo();
await ctx.reply("What should be the new width of the photo?");
const width = await conversation.form.int();
await ctx.reply("What should be the new height of the photo?");
const height = await conversation.form.int();
await ctx.reply(`Scaling your photo to ${width}x${height} ...`);
const scaled = await scaleImage(photo, width, height);
await ctx.replyWithPhoto(scaled);
```

There are many more form fields available.
Check out [`ConversationForm`](/ref/conversations/conversationform#methods) in the API reference.

All form fields take an `otherwise` function that will run when a non-matching update is received.
In addition, they all take an `action` function that will run when the form field has been filled correctly.

```ts
// Wait for a basic calculation operation.
const op = await conversation.form.select(["+", "-", "*", "/"], {
  action: (ctx) => ctx.deleteMessage(),
  otherwise: (ctx) => ctx.reply("Expected +, -, *, or /!"),
});
```

Conversational forms even allow you to build custom form fields via [`conversation.form.build`](/ref/conversations/conversationform#build).

## Wait Timeouts

Every time you wait for an update, you can pass a timeout value.

```ts
// Only wait for one hour before exiting the conversation.
const oneHourInMilliseconds = 60 * 60 * 1000;
await conversation.wait({ maxMilliseconds: oneHourInMilliseconds });
```

When the wait call is reached, [`conversation.now()`](#the-golden-rule-of-conversations) is called.

As soon as the next update arrives, `conversation.now()` is called again.
If the update took more than `maxMilliseconds` to arrive, the conversation is halted, and the update is returned to the middleware system.
Any downstream middleware will be called.

This will make it look like the conversation was not active anymore at the time the update arrived.

Note that this will not actually run any code after exactly the specified time.
Instead, the code is only run as soon as the next update arrives.

You can specify a default timeout value for all wait calls inside a conversation.

```ts
// Always wait for one hour only.
const oneHourInMilliseconds = 60 * 60 * 1000;
bot.use(createConversation(convo, {
  maxMillisecondsToWait: oneHourInMilliseconds,
}));
```

Passing a value to a wait call directly will override this default.

## Enter and Exit Events

You can specify a callback function that is invoked whenever a conversation is entered.
Similarly, you can specify a callback function that is invoked whenever a conversation is exited.

```ts
bot.use(conversations({
  onEnter(id, ctx) {
    // Entered conversation `id`.
  },
  onExit(id, ctx) {
    // Exited conversation `id`.
  },
}));
```

Each callback receives two values.
The first value is the identifier of the conversation that was entered or exited.
The second value is the current context object of the surrounding middleware.

Note that the callbacks are only called when a conversation is entered or exited via `ctx.conversation`.
The `onExit` callback is also invoked when the conversation terminates itself via `conversation.halt` or when it [times out](#wait-timeouts).

## Concurrent Wait Calls

You can use floating promises to wait for several things concurrently.
When a new update arrives, only the first matching wait call will resolve.

```ts
await ctx.reply("Send a photo and a caption!");
const [textContext, photoContext] = await Promise.all([
  conversation.waitFor(":text"),
  conversation.waitFor(":photo"),
]);
await ctx.replyWithPhoto(photoContext.msg.photo.at(-1).file_id, {
  caption: textContext.msg.text,
});
```

In the above example, it does not matter if the user sends a photo or text first.
Both promises will resolve in the order the user picks to send the two messages the code is waiting for.
[`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all) works normally, it only resolves when all passed promises resolve.

This can be used to wait for unrelated things, too.
For example, here is how you install a global exit listener inside the conversation.

```ts
conversation.waitForCommand("exit") // no await!
  .then(() => conversation.halt());
```

As soon as the conversation [finishes in any way](#exiting-conversations), all pending wait calls will be discarded.
For example, the following conversation will complete immediately after it was entered, without ever waiting for any updates.

::: code-group

```ts [TypeScript]
async function convo(conversation: Conversation, ctx: Context) {
  const _promise = conversation.wait() // no await!
    .then(() => ctx.reply("I will never be sent!"));

  // Conversation is done immediately after being entered.
}
```

```js [JavaScript]
async function convo(conversation, ctx) {
  const _promise = conversation.wait() // no await!
    .then(() => ctx.reply("I will never be sent!"));

  // Conversation is done immediately after being entered.
}
```

:::

Internally, when several wait calls are reached at the same time, the conversations plugin will keep track of a list of wait calls.
As soon as the next update arrives, it will then replay the conversation builder function once for each encountered wait call until one of them accepts the update.
Only if none of the pending wait calls accepts the update, the update will be dropped.

## Checkpoints and Going Back in Time

The conversations plugin [tracks](#conversations-are-replay-engines) the execution of your conversations builder function.

This allows you to create a checkpoint along the way.
A checkpoint contains information about how far the function has run so far.
It can be used to later jump back to this point.

Naturally, any actions performed in the meantime will not be undone.
In particular, rewinding to a checkpoint will not magically unsend any messages.

```ts
const checkpoint = conversation.checkpoint();

// Later:
if (ctx.hasCommand("reset")) {
  await conversation.rewind(checkpoint); // never returns
}
```

Checkpoints can be very useful to "go back."
However, like JavaScript's `break` and `continue` with [labels](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label), jumping around can make the code less readable.
**Make sure not to overuse this feature.**

Internally, rewinding a conversation aborts execution like a wait call does, and then replays the function only until the point where the checkpoint was created.
Rewinding a conversation does not literally execute functions in reverse, even though it feels like that.

## Parallel Conversations

Conversations in unrelated chats are fully independent and can always run in parallel.

However, by default, each chat can only have a single active conversation at all times.
If you try to enter a conversation while a conversation is already active, the `enter` call will throw an error.

You can change this behavior by marking a conversation as parallel.

```ts
bot.use(createConversation(convo, { parallel: true }));
```

This changes two things.

Firstly, you can now enter this conversation even when the same or a different conversation is already active.
For example, if you have the conversations `captcha` and `settings`, you can have `captcha` active five times and `settings` active twelve times---all in the same chat.

Secondly, when a conversation does not accept an update, the update is no longer dropped by default.
Instead, control is handed back to the middleware system.

All installed conversations will get a chance to handle an incoming update until one of them accepts it.
However, only a single conversation will be able to actually handle the update.

When multiple different conversations are active at the same time, the middleware order will determine which conversation gets to handle the update first.
When a single conversation is active multiple times, the oldest conversation (the one that was entered first) gets to handle the update first.

This is best illustrated by an example.

::: code-group

```ts [TypeScript]
async function captcha(conversation: Conversation, ctx: Context) {
  const user = ctx.from!.id;
  await ctx.reply("Welcome to the chat! What is the best bot framework?");
  const answer = await conversation.waitFor(":text").andFrom(user);
  if (answer.msg.text === "grammY") {
    await ctx.reply("Correct! Your future is bright!");
  } else {
    await ctx.banAuthor();
  }
}

async function settings(conversation: Conversation, ctx: Context) {
  const user = ctx.from!.id;
  const main = conversation.checkpoint();
  const options = ["Chat Settings", "About", "Privacy"];
  await ctx.reply("Welcome to the settings!", {
    reply_markup: Keyboard.from(options
      .map((btn) => [Keyboard.text(btn)])),
  });
  const option = await conversation.waitFor(":text")
    .andFrom(user)
    .and((ctx) => options.includes(ctx.msg.text), {
      otherwise: (ctx) => ctx.reply("Please use the buttons!"),
    });
  await openSettingsMenu(option, main);
}

bot.use(createConversation(captcha));
bot.use(createConversation(settings));
```

```js [JavaScript]
async function captcha(conversation, ctx) {
  const user = ctx.from.id;
  await ctx.reply("Welcome to the chat! What is the best bot framework?");
  const answer = await conversation.waitFor(":text").andFrom(user);
  if (answer.msg.text === "grammY") {
    await ctx.reply("Correct! Your future is bright!");
  } else {
    await ctx.banAuthor();
  }
}

async function settings(conversation, ctx) {
  const user = ctx.from.id;
  const main = conversation.checkpoint();
  const options = ["Chat Settings", "About", "Privacy"];
  await ctx.reply("Welcome to the settings!", {
    reply_markup: Keyboard.from(options
      .map((btn) => [Keyboard.text(btn)])),
  });
  const option = await conversation.waitFor(":text")
    .andFrom(user)
    .and((ctx) => options.includes(ctx.msg.text), {
      otherwise: (ctx) => ctx.reply("Please use the buttons!"),
    });
  await openSettingsMenu(option, main);
}

bot.use(createConversation(captcha));
bot.use(createConversation(settings));
```

:::

The above code works in group chats.
It provides two conversations.
The conversation `captcha` is used to make sure that only good developers join the chat (shameless grammY plug lol).
The conversation `settings` is used to implement a settings menu in the group chat.

Note that all wait calls filter for a user identifier, among other things.

Let's assume that the following has already happened.

1. You called `ctx.conversation.enter("captcha")` to enter the conversation `captcha` while handling an update from a user with identifier `ctx.from.id === 42`.
2. You called `ctx.conversation.enter("settings")` to enter the conversation `settings` while handling an update from a user with identifier `ctx.from.id === 3`.
3. You called `ctx.conversation.enter("captcha")` to enter the conversation `captcha` while handling an update from a user with identifier `ctx.from.id === 43`.

This means that three conversations are active in this group chat now---`captcha` is active twice and `settings` is active once.

> Note that `ctx.conversation` provides [various ways](/ref/conversations/conversationcontrols#exit) to exit specific conversations even with parallel conversations enabled.

Next, the following things happen in order.

1. User `3` sends a message containing the text `"About"`.
2. An update with a text message arrives.
3. The first instance of the conversation `captcha` is replayed.
4. The `waitFor(":text")` text call accepts the update, but the added filter `andFrom(42)` rejects the update.
5. The second instance of the conversation `captcha` is replayed.
6. The `waitFor(":text")` text call accepts the update, but the added filter `andFrom(43)` rejects the update.
7. All instances of `captcha` rejected the update, so control is handed back to the middleware system.
8. The instance of the conversation `settings` is replayed.
9. The wait call resolves and `option` will contain a context object for the text message update.
10. The function `openSettingsMenu` is called.
    It can send an about text to the user and rewind the conversation back to `main`, restarting the menu.

Note that even though two conversations were waiting for the the users `42` and `43` to complete their captcha, the bot correctly replied to user `3` who had started the settings menu.
Filtered wait calls can determine which updates are relevant for the current conversation.
Disregarded updates fall through and can be picked up by other conversations.

The above example uses a group chat to illustrate how conversations can handle multiple users in parallel in the same chat.
In reality, parallel conversations work in all chats.
This lets you wait for different things in a chat with a single user.

You can combine parallel conversations with [wait timeouts](#wait-timeouts) to keep the number of active conversations low.

## Inspecting Active Conversations

Inside your middleware, you can inspect which conversation is active.

```ts
bot.command("stats", (ctx) => {
  const convo = ctx.conversation.active("convo");
  console.log(convo); // 0 or 1
  const isActive = convo > 0;
  console.log(isActive); // false or true
});
```

When you pass a conversation identifier to `ctx.conversation.active`, it will return `1` if this conversation is active, and `0` otherwise.

If you enable [parallel conversations](#parallel-conversations) for the conversation, it will return the number of times that this conversation is currently active.

Call `ctx.conversation.active()` without arguments to receive an object that contains the identifiers of all active conversations as keys.
The respective values describe how many instances of each conversation are active.

If the conversation `captcha` is active twice and the conversation `settings` is active once, `ctx.conversation.active()` will work as follows.

```ts
bot.command("stats", (ctx) => {
  const stats = ctx.conversation.active();
  console.log(stats); // { captcha: 2, settings: 1 }
});
```

## Migrating From 1.x to 2.x

Conversations 2.0 is a complete rewrite from scratch.

Even though the basic concepts of the API surface remained the same, the two implementations are fundamentally different in how they operate under the hood.
In a nutshell, migrating from 1.x to 2.x results in very little adjustments to your code, but it requires you to drop all stored data.
Thus, all conversations will be restarted.

### Data Migration From 1.x to 2.x

There is no way to keep the current state of conversations when upgrading from 1.x to 2.x.

You should just drop the respective data from your sessions.
Consider using [session migrations](./session#migrations) for this.

Persisting conversations data with version 2.x can be done as described [here](#persisting-conversations).

### Type Changes Between 1.x and 2.x

With 1.x, the context type inside a conversation was the same context type used in the surrounding middleware.

With 2.x, you must now always declare two context types---[an outside context type and an inside context type](#conversational-context-objects).
These types can never be the same, and if they are, you have a bug in your code.
This is because the outside context type must always have [`ConversationFlavor`](/ref/conversations/conversationflavor) installed, while the inside context type must never have it installed.

In addition, you can now install an [independent set of plugins](#using-plugins-inside-conversations) for each conversation.

### Session Access Changes Between 1.x and 2.x

You can no longer use `conversation.session`.
Instead, you must use `conversation.external` for this.

```ts
// Read session data.
const session = await conversation.session; // [!code --]
const session = await conversation.external((ctx) => ctx.session); // [!code ++]

// Write session data.
conversation.session = newSession; // [!code --]
await conversation.external((ctx) => { // [!code ++]
  ctx.session = newSession; // [!code ++]
}); // [!code ++]
```

> Accessing `ctx.session` was possible with 1.x, but it was always incorrect.
> `ctx.session` is no longer available with 2.x.

### Plugin Compatibility Changes Between 1.x and 2.x

Conversations 1.x were barely compatible with any plugins.
Some compatibility could be achieved by using `conversation.run`.

This option was removed for 2.x.
Instead, you can now pass plugins to the `plugins` array as described [here](#using-plugins-inside-conversations).
Sessions need [special treatment](#session-access-changes-between-1-x-and-2-x).
Menus have improved compatibility since the introduction of [conversational menus](#conversational-menus).

### Parallel Conversation Changes Between 1.x and 2.x

Parallel conversations work the same way with 1.x and 2.x.

However, this feature was a common source of confusion when used accidentally.
With 2.x, you need to opt-in to the feature by specifying `{ parallel: true }` as described [here](#parallel-conversations).

The only breaking change to this feature is that updates no longer get passed back to the middleware system by default.
Instead, this is only done when the conversation is marked as parallel.

Note that all wait methods and form fields provide an option `next` to override the default behavior.
This option was renamed from `drop` in 1.x, and the semantics of the flag were flipped accordingly.

### Form Changes Between 1.x and 2.x

Forms were really broken with 1.x.
For example, `conversation.form.text()` returned text messages even for `edited_message` updates of old messages.
Many of these oddities were corrected for 2.x.

Fixing bugs technically does not count as a breaking change, but it is still a substatial change in behavior.

## Plugin Summary

- Name: `conversations`
- [Source](https://github.com/grammyjs/conversations)
- [Reference](/ref/conversations/)
</file>

<file path="site/docs/plugins/emoji.md">
---
prev: false
next: false
---

# Emoji Plugin (`emoji`)

With this plugin, you can easily insert emojis on your replies searching for them instead of manually copying and pasting an emoji from web at your code.

## Why Should I Use This?

Why not? People use emojis in their code all the time to better illustrate the message they're willing to pass or to organize things.
But you lose your focus every time you need a new emoji, see:

1. You stop coding to search for a specific emoji.
2. You go to a Telegram chat and spent ~6 seconds (to not say more) searching for the emoji you want.
3. You copy-paste them into your code and get back coding, but with lost focus.

With this plugin, you just don't stop coding as also you don't lose your focus.
There is also bad-frickin'-laggy systems and/or editors that doesn't like and don't show emojis, so you end up pasting a white square, like this sad-little-squary message: `I'm so happy □`.

This plugin aims to solve these issues, handling for you the hard task of parsing emojis in all systems and letting you only search for them in a easy way (autocomplete is available).
Now, the above steps can be reduced to this one:

1. Describe the emoji you want and use it. Right in your code. Simple as that.

### Is This Sorcery?

No, it is called template strings.
You can read more about them [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).

## Installing and Examples

You can install this plugin on your bot like this:

::: code-group

```ts [TypeScript]
import { Bot, Context } from "grammy";
import { EmojiFlavor, emojiParser } from "@grammyjs/emoji";

// This is called Context Flavoring
// You can read more about at:
// https://grammy.dev/guide/context#transformative-context-flavors
type MyContext = EmojiFlavor<Context>;

const bot = new Bot<MyContext>("");

bot.use(emojiParser());
```

```js [JavaScript]
const { Bot } = require("grammy");
const { emojiParser } = require("@grammyjs/emoji");

const bot = new Bot("");

bot.use(emojiParser());
```

```ts [Deno]
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
  EmojiFlavor,
  emojiParser,
} from "https://deno.land/x/grammy_emoji/mod.ts";

// This is called Context Flavoring
// You can read more about at:
// https://grammy.dev/guide/context#transformative-context-flavors
type MyContext = EmojiFlavor<Context>;

const bot = new Bot<MyContext>("");

bot.use(emojiParser());
```

:::

Now you can get emojis by their names:

```js
bot.command("start", async (ctx) => {
  const parsedString = ctx.emoji`Welcome! ${"smiling_face_with_sunglasses"}`; // => Welcome! 😎
  await ctx.reply(parsedString);
});
```

Alternatively, you can reply directly using the `replyWithEmoji` method:

```js
bot.command("ping", async (ctx) => {
  await ctx.replyWithEmoji`Pong ${"ping_pong"}`; // => Pong 🏓
});
```

::: warning Keep in Mind That
`ctx.emoji` and `ctx.replyWithEmoji` **ALWAYS** use template strings.
If you're unfamiliar with this syntax, you can read more about it [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).
:::

## Useful Data for Reactions

When you use [reactions](../guide/reactions) with your bot, you will have to program a lot with emoji, too!
This is equally annoying, and since this plugin is the wet dream of all your emoji usage, it can help you with reactions, too.

You can import `Reactions` from this plugin and then use it as follows.

```ts
bot.on("message", (ctx) => ctx.react(Reactions.thumbs_up));
```

How nice.

## Plugin Summary

- Name: `emoji`
- [Source](https://github.com/grammyjs/emoji)
- [Reference](/ref/emoji/)
</file>

<file path="site/docs/plugins/entity-parser.md">
---
prev: false
next: false
---

# Entity Parser (`entity-parser`)

Converts [Telegram entities](https://core.telegram.org/bots/api#messageentity) to semantic HTML.

## When Should I Use This?

Probably NEVER!

While this plugin can generate HTML, it's generally best to send the text and entities back to Telegram.

Converting them to HTML is only necessary in rare cases where you need to use Telegram-formatted text **outside** of Telegram itself, such as displaying Telegram messages on a website.

See the [_Cases When It's Better Not to Use This Package_](#cases-when-it-s-better-not-to-use-this-package) section to determine if you have a similar problem to solve.

If you're unsure whether this plugin is the right fit for your use case, please don't hesitate to ask in our [Telegram group](https://t.me/grammyjs).
In most cases, people find they don't actually need this plugin to solve their problems!

## Installation

Run the following command in your terminal based on your runtime or package manager:

::: code-group

```sh:no-line-numbers [Deno]
deno add jsr:@qz/telegram-entities-parser
```

```sh:no-line-numbers [Bun]
bunx jsr add @qz/telegram-entities-parser
```

```sh:no-line-numbers [pnpm]
pnpm dlx jsr add @qz/telegram-entities-parser
```

```sh:no-line-numbers [Yarn]
yarn dlx jsr add @qz/telegram-entities-parser
```

```sh:no-line-numbers [npm]
npx jsr add @qz/telegram-entities-parser
```

:::

## Simple Usage

Using this plugin is straightforward.
Here's a quick example:

```ts
import { EntitiesParser } from "@qz/telegram-entities-parser";
import type { Message } from "@qz/telegram-entities-parser/types";

// For better performance, create the instance outside the function.
const entitiesParser = new EntitiesParser();
const parse = (message: Message) => entitiesParser.parse({ message });

bot.on(":text", (ctx) => {
  const html = parse(ctx.msg); // Convert text to HTML string
});

bot.on(":photo", (ctx) => {
  const html = parse(ctx.msg); // Convert caption to HTML string
});
```

## Advanced Usage

### Customizing the Output HTML Tag

This package converts entities into semantic HTML, adhering to best practices and standards as closely as possible.
However, the provided output might not always be what you expect.

To address this, you can use your own `renderer` to customize the HTML elements surrounding the text according to your rules.
You can modify specific rules by extending the default [`RendererHtml`](https://github.com/quadratz/telegram-entities-parser/blob/main/src/renderers/renderer_html.ts) or override all the rules by implementing the [`Renderer`](https://github.com/quadratz/telegram-entities-parser/blob/main/src/renderers/renderer.ts).

To extend the existing `renderer`, do the following:

```ts
import { EntitiesParser, RendererHtml } from "@qz/telegram-entities-parser";
import type {
  CommonEntity,
  RendererOutput,
} from "@qz/telegram-entities-parser/types";

// Change the rule for bold type entity,
// but leave the rest of the types as defined by `RendererHtml`.
class MyRenderer extends RendererHtml {
  override bold(
    options: { text: string; entity: CommonEntity },
  ): RendererOutput {
    return {
      prefix: '<strong class="tg-bold">',
      suffix: "</strong>",
    };
  }
}

const entitiesParser = new EntitiesParser({ renderer: new MyRenderer() });
```

The `options` parameter accepts an object with `text` and `entity`.

- `text`: The specific text that the current entity refers to.
- `entity`: This may be represented by various interfaces depending on the entity type, such as `CommonEntity`, `CustomEmojiEntity`, `PreEntity`, `TextLinkEntity`, or `TextMentionEntity`.
  For instance, the `bold` type has an entity with the `CommonEntity` interface, while the `text_link` type may have an entity with the `TextLinkEntity` interface, as it includes additional properties like `url`.

Here is the full list of interfaces and the output for each entity type:

| Entity Type             | Interface           | Result                                                                                                                                                                             |
| ----------------------- | ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `blockquote`            | `CommonEntity`      | `<blockquote class="tg-blockquote"> ... </blockquote>`                                                                                                                             |
| `bold`                  | `CommonEntity`      | `<b class="tg-bold"> ... </b>`                                                                                                                                                     |
| `bot_command`           | `CommonEntity`      | `<span class="tg-bot-command"> ... </span>`                                                                                                                                        |
| `cashtag`               | `CommonEntity`      | `<span class="tg-cashtag"> ... </span>`                                                                                                                                            |
| `code`                  | `CommonEntity`      | `<code class="tg-code"> ... </code>`                                                                                                                                               |
| `custom_emoji`          | `CustomEmojiEntity` | `<span class="tg-custom-emoji" data-custom-emoji-id="${options.entity.custom_emoji_id}"> ... </span>`                                                                              |
| `email`                 | `CommonEntity`      | `<a class="tg-email" href="mailto:${options.text}"> ... </a>`                                                                                                                      |
| `expandable_blockquote` | `CommonEntity`      | `<blockquote class="tg-expandable-blockquote"> ... </blockquote>`                                                                                                                  |
| `hashtag`               | `CommonEntity`      | `<span class="tg-hashtag"> ... </span>`                                                                                                                                            |
| `italic`                | `CommonEntity`      | `<i class="tg-italic"> ... </i>`                                                                                                                                                   |
| `mention`               | `CommonEntity`      | `<a class="tg-mention" href="https://t.me/${username}"> ... </a>`                                                                                                                  |
| `phone_number`          | `CommonEntity`      | `<a class="tg-phone-number" href="tel:${options.text}"> ... </a>`                                                                                                                  |
| `pre`                   | `PreEntity`         | `<pre class="tg-pre-code"><code class="language-${options.entity.language}"> ... </code></pre>` or `<pre class="tg-pre"> ... </pre>`                                               |
| `spoiler`               | `CommonEntity`      | `<span class="tg-spoiler"> ... </span>`                                                                                                                                            |
| `strikethrough`         | `CommonEntity`      | `<del class="tg-strikethrough"> ... </del>`                                                                                                                                        |
| `text_link`             | `TextLinkEntity`    | `<a class="tg-text-link" href="${options.entity.url}"> ... </a>`                                                                                                                   |
| `text_mention`          | `TextMentionEntity` | `<a class="tg-text-mention" href="https://t.me/${options.entity.user.username}"> ... </a>` or `<a class="tg-text-mention" href="tg://user?id=${options.entity.user.id}"> ... </a>` |
| `underline`             | `CommonEntity`      | `<span class="tg-bot-command"> ... </span>`                                                                                                                                        |
| `url`                   | `CommonEntity`      | `<a class="tg-url" href="${options.text}"> ... </a>`                                                                                                                               |

If you are unsure which interface is correct, refer to how the [Renderer](https://github.com/quadratz/telegram-entities-parser/blob/main/src/renderers/renderer.ts) or [RendererHtml](https://github.com/quadratz/telegram-entities-parser/blob/main/src/renderers/renderer_html.ts) is implemented.

### Customize the Text Sanitizer

The output text is sanitized by default to ensure proper HTML rendering and prevent XSS vulnerabilities.

| Input | Output   |
| ----- | -------- |
| `&`   | `&amp;`  |
| `<`   | `&lt;`   |
| `>`   | `&gt;`   |
| `"`   | `&quot;` |
| `'`   | `&#x27;` |

For example, the result `<b>Bold</b> & <i>Italic</i>` will be sanitized to `<b>Bold</b> &amp; <i>Italic</i>`.

You can override this behavior by specifying a `textSanitizer` when instantiating the [`EntitiesParser`](https://github.com/quadratz/telegram-entities-parser/blob/main/src/mod.ts):

- If you do not specify `textSanitizer`, it will default to using [`sanitizerHtml`](https://github.com/quadratz/telegram-entities-parser/blob/main/src/utils/sanitizer_html.ts) as the sanitizer.
- Setting the value to `false` will skip sanitization, keeping the output text as the original.
  This is not recommended, as it may result in incorrect rendering and make your application vulnerable to XSS attacks.
  Ensure proper handling if you choose this option.
- If you provide a function, it will be used instead of the default sanitizer.

```ts
const myTextSanitizer: TextSanitizer = (options: TextSanitizerOption): string =>
  // Replace dangerous character
  options.text.replaceAll(/[&<>"']/, (match) => {
    switch (match) {
      case "&":
        return "&amp;";
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "'":
        return "&#x27;";
      default:
        return match;
    }
  });

// Implement the sanitizer.
const entitiesParser = new EntitiesParser({ textSanitizer: myTextSanitizer });
```

## Cases When It's Better Not to Use This Package

If you face problems similar to those listed below, you might be able to resolve them without using this package.

### Copying and Forwarding the Same Message

Use [`forwardMessage`](https://core.telegram.org/bots/api#forwardmessage) to forward messages of any kind.

You can also use the [`copyMessage`](https://core.telegram.org/bots/api#copymessage) API, which performs the same action but does not include a link to the original message.
[`copyMessage`](https://core.telegram.org/bots/api#copymessage) behaves like copying the message and sending it back to Telegram, making it appear as a regular message rather than a forwarded one.

```ts
bot.on(":text", async (ctx) => {
  // The target chat id to send.
  const chatId = -946659600;
  // Forward the current message without a link to the original message.
  await ctx.copyMessage(chatId);
  // Forward the current message with a link to the original message.
  await ctx.forwardMessage(chatId);
});
```

### Replying to Messages with Modified Text Format

You can easily reply to incoming messages using HTML, Markdown, or entities.

```ts
bot.on(":text", async (ctx) => {
  // Reply using HTML
  await ctx.reply("<b>bold</b> <i>italic</i>", { parse_mode: "HTML" });
  // Reply using Telegram Markdown V2
  await ctx.reply("*bold* _italic_", { parse_mode: "MarkdownV2" });
  // Reply with entities
  await ctx.reply("bold italic", {
    entities: [
      { offset: 0, length: 5, type: "bold" },
      { offset: 5, length: 6, type: "italic" },
    ],
  });
});
```

::: tip Use parse-mode for a Better Formatting Experience

Use the official [`parse-mode`](./parse-mode) plugin for a better experience constructing formatted messages.
:::

## Plugin Summary

- Name: `entity-parser`
- [Package](https://jsr.io/@qz/telegram-entities-parser)
- [Source](https://github.com/quadratz/telegram-entities-parser)
</file>

<file path="site/docs/plugins/files.md">
---
prev: false
next: false
---

# File Handling Simplified in grammY (`files`)

This plugin allows you to easily download files from Telegram servers, and to obtain a URL so you can download the file yourself.

> [Remember](../guide/files) how files work, and how to upload them.

## Downloading Files

You need to pass your bot token to this plugin because it must authenticate as your bot when it downloads files.
This plugin then installs the `download` method on `getFile` call results.
Example:

::: code-group

```ts [TypeScript]
import { Bot, Context } from "grammy";
import { FileFlavor, hydrateFiles } from "@grammyjs/files";

// Transformative Context flavor
type MyContext = FileFlavor<Context>;

// Create a bot.
const bot = new Bot<MyContext>("");

// Use the plugin.
bot.api.config.use(hydrateFiles(bot.token));

// Download videos and GIFs to temporary locations.
bot.on([":video", ":animation"], async (ctx) => {
  // Prepare the file for download.
  const file = await ctx.getFile();
  // Download the file to a temporary location.
  const path = await file.download();
  // Print the file path.
  console.log("File saved at ", path);
});
```

```js [JavaScript]
import { Bot } from "grammy";
import { hydrateFiles } from "@grammyjs/files";

// Create a bot.
const bot = new Bot("");

// Use the plugin.
bot.api.config.use(hydrateFiles(bot.token));

// Download videos and GIFs to temporary locations.
bot.on([":video", ":animation"], async (ctx) => {
  // Prepare the file for download.
  const file = await ctx.getFile();
  // Download the file to a temporary location.
  const path = await file.download();
  // Print the file path.
  console.log("File saved at ", path);
});
```

```ts [Deno]
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
  FileFlavor,
  hydrateFiles,
} from "https://deno.land/x/grammy_files/mod.ts";

// Transformative Context flavor
type MyContext = FileFlavor<Context>;

// Create a bot.
const bot = new Bot<MyContext>("");

// Use the plugin.
bot.api.config.use(hydrateFiles(bot.token));

// Download videos and GIFs to temporary locations.
bot.on([":video", ":animation"], async (ctx) => {
  // Prepare the file for download.
  const file = await ctx.getFile();
  // Download the file to a temporary location.
  const path = await file.download();
  // Print the file path.
  console.log("File saved at ", path);
});
```

:::

You can pass a string with a file path to `download` if you don't want to create a temporary file.
Just do `await file.download("/path/to/file")`.

If you only want to get the URL of the file so you can download it yourself, use `file.getUrl`.
This will return an HTTPS link to your file that is valid for at least one hour.

## Local Bot API Server

If you are using a [local Bot API server](https://core.telegram.org/bots/api#using-a-local-bot-api-server), then the `getFile` call effectively downloads the file to your disk already.

In turn, you can call `file.getUrl()` to access that file path.
Note that `await file.download()` will now simply copy that locally present file to a temporary location (or to the given path if specified).

## Supporting `bot.api` Calls

By default, the results of `await bot.api.getFile()` will also be equipped with `download` and `getUrl` methods.
However, this is not reflected in the types.
If you need these calls, you should also install an [API flavor](../advanced/transformers#api-flavoring) on the bot object called `FileApiFlavor`:

::: code-group

```ts [Node.js]
import { Api, Bot, Context } from "grammy";
import { FileApiFlavor, FileFlavor, hydrateFiles } from "@grammyjs/files";

type MyContext = FileFlavor<Context>;
type MyApi = FileApiFlavor<Api>;

const bot = new Bot<MyContext, MyApi>("");
// ...
```

```ts [Deno]
import { Api, Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
  FileApiFlavor,
  FileFlavor,
  hydrateFiles,
} from "https://deno.land/x/grammy_files/mod.ts";

type MyContext = FileFlavor<Context>;
type MyApi = FileApiFlavor<Api>;

const bot = new Bot<MyContext, MyApi>("");
// ...
```

:::

## Plugin Summary

- Name: `files`
- [Source](https://github.com/grammyjs/files)
- [Reference](/ref/files/)
</file>

<file path="site/docs/plugins/fluent.md">
---
prev: false
next: false
---

# Internationalization with Fluent (`fluent`)

[Fluent](https://projectfluent.org/) is a localization system made by the Mozilla Foundation for natural-sounding translations.
It has a very powerful and elegant syntax that lets anyone write efficient and fully-understandable translations.
This plugin takes advantage of this amazing localization system to make grammY-powered bots fluent with high-quality translations.

::: tip Not to Be Confused
Don't confuse this with [i18n](./i18n).

[i18n](./i18n) is an improved version of this plugin that works on both Deno and Node.js.
:::

## Initialize Fluent

The first thing you do is to initialize a Fluent instance:

```ts
import { Fluent } from "@moebius/fluent";

const fluent = new Fluent();
```

Then, you will need to add at least one translation to the Fluent instance:

```ts
await fluent.addTranslation({
  // Specify one or more locales supported by your translation:
  locales: "en",

  // You can specify the translation content directly:
  source: "{YOUR TRANSLATION FILE CONTENT}",

  // Or the translation files:
  filePath: [
    `${__dirname}/feature-1/translation.en.ftl`,
    `${__dirname}/feature-2/translation.en.ftl`,
  ],

  // All the aspects of Fluent are highly configurable:
  bundleOptions: {
    // Use this option to avoid invisible characters around placeables.
    useIsolating: false,
  },
});
```

## Write Translation Messages

The Fluent syntax should be easy to master.
You can start by looking at the [official examples](https://projectfluent.org/#examples) or by studying the [comprehensive syntax guide](https://projectfluent.org/fluent/guide/).

Let's start with this example for now:

```ftl
-bot-name = Apples Bot

welcome =
  Welcome, {$name}, to the {-bot-name}!
  You have { NUMBER($applesCount) ->
    [0] no apples
    [one] {$applesCount} apple
    *[other] {$applesCount} apples
  }.
```

It demonstrates three important features of Fluent, namely: **terms**, **variable substitution** (aka _placeables_) and **pluralization**.

The `welcome` is the **message ID**, which will be used to reference its message whenever render it.

The statement `-bot-name = Apples Bot` defines a **term** with name `bot-name` and value `Apples Bot`.
The construct `{-bot-name}` references the previously defined term and will be get replaced by the term's value when rendered.

The statement `{$name}` will be replaced with the value of the `name` variable that you will need to pass to the translation function yourself.

And the final statement (_lines 5 to 9_) defines a **selector** (very similar to a switch statement) that takes result of the special `NUMBER` function applied to the `applesCount` variable and selects one of the three possible messages to be rendered based on the matched value.
The `NUMBER` function will return a [CLDR plural category](https://www.unicode.org/cldr/cldr-aux/charts/30/supplemental/language_plural_rules.html) based on the provided value and the used locale.
This effectively implements the pluralization.

## grammY Configuration

Now let's see how this message above could be rendered by a bot.
But first, we will need to configure grammY to use the plugin.

Before all else, you will need to configure your bot to use the Fluent context flavor.
If you are not familiar with this concept, you should read the official docs on [Context Flavors](../guide/context#context-flavors).

```ts
import { Context } from "grammy";
import { FluentContextFlavor } from "@grammyjs/fluent";

// Extend your application context type with the provided flavor interface.
export type MyAppContext = Context & FluentContextFlavor;
```

You will need to create your bot instance the following way in order to use the augmented context type:

```ts
const bot = new Bot<MyAppContext>("");
```

And the final step would be to register the Fluent plugin itself with grammY:

```ts
bot.use(
  useFluent({
    fluent,
  }),
);
```

Make sure to pass the [previously created Fluent instance](#initialize-fluent).

## Render the Localized Messages

Great, now we have everything in place to render our messages!
Let's do that by defining a test command in our bot:

```ts
bot.command("i18n_test", async (ctx) => {
  // Call the "translate" or "t" helper to render the
  // message by specifying its ID and additional parameters:
  await ctx.reply(
    ctx.t("welcome", {
      name: ctx.from.first_name,
      applesCount: 1,
    }),
  );
});
```

Now you can start your bot and use the `/i18n_test` command.
It should render the following message:

```text
Welcome, Slava, to the Apples Bot!
You have 1 apple.
```

Of course, you will see you own name instead of "Slava".
Try to change the value of the `applesCount` variable to see how the rendered message would change!

Be advised that you can now use the translation function everywhere where the `Context` is available.
The library would automatically determine the best possible locale to use for each user that will interact with your bot based on their personal preferences (the language set in the Telegram client settings).
You will just need to create several translation files and make sure that all the translation are properly synchronized.

## Further Steps

- Complete reading the [Fluent documentation](https://projectfluent.org/), especially the [syntax guide](https://projectfluent.org/fluent/guide/).
- [Migrate from the `i18n` plugin.](https://github.com/grammyjs/fluent#i18n-plugin-replacement)
- Familiarize yourself with [`@moebius/fluent`](https://github.com/the-moebius/fluent#readme).

## Plugin Summary

- Name: `fluent`
- [Source](https://github.com/grammyjs/fluent)
</file>

<file path="site/docs/plugins/guide.md">
---
next: false
---

# The Hitchhiker's Guide to grammY Plugins

If you would like to develop your own plugin and publish it, or if you want to know how grammY plugins work behind the scenes, this is the place for you!

> Please note that there is already a summary about [grammY plugins](./) are and what they do.
> This article is a deep dive into their inner workings.

## Types of Plugins in grammY

There are two main types of plugins in grammY:

- Middleware Plugins: The plugin's sole job is to return a [middleware function](../guide/middleware) that can be fed to a grammY bot.
- Transformer Plugins: The plugin's sole job is to return a [transformer function](../advanced/transformers) that can be fed to a grammY bot.

However, you will sometimes find plugins that do both things.
There are also other packages that are neither middleware nor transformer functions, but we will call them plugins anyway because they extend grammY in various ways.

## Rules of Contribution

You may publish your plugins in one of the following forms:

- Publishing as an **official** plugin.
- Publishing as a **third-party** plugin.

If you choose to publish your plugins as a third party, we can still offer you a prominent place on this website.
However, we prefer it if you publish your plugin under the [grammyjs organization](https://github.com/grammyjs) on GitHub, hence making it an official plugin.
In such a case, you will be granted publish access to GitHub and npm.
Also, You will be responsible for maintaining your code.

Before diving into some hands-on examples, there are some rules to pay attention to if you'd like your plugins to be listed on this website.

1. Have a README file on GitHub (and npm) with **short and clear** instructions on how to use it.
2. Explain the purpose of your plugin and how to use it by adding a page to the [docs](https://github.com/grammyjs/website).
   (We can create the page for you if you are unsure how to do that.)
3. Choose a permissive license such as MIT or ISC.

Finally, you should know that even though grammY supports both Node.js and [Deno](https://deno.com), it is a Deno-first project, and we also encourage you to write your plugins for Deno (and subsequently in style!).
There is a handy-dandy tool called [deno2node](https://github.com/wojpawlik/deno2node) that transpiles your code from Deno to Node.js so we can support both platforms equally well.
Deno support is only a strict requirement for official plugins, but not for third-party ones.
Nonetheless, it is very much encouraged to give Deno a try.
You will not want to go back.

## Designing a Dummy Middleware Plugin

Let's assume we would like to design a plugin that only responds to certain users!
For example, we could decide to only respond to people whose first name contain a certain word.
The bot will simply refuse to work for everyone else.

Here is a dummy example:

```ts
// plugin.ts

// Importing the types from grammY (we re-export them in `deps.deno.ts`).
import type { Context, Middleware, NextFunction } from "./deps.deno.ts";

// Your plugin can have one main function that creates middleware
export function onlyAccept<C extends Context>(str: string): Middleware<C> {
  // Create and return middleware.
  return async (ctx, next) => {
    // Get first name of user.
    const name = ctx.from?.first_name;
    // Let through all matching updates.
    if (name === undefined || name.includes(str)) {
      // Pass on control flow to downstream middleware.
      await next();
    } else {
      // Tell them we don't like them.
      await ctx.reply(`I'm not talking to you! You don't care about ${str}!`);
    }
  };
}
```

Now, it can be used in a real bot:

```ts
// Here, the plugin code is in a file called `plugin.ts`.
import { onlyAccept } from "./plugin.ts";
import { Bot } from "./deps.deno.ts";

const bot = new Bot("");

bot.use(onlyAccept("grammY"));

bot.on("message", (ctx) => ctx.reply("You passed the middleware plugin"));

bot.start();
```

Voilà!
You got yourself a plugin, right?
Well, not so fast.
We still need to package it up, but before that, let's take a look at transformer plugins, as well.

## Designing a Dummy Transformer Plugin

Imagine writing a plugin that sends the appropriate [chat action](https://core.telegram.org/bots/api#sendchataction) automatically whenever the bot sends a document.
This means that while your bot is sending a file, users will automatically see "_sending file…_" as status.
Pretty cool, right?

```ts
// plugin.ts
import type { Transformer } from "./deps.deno.ts";

// Main plugin function
export function autoChatAction(): Transformer {
  // Create and return a transformer function.
  return async (prev, method, payload, signal) => {
    // Save the handle of the set interval so we can clear it later.
    let handle: ReturnType<typeof setTimeout> | undefined;
    if (method === "sendDocument" && "chat_id" in payload) {
      // We now know that a document is being sent.
      const actionPayload = {
        chat_id: payload.chat_id,
        action: "upload_document",
      };
      // Repeatedly set the chat action while the file is being uploaded.
      handle ??= setInterval(() => {
        prev("sendChatAction", actionPayload).catch(console.error);
      }, 5000);
    }

    try {
      // Run the actual method from the bot.
      return await prev(method, payload, signal);
    } finally {
      // Clear the interval so we stop sending the chat action to the client.
      clearInterval(handle);
    }
  };
}
```

Now, we can use it in a real bot:

```ts
import { Bot, InputFile } from "./deps.deno.ts";
// The plugin code is in a file called `plugin.ts`
import { autoChatAction } from "./plugin.ts";

// Create a bot instance.
const bot = new Bot("");

// Use the plugin.
bot.api.config.use(autoChatAction());

bot.hears("send me a document", async (ctx) => {
  // If user send this command, we will send him a pdf file (for demonstration purposes)
  await ctx.replyWithDocument(new InputFile("/tmp/document.pdf"));
});

// start the bot
bot.start();
```

Now, every time we send a document, the chat action of `upload_document` will be sent to our client.
Note that this was for demonstration purposes.
Telegram recommends using chat actions only when "a response from the bot will take a **noticeable** amount of time to arrive".
You probably don't actually need to set the status if the file is very small, so there are some optimizations that could be done here.

## Extraction Into a Plugin

Whichever type of plugin you made, you have to bundle it in a standalone package.
This is a fairly simple task.
There are no specific rules on how to do this and npm is your oyster, but just to keep things organized, we have a template suggestion for you.
You can download the code from [our plugin template repository on GitHub](https://github.com/grammyjs/plugin-template) and start developing your plugin without any time spent on configuration.

The initially suggested folder structure:

```asciiart:no-line-numbers
plugin-template/
├─ src/
│  ├─ deps.deno.ts
│  ├─ deps.node.ts
│  └─ index.ts
├─ package.json
├─ tsconfig.json
└─ README.md
```

**`deps.deno.ts` and `deps.node.ts`**: This is for the developers who are willing to write the plugin for Deno, and then transpile it to Node.js.
As mentioned before, we use the tool `deno2node` to transpile our Deno code for Node.js.
`deno2node` has a feature that allows you to provide runtime-specific files to it.
These files should be adjacent to each other and follow the `*.deno.ts` and `*.node.ts` name structure as [explained in the docs](https://github.com/wojpawlik/deno2node#runtime-specific-code).
This is why there are two files: `deps.deno.ts` and `deps.node.ts`.
If there are any Node.js-specific dependencies, put them in `deps.node.ts`, otherwise, leave it empty.

> _**Note**_: You may also use other tools such as [deno dnt](https://github.com/denoland/dnt) to transpile your deno codebase or use other folder structures.
> The tooling you use is irrelevant, the main point here is that writing code for Deno is better and easier.

**`tsconfig.json`**: This is the TypeScript compiler configuration file used by `deno2node` to transpile your code.
A default one is provided in the repository as a suggestion.
It corresponds with the TypeScript configuration that Deno uses internally, and we recommend that you stick with this.

**`package.json`**: The package.json file for the npm version of your plugin.
**Make sure to change it according to your project**.

**`README.md`**: Instructions on how to use the plugin.
**Make sure to change it according to your project**.

**`index.ts`**: The file containing your business logic, i.e. your main plugin code.

## There Is a Boilerplate

If you would like to develop a plugin for grammY and do not know where to start, we highly suggest the template code in [our repository](https://github.com/grammyjs/plugin-template).
You can clone the code for yourself and start coding based on what was covered in this article.
This repository also includes some extra goodies such as `.editorconfig`, `LICENSE`, `.gitignore`, etc, but you may choose to delete them.

## I Don't Like Deno

Well, you're missing out!
But you can also write your plugins only for Node.js.
You can still publish the plugin and have it listed as a third-party plugin on this website.
In such a case, you may use any folder structure you like (as long as it is organized like any other npm project).
Simply install grammY through npm with `npm install grammy`, and start coding.

## How to Submit?

If you have a plugin ready, you may simply submit a pull request on GitHub (according to the [Rules of Contribution](#rules-of-contribution)), or notify us in the [community chat](https://t.me/grammyjs) for further help.
</file>

<file path="site/docs/plugins/hydrate.md">
---
prev: false
next: false
---

# Hydration Plugin for grammY (`hydrate`)

This plugin installs useful methods on two types of objects, namely

1. the results of API calls, and
2. the objects on the context object `ctx`.

Instead of having to call `ctx.api` or `bot.api` and having to supply all sorts of identifiers, you can now just call methods on objects and they will just work.
This is best illustrated by an example.

**WITHOUT** this plugin:

```ts
bot.on(":photo", async (ctx) => {
  const statusMessage = await ctx.reply("Processing");
  await doWork(ctx.msg.photo); // some long image processing
  await ctx.api.editMessageText(
    ctx.chat.id,
    statusMessage.message_id,
    "Done!",
  );
  setTimeout(
    () =>
      ctx.api.deleteMessage(ctx.chat.id, statusMessage.message_id).catch(
        () => {
          // Do nothing on error.
        },
      ),
    3000,
  );
});
```

**WITH** this plugin:

```ts
bot.on(":photo", async (ctx) => {
  const statusMessage = await ctx.reply("Processing");
  await doWork(ctx.msg.photo); // some long image processing
  await statusMessage.editText("Done!"); // so easy!
  setTimeout(() => statusMessage.delete().catch(() => {}), 3000);
});
```

Neat, right?

## Installation

There are two ways to install this plugin.

### Simple Installation

This plugin can be installed in a straightforward way that should be enough for most users.

::: code-group

```ts [TypeScript]
import { Bot, Context } from "grammy";
import { hydrate, HydrateFlavor } from "@grammyjs/hydrate";

type MyContext = HydrateFlavor<Context>;

const bot = new Bot<MyContext>("");

bot.use(hydrate());
```

```js [JavaScript]
import { Bot } from "grammy";
import { hydrate } from "@grammyjs/hydrate";

const bot = new Bot("");

bot.use(hydrate());
```

```ts [Deno]
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
  hydrate,
  HydrateFlavor,
} from "https://deno.land/x/grammy_hydrate/mod.ts";

type MyContext = HydrateFlavor<Context>;

const bot = new Bot<MyContext>("");

bot.use(hydrate());
```

:::

### Advanced Installation

When using the simple installation, only the API call results that go through `ctx.api` will be hydrated, e.g. `ctx.reply`.
These are most calls for most bots.

However, some bots may need to make calls to `bot.api`.
In this case, you should use this advanced installation.

It will integrate context hydration and API call result hydration separately into your bot.
Note that you now also have to install an [API flavor](../advanced/transformers#api-flavoring).

::: code-group

```ts [TypeScript]
import { Api, Bot, Context } from "grammy";
import {
  hydrateApi,
  HydrateApiFlavor,
  hydrateContext,
  HydrateFlavor,
} from "@grammyjs/hydrate";

type MyContext = HydrateFlavor<Context>;
type MyApi = HydrateApiFlavor<Api>;

const bot = new Bot<MyContext, MyApi>("");

bot.use(hydrateContext());
bot.api.config.use(hydrateApi());
```

```js [JavaScript]
import { Bot } from "grammy";
import { hydrateApi, hydrateContext } from "@grammyjs/hydrate";

const bot = new Bot("");

bot.use(hydrateContext());
bot.api.config.use(hydrateApi());
```

```ts [Deno]
import { Api, Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
  hydrateApi,
  HydrateApiFlavor,
  hydrateContext,
  HydrateFlavor,
} from "https://deno.land/x/grammy_hydrate/mod.ts";

type MyContext = HydrateFlavor<Context>;
type MyApi = HydrateApiFlavor<Api>;

const bot = new Bot<MyContext, MyApi>("");

bot.use(hydrateContext());
bot.api.config.use(hydrateApi());
```

:::

## What Objects Are Hydrated

This plugin currently hydrates

- messages and channel posts
- edited messages and edited channel posts
- callback queries
- inline queries
- chosen inline results
- web app queries
- pre-checkout and shipping queries
- chat join requests

All objects are hydrated on

- the context object `ctx`,
- the update object `ctx.update` inside the context,
- shortcuts on the context object such as `ctx.msg`, and
- API call results where applicable.

## Plugin Summary

- Name: `hydrate`
- [Source](https://github.com/grammyjs/hydrate)
- [Reference](/ref/hydrate/)
</file>

<file path="site/docs/plugins/i18n.md">
---
prev: false
next: false
---

# Internationalization (`i18n`)

The internationalization plugin makes your bot speak multiple languages.

::: tip Not to Be Confused
Don't confuse this with [fluent](./fluent).

This plugin is an improved version of [fluent](./fluent) that works on both Deno and Node.js.
:::

## Internationalization Explained

> This section explains what internationalization is, why it is needed, what is complicated about it, how it relates to localization, and why you need a plugin for all of this.
> If you already know these things, scroll right to [Getting Started](#getting-started).

First, internationalization is a very long word.
Hence, people like to write the first letter (i) and the last letter (n).
They then count all remaining letters (nternationalizatio, 18 letters) and put this number between i and the n, so they end up with _i18n_.
Don't ask us why.
So i18n is just a weird abbreviation of the word internationalization.

The same is done to localization, which turns into _l10n_.

### What Is Localization?

Localization means creating a bot that can speak multiple languages.
It should automatically adjust its language to the language of the user.

There are more things to localize than the language.
You can also account for cultural differences or other standards, such as the date and time formats.
Here are a few more examples of things that are represented differently across the globe:

1. Dates
2. Times
3. Numbers
4. Units
5. Pluralization
6. Genders
7. Hyphenation
8. Capitalization
9. Alignment
10. Symbols and icons
11. Sorting

… and [a lot more](https://youtu.be/0j74jcxSunY).

All of these things collectively define the _locale_ of a user.
Locales often get two-letter codes, such as `en` for English, `de` for German, and so on.
If you want to find the code for your locale, check out this [list](https://en.wikipedia.org/wiki/IETF_language_tag#List_of_common_primary_language_subtags).

### What Is Internationalization?

In a nutshell, internationalization means writing code that can adjust to a user's locale.
In other words, internationalization is what enables localization (see [above](#what-is-localization)).
This means that while your bot fundamentally works the same way for everybody, the exact messages it sends vary from user to user, so the bot can speak different languages.

You are doing internationalization if you don't hard-code the texts your bot sends but instead read them from a file dynamically.
You are doing internationalization if you don't hard-code how dates and times are represented, and instead use a library that adjusts these values according to different standards.
You get the idea: Don't hard-code stuff that should change based on where the user lives or the language they speak.

### Why Do You Need This Plugin?

This plugin can assist you throughout your internationalization process.
It is based on [Fluent](https://projectfluent.org/)---a localization system built by [Mozilla](https://mozilla.org/en-US/).
This system has a very powerful and elegant syntax that lets you write natural-sounding translations in an efficient way.

In essence, you can extract the things that should adjust based on the user's locale to some text files that you put next to your code.
You can then use this plugin to load these localizations.
The plugin will automatically determine the user's locale and let your bot choose the right language to speak.

Below, we will call these text files _translation files_.
They are required to follow Fluent's syntax.

## Getting Started

> This section describes setting up your project structure and where to put your translation files.
> If you are familiar with this, [skip ahead](#usage) to see how to install and use the plugin.

There are [multiple ways](#adding-translations) to add more languages to your bot.
The easiest way is to create a folder with your Fluent translation files.
Usually, the name of that folder is going to be `locales/`.
The translation files should have the extension `.ftl` (fluent).

Here is an example project structure:

```asciiart:no-line-numbers
.
├── bot.ts
└── locales/
    ├── de.ftl
    ├── en.ftl
    ├── it.ftl
    └── ru.ftl
```

If you're unfamiliar with Fluent's syntax, you can read their guide: <https://projectfluent.org/fluent/guide>

Here is an example translation file for English, called `locales/en.ftl`:

```ftl
start = Hi, how can I /help you?
help =
    Send me some text, and I can make it bold for you.
    You can change my language using the /language command.
```

The German equivalent would be called `locales/de.ftl` and look like this:

```ftl
start = Hallo, wie kann ich dir helfen? /help
help =
    Schick eine Textnachricht, die ich für dich fett schreiben soll.
    Du kannst mit dem Befehl /language die Spache ändern.
```

In your bot, you can now use these translations through the plugin.
It will make them available through `ctx.t`:

```ts
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start"));
});

bot.command("help", async (ctx) => {
  await ctx.reply(ctx.t("help"));
});
```

Whenever you call `ctx.t`, the locale of the current context object `ctx` is used to find the proper translation.
Finding the proper translation is done using a _locale negotiator_.
In the simplest case, it just returns `ctx.from.language_code`.

As a result, users with different locales will be able to read the messages, each in their language.

## Usage

The plugin derives the user's locale from many different factors.
One of them is from `ctx.from.language_code`, which will be provided by the user's client.

However, there are many more things that can be used to determine the user's locale.
For example, you could store the user's locale in your [session](./session).
Hence, there are two main ways to use this plugin: [With Sessions](#with-sessions) and [Without Sessions](#without-sessions).

### Without Sessions

It's easier to use and set up the plugin without sessions.
Its main drawback is that you can't store the languages the users choose.

Like mentioned above, the locale to be used for the user will be decided with `ctx.from.language_code`, which is coming from the user's client.
But the default language will be used if you don't have a translation of that language.
Sometimes your bot might not be able to see the user's preferred language provided by their client, and in that case the default language will be used, too.

**The `ctx.from.language_code` will be visible only if the user previously has started a private conversation with your bot.**

::: code-group

```ts [TypeScript]
import { Bot, Context } from "grammy";
import { I18n, I18nFlavor } from "@grammyjs/i18n";

// For TypeScript and auto-completion support,
// extend the context with I18n's flavor:
type MyContext = Context & I18nFlavor;

// Create a bot as you normally would.
// Remember to extend the context.
const bot = new Bot<MyContext>("");

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n<MyContext>({
  defaultLocale: "en", // see below for more information
  directory: "locales", // Load all translation files from locales/.
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n);

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

```js [JavaScript]
const { Bot } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

// Create a bot as you normally would.
const bot = new Bot("");

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // see below for more information
  directory: "locales", // Load all translation files from locales/.
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n);

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

```ts [Deno]
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import { I18n, I18nFlavor } from "https://deno.land/x/grammy_i18n/mod.ts";

// For TypeScript and auto-completion support,
// extend the context with I18n's flavor:
type MyContext = Context & I18nFlavor;

// Create a bot as you normally would.
// Remember to extend the context.
const bot = new Bot<MyContext>("");

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n<MyContext>({
  defaultLocale: "en", // see below for more information
  // Load all translation files from locales/. (Not working in Deno Deploy.)
  directory: "locales",
});

// Translation files loaded this way works in Deno Deploy, too.
// await i18n.loadLocalesDir("locales");

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n);

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

:::

`ctx.t` returns the translated message for the specified key.
You don't have to worry about languages, as they will be picked automatically by the plugin.

Congratulations!
Your bot now speaks multiple languages! :earth_africa::tada:

### With Sessions

Let's assume that your bot has a `/language` command.
Generally, in grammY we can use [sessions](./session) to store user data per chat.
To let your internationalization instance know that sessions are enabled, you have to set `useSession` to `true` in the options of `I18n`.

Here is an example including a simple `/language` command:

::: code-group

```ts [TypeScript]
import { Bot, Context, session, SessionFlavor } from "grammy";
import { I18n, I18nFlavor } from "@grammyjs/i18n";

interface SessionData {
  __language_code?: string;
}

type MyContext = Context & SessionFlavor<SessionData> & I18nFlavor;

const bot = new Bot<MyContext>("");

const i18n = new I18n<MyContext>({
  defaultLocale: "en",
  useSession: true, // whether to store user language in session
  directory: "locales", // Load all translation files from locales/.
});

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(
  session({
    initial: () => {
      return {};
    },
  }),
);

// Register i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if ((await ctx.i18n.getLocale()) === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

```js [JavaScript]
const { Bot, session } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

const bot = new Bot("");

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether to store user language in session
  directory: "locales", // Load all translation files from locales/.
});

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(
  session({
    initial: () => {
      return {};
    },
  }),
);

// Register i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if ((await ctx.i18n.getLocale()) === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

```ts [Deno]
import {
  Bot,
  Context,
  session,
  SessionFlavor,
} from "https://deno.land/x/grammy/mod.ts";
import { I18n, I18nFlavor } from "https://deno.land/x/grammy_i18n/mod.ts";

interface SessionData {
  __language_code?: string;
}

type MyContext = Context & SessionFlavor<SessionData> & I18nFlavor;

const bot = new Bot<MyContext>("");

const i18n = new I18n<MyContext>({
  defaultLocale: "en",
  useSession: true, // whether to store user language in session

  // DOES NOT work in Deno Deploy
  directory: "locales",
});

// Translation files loaded this way works in Deno Deploy, too.
// await i18n.loadLocalesDir("locales");

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(
  session({
    initial: () => {
      return {};
    },
  }),
);

// Register the i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if ((await ctx.i18n.getLocale()) === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

:::

When sessions are enabled, the `__language_code` property in the session will be used instead of `ctx.from.language_code` (provided by the Telegram client) during language selection.
When your bot sends messages, the locale is selected from `ctx.session.__language_code`.

There is a `setLocale` method that you can use to set the desired language.
It will save this value in your session.

```ts
await ctx.i18n.setLocale("de");
```

This is equivalent to manually setting it in session, and then renegotiating the locale:

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

::: tip Renegotiating the Locale
When you are using sessions or something else---apart from `ctx.from.language_code`---for selecting a custom locale for the user, there are some situations where you might change the language while handling an update.
For instance, take a look at the above example using sessions.

When you only do

```ts
ctx.session.__language_code = "de";
```

it will not update the currently used locale in the `I18n` instance.
Instead, it only updates the session.
Thus, the changes will only take place _for the next update_.

If you cannot wait until the next update, you might need to refresh the changes after updating the user language.
Use the `renegotiateLocale` method for these cases.

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

Afterwards, whenever we use the method `t`, the bot will try to reply with the German translation of that message (specified in `locales/de.ftl`).

Also, remember that when you use built-in sessions, you can achieve the same result using the `setLocale` method.
:::

::: tip Setting the Locale When Not Using Sessions
When [not using sessions](#without-sessions), if there is a case where you need to set the locale for a user, you can do that by using the `useLocale` method.

```ts
await ctx.i18n.useLocale("de");
```

It sets the specified locale to be used for future translations.
The effect lasts only for the current update and is not preserved.
You can use this method to change the translation locale in the middle of the update (e.g., when the user changes the language).
:::

## Custom Locale Negotiation

You can use the option `localeNegotiator` to specify a custom locale negotiator.
This option is helpful if you want to select the locale based on external sources (such as databases) or in other situations where you want to control which locale is used.

Here is the default order of how the plugin chooses its locale:

1. If sessions are enabled, try to read `__language_code` from the session.
   If it returns a valid locale, it is used.
   If it returns nothing or a non-registered locale, move on to step 2.
2. Try to read from `ctx.from.language_code`.
   If it returns a valid locale, it is used.
   If it returns nothing or a non-registered locale, move on to step 3.

   > Note that `ctx.from.language_code` is only available if the user has started the bot.
   > That means if the bot sees the user in a group or somewhere without the user previously having started the bot, it won't be able to see `ctx.from.language_code`.

3. Try using the default language configured in the options of `I18n`.
   If it is set to a valid locale, it is used.
   If it isn't specified or set to a non-registered locale, move on to step 4.
4. Try using English (`en`).
   The plugin itself sets this as the ultimate fallback locale.
   Even though it is a fallback locale, and we recommend having a translation, it is not a requirement.
   If no English locale is provided, move on to step 5.
5. If all the above things fail, use `{key}` instead of a translation.
   We **highly recommend** setting a locale that exists in your translations as `defaultLocale` in the `I18n` options.

::: tip Locale Negotiation
Locale negotiation happens typically only once during Telegram update processing.
However, you can run `ctx.i18n.renegotiateLocale()` to call the negotiator again and determine the new locale.
It is helpful if the locale changes during single update processing.
:::

Here is an example of `localeNegotiator` where we use `locale` from session instead of `__language_code`.
In a case like this, you don't have to set `useSession` to `true` in the options of `I18n`.

::: code-group

```ts [TypeScript]
const i18n = new I18n<MyContext>({
  localeNegotiator: (ctx) =>
    ctx.session.locale ?? ctx.from?.language_code ?? "en",
});
```

```js [JavaScript]
const i18n = new I18n({
  localeNegotiator: (ctx) =>
    ctx.session.locale ?? ctx.from?.language_code ?? "en",
});
```

:::

If the custom locale negotiator returns an invalid locale, it will fall back and choose a locale, following the above order.

## Rendering Translated Messages

Let's take a closer look at rendering messages.

```ts
bot.command("start", async (ctx) => {
  // Call the "translate" or "t" helper to render the
  // message by specifying its ID and additional parameters:
  await ctx.reply(ctx.t("welcome"));
});
```

Now you can `/start` your bot.
It should render the following message:

```:no-line-numbers
Hi there!
```

### Placeables

Sometimes, you may want to place values such as numbers and names inside the strings.
You can do this with placeables.

```ts
bot.command("cart", async (ctx) => {
  // You can pass placeables as the second object.
  await ctx.reply(ctx.t("cart-msg", { items: 10 }));
});
```

The object `{ items: 10 }` is called the _translation context_ of the `cart-msg` string.

Now, with the `/cart` command:

```:no-line-numbers
You currently have 10 items in your cart.
```

Try to change the value of the `items` variable to see how the rendered message would change!
Also, check out the Fluent documentation, especially the [placeables documentation](https://projectfluent.org/fluent/guide/placeables.html).

### Global Placeables

It can be useful to specify a number of placeables that should be available to _all_ translations.
For example, if you reuse the name of the user in many messages, it can be tedious to pass the translation context `{ name: ctx.from.first_name }` everywhere.

Global placeables come to rescue!
Consider this:

```ts
const i18n = new I18n<MyContext>({
  defaultLocale: "en",
  directory: "locales",
  // Define globally available placeables:
  globalTranslationContext(ctx) {
    return { name: ctx.from?.first_name ?? "" };
  },
});

bot.use(i18n);

bot.command("start", async (ctx) => {
  // Can use `name` without specifying it again!
  await ctx.reply(ctx.t("welcome"));
});
```

::: warning Potential Formatting Issues
By default, Fluent uses Unicode isolation marks for interpolations.

If you use placeables inside tags or entities, having the isolation marks might result in incorrect formatting (e.g., plain text instead of an expected link or a cashtag).

To fix this, use the following options:

```ts
const i18n = new I18n({
  fluentBundleOptions: { useIsolating: false },
});
```

:::

## Adding Translations

There are three main methods to load translations.

### Loading Locales Using the `directory` Option

The simplest way to add translations to the `I18n` instance is by having all of your translations in a directory and specifying the directory name in the options.

```ts
const i18n = new I18n({
  directory: "locales",
});
```

### Loading Locales From a Directory

This method is the same thing as specifying `directory` in options.
Just put them all in a folder and load them like this:

```ts
const i18n = new I18n();

await i18n.loadLocalesDir("locales"); // async version
i18n.loadLocalesDirSync("locales-2"); // sync version
```

> Note that certain environments require you to use the `async` version.
> For example, Deno Deploy does not support synchronous file operations.

### Loading a Single Locale

It is also possible to add a single translation to the instance.
You can either specify the file path to the translation using

```ts
const i18n = new I18n();

await i18n.loadLocale("en", { filePath: "locales/en.ftl" }); // async version
i18n.loadLocaleSync("de", { filePath: "locales/de.ftl" }); // sync version
```

or you can directly load the translation data as a string like this:

```ts
const i18n = new I18n();

// async version
await i18n.loadLocale("en", {
  source: `greeting = Hello { $name }!
language-set = Language has been set to English!`,
});

// sync version
i18n.loadLocaleSync("de", {
  source: `greeting = Hallo { $name }!
language-set = Die Sprache wurde zu Deutsch geändert!`,
});
```

## Listening for Localized Text

We managed to send localized messages to the user.
Now, let's take a look at how to listen for messages sent by the user.
In grammY, we usually use the `bot.hears` handler for listening to incoming messages.
But since we've been talking about internationalization, in this section we will see how to listen for localized incoming messages.

This feature comes in handy when your bot has [custom keyboards](./keyboard#custom-keyboards) containing localized text.

Here is a short example of listening to a localized text message sent using a custom keyboard.
Instead of using `bot.hears` handler, we use `bot.filter` combined with the `hears` middleware provided by this plugin.

::: code-group

```ts [TypeScript]
import { hears } from "@grammyjs/i18n";

bot.filter(hears("back-to-menu-btn"), async (ctx) => {
  await ctx.reply(ctx.t("main-menu-msg"));
});
```

```js [JavaScript]
const { hears } = require("@grammyjs/i18n");

bot.filter(hears("back-to-menu-btn"), async (ctx) => {
  await ctx.reply(ctx.t("main-menu-msg"));
});
```

```ts [Deno]
import { hears } from "https://deno.land/x/grammy_i18n/mod.ts";

bot.filter(hears("back-to-menu-btn"), async (ctx) => {
  await ctx.reply(ctx.t("main-menu-msg"));
});
```

:::

The `hears` helper function allows your bot to listen for a message that is written in the locale of the user.

## Further Steps

- Complete reading the [Fluent documentation](https://projectfluent.org/), especially the [syntax guide](https://projectfluent.org/fluent/guide/).
- Check out proper [examples](https://github.com/grammyjs/i18n/tree/main/examples) of this plugin for Deno and Node.js.

## Plugin Summary

- Name: `i18n`
- [Source](https://github.com/grammyjs/i18n)
- [API Reference](/ref/i18n/)
</file>

<file path="site/docs/plugins/inline-query.md">
---
prev: false
next: false
---

# Inline Queries (built-in)

With inline queries, users can search for, browse, and send content suggested by your bot in any chat, even if it is not a member there.
To do this, they start a message with `@your_bot_name` and choose one of the results.

> Revisit the Inline mode section in the [Telegram Bot Features](https://core.telegram.org/bots/features#inline-requests) written by the Telegram team.
> Further resources are their [detailed description](https://core.telegram.org/bots/inline) of inline bots, as well as the [original blog post](https://telegram.org/blog/inline-bots) announcing the feature, and the Inline mode section in the [Telegram Bot API Reference](https://core.telegram.org/bots/api#inline-mode).
> They are all worth a read before implementing inline queries for your bot, as inline queries are a little advanced.
> If you do not feel like reading all of that, then rest assured that this page will walk you through every step.

## Enabling Inline Mode

By default, support for inline mode is disabled for your bot.
You must contact [@BotFather](https://t.me/BotFather) and enable inline mode for your bot to start receiving inline queries.

Got it?
Your Telegram client should now display "..." when you type the bot name in any text field, and show a loading spinner.
You can already start typing something.
Let us now see how your bot can handle these queries.

## Handling Inline Queries

Once a user triggers an inline query, i.e. starts a message by typing "@your_bot_name ..." in the text input field, your bot will receive updates about this.
grammY has special support for handling inline queries via the `bot.inlineQuery()` method, as documented on the `Composer` class in the [grammY API Reference](/ref/core/composer#inlinequery).
It allows you to listen for specific inline queries that match strings or regular expressions.
If you want to handle all inline queries generically, use `bot.on("inline_query")`.

```ts
// Listen for specific strings or regular expressions.
bot.inlineQuery(/best bot (framework|library)/, async (ctx) => {
  const match = ctx.match; // regex match object
  const query = ctx.inlineQuery.query; // query string
});

// Listen for any inline query.
bot.on("inline_query", async (ctx) => {
  const query = ctx.inlineQuery.query; // query string
});
```

Now that we know how to listen for inline query updates, we can answer them with a result list.

## Building Inline Query Results

Building result lists for inline queries is a tedious task because you need to construct [complex nested objects](https://core.telegram.org/bots/api#inlinequeryresult) with a variety of properties.
Fortunately, you are using grammY, and of course there are helpers that make this task very simple.

Every result needs three things.

1. A unique string identifier.
2. A _result object_ that describes how to display the inline query result.
   It can contain things like a title, a link, or an image.
3. A _message content object_ that describes the content of the message which will be sent by the user if they pick this result.
   In some cases, the message content can be inferred implicitly from the result object.
   For example, if you want your result to be displayed as a GIF, then Telegram will understand that the message content will be that same GIF---unless you specify a message content object.

grammY exports a builder for inline query results, named `InlineQueryResultBuilder`.
Here are some examples for its usage.

::: code-group

```ts [TypeScript]
import { InlineKeyboard, InlineQueryResultBuilder } from "grammy";

// Build a photo result.
InlineQueryResultBuilder.photo("id-0", "https://grammy.dev/images/grammY.png");

// Build a result that displays a photo but sends a text message.
InlineQueryResultBuilder.photo("id-1", "https://grammy.dev/images/grammY.png")
  .text("This text will be sent instead of the photo");

// Build a text result.
InlineQueryResultBuilder.article("id-2", "Inline Queries")
  .text("Great inline query docs: grammy.dev/plugins/inline-query");

// Pass further options to the result.
const keyboard = new InlineKeyboard()
  .text("Aw yis", "call me back");
InlineQueryResultBuilder.article("id-3", "Hit me", { reply_markup: keyboard })
  .text("Push my buttons");

// Pass further options to the message content.
InlineQueryResultBuilder.article("id-4", "Inline Queries")
  .text("**Outstanding** docs: grammy.dev", { parse_mode: "MarkdownV2" });
```

```js [JavaScript]
const { InlineKeyboard, InlineQueryResultBuilder } = require("grammy");

// Build a photo result.
InlineQueryResultBuilder.photo("id-0", "https://grammy.dev/images/grammY.png");

// Build a result that displays a photo but sends a text message.
InlineQueryResultBuilder.photo("id-1", "https://grammy.dev/images/grammY.png")
  .text("This text will be sent instead of the photo");

// Build a text result.
InlineQueryResultBuilder.article("id-2", "Inline Queries")
  .text("Great inline query docs: grammy.dev/plugins/inline-query");

// Pass further options to the result.
const keyboard = new InlineKeyboard()
  .text("Aw yis", "call me back");
InlineQueryResultBuilder.article("id-3", "Hit me", { reply_markup: keyboard })
  .text("Push my buttons");

// Pass further options to the message content.
InlineQueryResultBuilder.article("id-4", "Inline Queries")
  .text("**Outstanding** docs: grammy.dev", { parse_mode: "MarkdownV2" });
```

```ts [Deno]
import {
  InlineKeyboard,
  InlineQueryResultBuilder,
} from "https://deno.land/x/grammy/mod.ts";

// Build a photo result.
InlineQueryResultBuilder.photo("id-0", "https://grammy.dev/images/grammY.png");

// Build a result that displays a photo but sends a text message.
InlineQueryResultBuilder.photo("id-1", "https://grammy.dev/images/grammY.png")
  .text("This text will be sent instead of the photo");

// Build a text result.
InlineQueryResultBuilder.article("id-2", "Inline Queries")
  .text("Great inline query docs: grammy.dev/plugins/inline-query");

// Pass further options to the result.
const keyboard = new InlineKeyboard()
  .text("Aw yis", "call me back");
InlineQueryResultBuilder.article("id-3", "Hit me", { reply_markup: keyboard })
  .text("Push my buttons");

// Pass further options to the message content.
InlineQueryResultBuilder.article("id-4", "Inline Queries")
  .text("**Outstanding** docs: grammy.dev", { parse_mode: "MarkdownV2" });
```

:::

Note that if you want to send files via existing file identifiers, you should use the `*Cached` methods.

```ts
// Result for an audio file sent via file identifier.
const audioFileId = "AgADBAADZRAxGyhM3FKSE4qKa-RODckQHxsoABDHe0BDC1GzpGACAAEC";
InlineQueryResultBuilder.audioCached("id-0", audioFileId);
```

> Read more about file identifiers [here](../guide/files#how-files-work-for-telegram-bots).

You should check out the [API reference](/ref/core/inlinequeryresultbuilder) of `InlineQueryResultBuilder` and maybe also the [specification](https://core.telegram.org/bots/api#inlinequeryresult) of `InlineQueryResult` to see all available options.

## Answering Inline Queries

After generating an array of inline query results using the [above](#building-inline-query-results) builder, you can call `answerInlineQuery` to send these results to the user.

```ts
// Shameless self-advertisement in one project's documentation
// is the best kind of advertisement.
bot.inlineQuery(/best bot (framework|library)/, async (ctx) => {
  // Create a single inline query result.
  const result = InlineQueryResultBuilder
    .article("id:grammy-website", "grammY", {
      reply_markup: new InlineKeyboard()
        .url("grammY website", "https://grammy.dev/"),
    })
    .text(
      `<b>grammY</b> is the best way to create your own Telegram bots.
They even have a pretty website! 👇`,
      { parse_mode: "HTML" },
    );

  // Answer the inline query.
  await ctx.answerInlineQuery(
    [result], // answer with result list
    { cache_time: 30 * 24 * 3600 }, // 30 days in seconds
  );
});

// Return empty result list for other queries.
bot.on("inline_query", (ctx) => ctx.answerInlineQuery([]));
```

[Remember](../guide/basics#sending-messages) that you can always specify further options when calling API methods by using the options object of type `Other`.
For example, `answerInlineQuery` allows you to perform pagination for inline queries via an offset, as you can see [here](https://core.telegram.org/bots/api#answerinlinequery).

::: tip Mixing Text and Media
While it is allowed to send a result lists that contain both media and text elements, most Telegram clients do not render them very well.
From a user experience point of view, you should avoid them.
:::

## Button Above Inline Query Results

Telegram clients are able to [show a button](https://core.telegram.org/bots/api#inlinequeryresultsbutton) above the result list.
This button can take the user to the private chat with the bot.

```ts
const button = {
  text: "Open private chat",
  start_parameter: "login",
};
await ctx.answerInlineQuery(results, { button });
```

When the user presses the button, a `/start` command message will be sent to your bot.
The start parameter will be available via [deep linking](../guide/commands#deep-linking-support).
In other words, using the above code snippet, `ctx.match` will have the value `"login"` in your command handler.

If you then send an [inline keyboard](./keyboard#building-an-inline-keyboard) with a `switchInline` button, the user will be returned to the chat where they pressed the inline query results button initially.

```ts
bot
  .command("start")
  .filter((ctx) => ctx.match === "login", async (ctx) => {
    // User is coming from inline query results.
    await ctx.reply("DM open, you can go back now!", {
      reply_markup: new InlineKeyboard()
        .switchInline("Go back"),
    });
  });
```

That way, you can perform e.g. login procedures in a private chat with the user before delivering inline query results.
The dialogue can go back and forth a bit before you send them back.
For example, you can enter a short conversation with the [conversations plugin](./conversations).

## Getting Feedback About Chosen Results

Inline query results are delivered in a fire-and-forget fashion.
In other words, after your bot sent the list of inline query results to Telegram, it will not know which result the user picked (or if they picked one at all).

If you are interested in this, you can enable inline feedback with [@BotFather](https://t.me/BotFather).
You can decide how much feedback you want to receive by chosing among several options between 0 % (feedback disabled) and 100 % (receive feedback for every chosen inline result).

Inline feedback is delivered via `chosen_inline_result` updates.
You can listen for specific result identifiers via string or regular expression.
Naturally, you can also listen for the updates the normal way via filter queries.

```ts
// Listen for specific result identifiers.
bot.chosenInlineResult(/id-[0-9]+/, async (ctx) => {
  const match = ctx.match; // regex match object
  const query = ctx.chosenInlineResult.query; // used inline query
});

// Listen for any chosen inline results.
bot.on("chosen_inline_result", async (ctx) => {
  const query = ctx.chosenInlineResult.query; // used inline query
});
```

Some bots set the feedback to 100 % and use it as a hack.
They deliver dummy messages with no real content in `answerInlineQuery`.
Immediately after receiving a `chosen_inline_result` update, they edit the respective message and inject the real message content.

These bots will not work for anonymous admins or when sending scheduled messages, as no inline feedback can be received there.
However, if this is not a problem for you, then this hack will allow you to not have to generate a lot of message content for messages that never end up being sent.
This can save your bot resources.

## Plugin Summary

This plugin is built-in into the core of grammY.
You don't need to install anything to use it.
Simply import everything from grammY itself.

Also, both the documentation and the API reference of this plugin are unified with the core package.
</file>

<file path="site/docs/plugins/keyboard.md">
---
prev: false
next: false
---

# Inline and Custom Keyboards (built-in)

Your bot may send a number of buttons, either to be [displayed underneath a message](#inline-keyboards), or to [replace the user's keyboard](#custom-keyboards).
They are called _inline keyboards_ and _custom keyboards_, respectively.
If you think that this is confusing, then that's because it is.
Thank you, Telegram, for this overlapping terminology.

Let us try to clear it up a bit:

| Term                                     | Definition                                                                                                                          |
| ---------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| [**Inline Keyboard**](#inline-keyboards) | a set of buttons that is displayed underneath a message inside the chat.                                                            |
| [**Custom Keyboard**](#custom-keyboards) | a set of buttons that is displayed instead of the user's system keyboard.                                                           |
| **Inline Keyboard button**               | a button in an inline keyboard, sends a callback query not visible to the user when pressed, sometimes just called _inline button_. |
| **Custom Keyboard button**               | a button in a keyboard, sends a text message with its label when pressed, sometimes just called _keyboard button_.                  |
| **`InlineKeyboard`**                     | class in grammY to create inline keyboards.                                                                                         |
| **`Keyboard`**                           | class in grammY to create custom keyboards.                                                                                         |

> Note that both custom keyboard buttons and inline keyboard buttons can also have other functions, such as requesting the user's location, opening a website, and so on.
> This was omitted for brevity.

It is not possible to specify both a custom keyboard and an inline keyboard in the same message.
The two are mutually exclusive.
Moreover, the sent kind of reply markup cannot be changed at a later point by editing the message.
For example, it is not possible to first send a custom keyboard along with a message, and then edit the message to use an inline keyboard.

## Inline Keyboards

> Revisit the inline keyboard section in the [Telegram Bot Features](https://core.telegram.org/bots/features#inline-keyboards) written by the Telegram team.

grammY has a simple and intuitive way to build up the inline keyboards that your bot can send along with a message.
It provides a class called `InlineKeyboard` for this.

> The buttons added by calling `switchInline`, `switchInlineCurrent`, and `switchInlineChosen` start inline queries.
> Check out the section about [Inline Queries](./inline-query) for more information on how they work.

### Building an Inline Keyboard

You can build an inline keyboard by creating a new instance of the `InlineKeyboard` class, and then adding buttons you like to it using `.text()` and its other methods.

Here is an example:

![Example](/images/inline-keyboard-example.png)

```ts
const inlineKeyboard = new InlineKeyboard()
  .text("« 1", "first")
  .text("‹ 3", "prev")
  .text("· 4 ·", "stay")
  .text("5 ›", "next")
  .text("31 »", "last");
```

Call `.row()` if you want to begin a new row of buttons.
You can also use other methods like `.url()` to let the user's client open a specific URL or do other cool things.
Be sure to check out [all methods](/ref/core/inlinekeyboard#methods) on the `InlineKeyboard` class.

If you already have an array of strings that you would like to turn into an inline keyboard, you can use a second, alternative style for building inline keyboard instances.
The `InlineKeyboard` class has static methods such as `InlineKeyboard.text` that let you create button objects.
In turn, you can create an inline keyboard instance from array of button objects using `InlineKeyboard.from`.

That way, you can build the above inline keyboard in a functional way.

```ts
const labelDataPairs = [
  ["« 1", "first"],
  ["‹ 3", "prev"],
  ["· 4 ·", "stay"],
  ["5 ›", "next"],
  ["31 »", "last"],
];
const buttonRow = labelDataPairs
  .map(([label, data]) => InlineKeyboard.text(label, data));
const keyboard = InlineKeyboard.from([buttonRow]);
```

### Sending an Inline Keyboard

You can send an inline keyboard directly along a message, no matter whether you use `bot.api.sendMessage`, `ctx.api.sendMessage`, or `ctx.reply`:

```ts
// Send inline keyboard with message.
await ctx.reply(text, {
  reply_markup: inlineKeyboard,
});
```

Naturally, all other methods that send messages other than text messages support the same options, as specified by the [Telegram Bot API Reference](https://core.telegram.org/bots/api).
For example, you can edit a keyboard by calling `editMessageReplyMarkup`, and passing the new `InlineKeyboard` instance as `reply_markup`.
Specify an empty inline keyboard to remove all buttons underneath a message.

### Responding to Inline Keyboard Clicks

::: tip Menu Plugin
The keyboard plugin gives you raw access to the update objects that Telegram sends.
However, responding to clicks this way can be tedious.
If you are looking for a more high-level implementation of inline keyboards, check out the [menu plugin](./menu).
It makes it simple to create interactive menus.
:::

Every `text` button has a string as callback data attached.
If you don't attach callback data, grammY will use the button's text as data.

Once a user clicks a `text` button, your bot will receive an update containing the corresponding button's callback data.
You can listen for callback data via `bot.callbackQuery()`.

```ts
// Construct a keyboard.
const inlineKeyboard = new InlineKeyboard().text("click", "click-payload");

// Send a keyboard along with a message.
bot.command("start", async (ctx) => {
  await ctx.reply("Curious? Click me!", { reply_markup: inlineKeyboard });
});

// Wait for click events with specific callback data.
bot.callbackQuery("click-payload", async (ctx) => {
  await ctx.answerCallbackQuery({
    text: "You were curious, indeed!",
  });
});
```

::: tip Answering All Callback Queries
`bot.callbackQuery()` is useful to listen for click events of specific buttons.
You can use `bot.on("callback_query:data")` to listen for events of any button.

```ts
bot.callbackQuery("click-payload" /* , ... */);

bot.on("callback_query:data", async (ctx) => {
  console.log("Unknown button event with payload", ctx.callbackQuery.data);
  await ctx.answerCallbackQuery(); // remove loading animation
});
```

It makes sense to define `bot.on("callback_query:data")` at last to always answer all other callback queries that your previous listeners did not handle.
Otherwise, some clients may display a loading animation for up to a minute when a user presses a button that your bot does not want to react to.
:::

## Custom Keyboards

First things first: custom keyboards are sometimes just called keyboards, sometimes they're called reply keyboards, and even Telegram's own documentation is not consistent in this respect.
As a simple rule of thumb, when it isn't absolutely obvious from the context and not called inline keyboard, it probably is a custom keyboard.
This refers to a way to replace the system keyboard by a set of buttons that you can define.

> Revisit the custom keyboard section in the [Telegram Bot Features](https://core.telegram.org/bots/features#keyboards) written by the Telegram team.

grammY has a simple and intuitive way to build up the custom keyboards that your bot can use to replace the system keyboard.
It provides a class called `Keyboard` for this.

Once a user clicks a `text` button, your bot will receive the sent text as a plain text message.
Remember that you can listen for text message via `bot.on("message:text")` or `bot.hears()`.

### Building a Custom Keyboard

You can build a custom keyboard by creating a new instance of the `Keyboard` class, and by then adding buttons like to it via `.text()` and others.
Call `.row()` to begin a new row of buttons.

Here is an example:

![Example](/images/keyboard-example.png)

```ts
const keyboard = new Keyboard()
  .text("Yes, they certainly are").row()
  .text("I'm not quite sure").row()
  .text("No. 😈")
  .resized();
```

You can also send more powerful buttons that request the user's phone number or location or do other cool things.
Be sure to check out [all methods](/ref/core/keyboard#methods) on the `Keyboard` class.

If you already have an array of strings that you would like to turn into a keyboard, you can use a second, alternative style for building keyboard instances.
The `Keyboard` class has static methods such as `Keyboard.text` that let you create button objects.
In turn, you can create a keyboard instance from array of button objects using `Keyboard.from`.

That way, you can build the above keyboard in a functional way.

```ts
const labels = [
  "Yes, they certainly are",
  "I'm not quite sure",
  "No. 😈",
];
const buttonRows = labels
  .map((label) => [Keyboard.text(label)]);
const keyboard = Keyboard.from(buttonRows).resized();
```

### Sending a Custom Keyboard

You can send a custom keyboard directly along a message, no matter whether you use `bot.api.sendMessage`, `ctx.api.sendMessage`, or `ctx.reply`:

```ts
// Send keyboard with message.
await ctx.reply(text, {
  reply_markup: keyboard,
});
```

Naturally, all other methods that send messages other than text messages support the same options, as specified by the [Telegram Bot API Reference](https://core.telegram.org/bots/api).

You can also give your keyboard one or more further properties by calling special methods on it.
They will not add any buttons, but rather define the behavior of the keyboard.
We have already seen `resized` in the example above---here are a few more things you can do.

#### Persistent Keyboards

By default, users see an icon that allows them to show or hide the custom keyboard which your bot set.

You can call `persistent` if you want the custom keyboard to always be shown when the regular system keyboard is hidden.
That way, users will always see either the custom keyboard or the system keyboard.

```ts
new Keyboard()
  .text("Skip")
  .persistent();
```

#### Resize Custom Keyboard

You can call `resized` if you want the custom keyboard to be resized according to the buttons it contains.
This will effectively make the keyboard smaller.
(Usually, the keyboard will always have the size of the app's standard keyboard.)

```ts
new Keyboard()
  .text("Yes").row()
  .text("No")
  .resized();
```

It does not matter whether you call `resized` first, last or somewhere in between.
The result will always be the same.

#### One-Time Custom Keyboards

You can call `oneTime` if you want the custom keyboard to be hidden immediately after the first button was pressed.

```ts
new Keyboard()
  .text("Yes").row()
  .text("No")
  .oneTime();
```

It does not matter whether you call `oneTime` first, last or somewhere in between.
The result will always be the same.

#### Input Field Placeholder

You can call `placeholder` if you want a placeholder to be shown in the input field as long as the custom keyboard is visible.

```ts
new Keyboard()
  .text("Yes").row()
  .text("No")
  .placeholder("Decide now!");
```

It does not matter whether you call `placeholder` first, last or somewhere in between.
The result will always be the same.

#### Selectively Send Custom Keyboards

You can call `selected` if you want to show the custom keyboard only to those users that are @-mentioned in the text of the message object, and to the sender of the original message in case your message is a [reply](../guide/basics#sending-messages-with-reply).

```ts
new Keyboard()
  .text("Yes").row()
  .text("No")
  .selected();
```

It does not matter whether you call `selected` first, last or somewhere in between.
The result will always be the same.

### Responding to Custom Keyboard Clicks

As mentioned earlier, all that custom keyboards do is sending regular text messages.
Your bot cannot differentiate between ordinary text messages, and text messages that were sent by clicking a button.

Moreover, buttons will always send exactly the message that's written on them.
Telegram does not allow you to create buttons that display one text, but send another.
If you need to do this, you should use an [inline keyboard](#inline-keyboards) instead.

In order to handle the click of a specific button, you can use `bot.hears` with the same text as you put on the button.
If you want to handle all button clicks at once, you use `bot.on("message:text")` and inspect `ctx.msg.text` to figure out which button was clicked, or if an ordinary text message was sent.

### Removing a Custom Keyboard

Unless you specify `one_time_keyboard` as described [above](#one-time-custom-keyboards), the custom keyboard will remain open for the user (but
the user can minimize it).

You can only remove a custom keyboard when you send a new message in the chat, just like you can only specify a new keyboard by sending a message.
Pass `{ remove_keyboard: true }` as `reply_markup` like so:

```ts
await ctx.reply(text, {
  reply_markup: { remove_keyboard: true },
});
```

Next to `remove_keyboard`, you can set `selective: true` in order to remove the custom keyboard for selected users only.
This works analogously to [selectively sending a custom keyboard](#selectively-send-custom-keyboards).

## Plugin Summary

This plugin is built-in into the core of grammY.
You don't need to install anything to use it.
Simply import everything from grammY itself.

Also, both the documentation and the API reference of this plugin are unified with the core package.
</file>

<file path="site/docs/plugins/media-group.md">
---
prev: false
next: false
---

# Media Groups (built-in)

The media group plugin helps you send media groups by letting you build `InputMedia` objects.
Incidentally, `InputMedia` object are also used when editing media messages, so this plugin also helps you to edit media.

Remember that `InputMedia` objects are specified [here](https://core.telegram.org/bots/api#inputmedia).

## Building an `InputMedia` Object

You can use this plugin like so:

::: code-group

```ts [TypeScript]
import { InputMediaBuilder } from "grammy";

const photo = InputMediaBuilder.photo(new InputFile("/tmp/photo.mp4"));
const video = InputMediaBuilder.video(new InputFile("/tmp/video.mp4"));
// etc
```

```js [JavaScript]
const { InputMediaBuilder } = require("grammy");

const photo = InputMediaBuilder.photo(new InputFile("/tmp/photo.mp4"));
const video = InputMediaBuilder.video(new InputFile("/tmp/video.mp4"));
// etc
```

```ts [Deno]
import { InputMediaBuilder } from "https://deno.land/x/grammy/mod.ts";

const photo = InputMediaBuilder.photo(new InputFile("/tmp/photo.mp4"));
const video = InputMediaBuilder.video(new InputFile("/tmp/video.mp4"));
// etc
```

:::

Check out all methods of `InputMediaBuilder` in the [API reference](/ref/core/inputmediabuilder).

You can also directly pass public URLs which Telegram fetches.

```ts
const photo = InputMediaBuilder.photo("https://grammy.dev/images/grammY.png");
```

Further options can be provided in an options object at the end.

```ts
const photo = InputMediaBuilder.photo("https://grammy.dev/images/grammY.png", {
  caption: "grammY is awesome",
  // etc
});
```

## Sending a Media Group

You can send a media group as follows:

```ts
await ctx.replyWithMediaGroup([photo0, photo1, photo2, video]);
```

Likewise, you can pass an array of `InputMedia` objects to `ctx.api.sendMediaGroup` or `bot.api.sendMediaGroup`.

## Editing a Media Message

Since `InputMedia` objects are also used to edit media messages, this plugin will assist you here, too:

```ts
const newMedia = InputMediaBuilder.photo(
  "https://grammy.dev/images/grammY.png",
);
await ctx.editMessageMedia(newMedia);
```

As always, this works for `ctx.api.editMessageMedia` and `bot.api.editMessageMedia`, too.

## Plugin Summary

This plugin is built-in into the core of grammY.
You don't need to install anything to use it.
Simply import everything from grammY itself.

Also, both the documentation and the API reference of this plugin are unified with the core package.
</file>

<file path="site/docs/plugins/menu.md">
---
prev: false
next: false
---

# Interactive Menus (`menu`)

Easily create interactive menus.

## Introduction

An inline keyboard is an array of buttons underneath a message.
grammY has a [built-in plugin](./keyboard#inline-keyboards) to create basic inline keyboards.

The menu plugin takes this idea further and lets you create rich menus right inside the chat.
They can have interactive buttons, multiple pages with navigation between them, and more.

Here is a simple example that speaks for itself.

::: code-group

```ts [TypeScript]
import { Bot } from "grammy";
import { Menu } from "@grammyjs/menu";

// Create a bot.
const bot = new Bot("");

// Create a simple menu.
const menu = new Menu("my-menu-identifier")
  .text("A", (ctx) => ctx.reply("You pressed A!")).row()
  .text("B", (ctx) => ctx.reply("You pressed B!"));

// Make it interactive.
bot.use(menu);

bot.command("start", async (ctx) => {
  // Send the menu.
  await ctx.reply("Check out this menu:", { reply_markup: menu });
});

bot.start();
```

```js [JavaScript]
const { Bot } = require("grammy");
const { Menu } = require("@grammyjs/menu");

// Create a bot.
const bot = new Bot("");

// Create a simple menu.
const menu = new Menu("my-menu-identifier")
  .text("A", (ctx) => ctx.reply("You pressed A!")).row()
  .text("B", (ctx) => ctx.reply("You pressed B!"));

// Make it interactive.
bot.use(menu);

bot.command("start", async (ctx) => {
  // Send the menu.
  await ctx.reply("Check out this menu:", { reply_markup: menu });
});

bot.start();
```

```ts [Deno]
import { Bot } from "https://deno.land/x/grammy/mod.ts";
import { Menu } from "https://deno.land/x/grammy_menu/mod.ts";

// Create a bot.
const bot = new Bot("");

// Create a simple menu.
const menu = new Menu("my-menu-identifier")
  .text("A", (ctx) => ctx.reply("You pressed A!")).row()
  .text("B", (ctx) => ctx.reply("You pressed B!"));

// Make it interactive.
bot.use(menu);

bot.command("start", async (ctx) => {
  // Send the menu.
  await ctx.reply("Check out this menu:", { reply_markup: menu });
});

bot.start();
```

:::

> Make sure that you install all menus before other middleware, especially before middleware that uses callback query data.
> Also, if you use a custom configuration for `allowed_updates`, remember to include `callback_query` updates.

Naturally, if you are using a [custom context type](../guide/context#customizing-the-context-object), you can pass it to `Menu` too.

```ts
const menu = new Menu<MyContext>("id");
```

## Adding Buttons

The menu plugin lays out your keyboards exactly like the [plugin for inline keyboards](./keyboard#building-an-inline-keyboard) does.
The class `Menu` replaces the class `InlineKeyboard`.

Here is an example for a menu that has four buttons in a 1-2-1 row shape.

```ts
const menu = new Menu("movements")
  .text("^", (ctx) => ctx.reply("Forward!")).row()
  .text("<", (ctx) => ctx.reply("Left!"))
  .text(">", (ctx) => ctx.reply("Right!")).row()
  .text("v", (ctx) => ctx.reply("Backwards!"));
```

Use `text` to add new text buttons.
You can pass a label and a handler function.

Use `row` to end the current row, and add all subsequent buttons to a new one.

There are many more button types available, e.g. for opening URLs.
Check out this plugin's [API Reference](/ref/menu/menurange) for `MenuRange`, as well as the [Telegram Bot API Reference](https://core.telegram.org/bots/api#inlinekeyboardbutton) for `InlineKeyboardButton`.

## Sending a Menu

You must first install a menu.
This makes it interactive.

```ts
bot.use(menu);
```

You can now simply pass the menu as `reply_markup` when sending a message.

```ts
bot.command("menu", async (ctx) => {
  await ctx.reply("Here is your menu", { reply_markup: menu });
});
```

## Dynamic Labels

Whenever you put a label string on a button, you can also pass a function `(ctx: Context) => string` to get a dynamic label on the button.
This function may or may not be `async`.

```ts
// Create a button with the user's name, which will greet them when pressed.
const menu = new Menu("greet-me")
  .text(
    (ctx) => `Greet ${ctx.from?.first_name ?? "me"}!`, // dynamic label
    (ctx) => ctx.reply(`Hello ${ctx.from.first_name}!`), // handler
  );
```

A string that is generated by such a function is called a _dynamic string_.
Dynamic strings are ideal for things like toggle buttons.

```ts
// Set of user identifiers that have notifications enabled.
const notifications = new Set<number>();

function toggleNotifications(id: number) {
  if (!notifications.delete(id)) notifications.add(id);
}

const menu = new Menu("toggle")
  .text(
    (ctx) => ctx.from && notifications.has(ctx.from.id) ? "🔔" : "🔕",
    (ctx) => {
      toggleNotifications(ctx.from.id);
      ctx.menu.update(); // update the menu!
    },
  );
```

Note that you must update a menu whenever you want your buttons to change.
Call `ctx.menu.update()` to make sure that your menu will be re-rendered.

::: tip Storing Data
The example above demonstrates how to use the menu plugin.
It is not a good idea to actually store user settings in a `Set` object, because then all data will be lost when you stop the server.

Instead, consider using a database or the [session plugin](./session) if you want to store data.
:::

## Updating or Closing the Menu

When a button handler is called, a number of useful functions are available on `ctx.menu`.

If you want your menu to re-render, you can call `ctx.menu.update()`.
This will only work inside the handlers that you install on your menu.
It will not work when called from other bot middleware, as in such cases there is no way to know _which_ menu should be updated.

```ts
const menu = new Menu("time", { onMenuOutdated: false })
  .text(
    () => new Date().toLocaleString(), // button label is current time
    (ctx) => ctx.menu.update(), // update time on button click
  );
```

> The purpose of `onMenuOutdated` is explained [below](#outdated-menus-and-fingerprints).
> You can ignore it for now.

You can also update the menu implicitly by editing the corresponding message.

```ts
const menu = new Menu("time")
  .text(
    "What's the time?",
    (ctx) => ctx.editMessageText("It is " + new Date().toLocaleString()),
  );
```

The menu will detect that you intend to edit the text of the message, and use the opportunity to update the buttons underneath too.
As a result, you can often avoid having to call `ctx.menu.update()` explicitly.

Calling `ctx.menu.update()` does not update the menu immediately.
Instead, it sets a flag and remembers to update it at some point during the execution of your middleware.
This is called _lazy updating_.
If you edit the message itself later on, the plugin can simply use the same API call to also update the buttons.
This is very efficient, and ensures that both the message and the keyboard are updated at the same time.

Naturally, if you call `ctx.menu.update()` but you never request any edits to the message, the menu plugin will update the keyboard by itself, before your middleware completes.

You can force the menu to update immediately with `await ctx.menu.update({ immediate: true })`.
Note that `ctx.menu.update()` will then return a promise, so you need to use `await`!
Using the `immediate` flag also works for all other operations that you can call on `ctx.menu`.
This should only be used when necessary.

If you want to close a menu, i.e. remove all buttons, you can call `ctx.menu.close()`.
Again, this will be performed lazily.

## Navigation Between Menus

You can easily create menus with several pages, and navigation between them.
Every page has its own instance of `Menu`.
The `submenu` button is a button that lets you navigate to other pages.
Backwards navigation is done via the `back` button.

```ts
const main = new Menu("root-menu")
  .text("Welcome", (ctx) => ctx.reply("Hi!")).row()
  .submenu("Credits", "credits-menu");

const settings = new Menu("credits-menu")
  .text("Show Credits", (ctx) => ctx.reply("Powered by grammY"))
  .back("Go Back");
```

Both buttons optionally take middleware handlers so you can react to navigation events.

Instead of using `submenu` and `back` buttons to navigate between pages, you can also do this manually using `ctx.menu.nav()`.
This function takes the menu identifier string, and will perform navigation lazily.
Analogously, backwards navigation works via `ctx.menu.back()`.

Next, you need to link the menus by registering them to one another.
Registering a menu to another implies their hierarchy. The menu that is being registered to is the parent, and the registered menu is the child.
Below, `main` is the parent of `settings`, unless a different parent is explicitly defined.
The parent menu is used when backwards navigation is performed.

```ts
// Register settings menu at main menu.
main.register(settings);
// Optionally, set a different parent.
main.register(settings, "back-from-settings-menu");
```

You can register as many menus as you like, and nest them as deeply as you like.
The menu identifiers let you jump easily to any page.

**You only have to make a single menu of your nested menu structure interactive.**
For example, only pass the root menu to `bot.use`.

```ts
// If you have this:
main.register(settings);

// Do this:
bot.use(main);

// Don't do this:
bot.use(main);
bot.use(settings);
```

**You can create multiple independent menus and make them all interactive.**
For example, if you create two unrelated menus and you never need to navigate between them, then you should install both of them independently.

```ts
// If you have independent menus like this:
const menuA = new Menu("menu-a");
const menuB = new Menu("menu-b");

// You can do this:
bot.use(menuA);
bot.use(menuB);
```

## Payloads

You can store short text payloads along with all navigation and text buttons.
When the respective handlers are invoked, the text payload will be available under `ctx.match`.
This is useful because it lets you store a little bit of data in a menu.

Here is an example menu that remembers current time in the payload.
Other use cases could be, for example, to store the index in a paginated menu.

```ts
function generatePayload() {
  return Date.now().toString();
}

const menu = new Menu("store-current-time-in-payload")
  .text(
    { text: "ABORT!", payload: generatePayload },
    async (ctx) => {
      // Give the user 5 seconds to undo.
      const text = Date.now() - Number(ctx.match) < 5000
        ? "The operation was canceled successfully."
        : "Too late. Your cat videos have already gone viral on the internet.";
      await ctx.reply(text);
    },
  );

bot.use(menu);
bot.command("publish", async (ctx) => {
  await ctx.reply("The videos will be sent. You have 5 seconds to cancel it.", {
    reply_markup: menu,
  });
});
```

::: tip Limitations
Payloads cannot be used to actually store any significant amounts of data.
The only thing you can store are short strings of typically less than 50 bytes, such as an index or an identifier.
If you really want to store user data such as a file identifier, a URL, or anything else, you should use [sessions](./session).

Also, note that the payload is always generated based on the current context object.
This means that it matters _where from_ you navigate to the menu, which can lead to surprising results.
As an example, when a menu is [outdated](#outdated-menus-and-fingerprints), it will be re-rendered _based on the button click of the outdated menu_.
:::

Payloads also work well together with dynamic ranges.

## Dynamic Ranges

So far, we've only seen how to change the text on a button dynamically.
You can also dynamically adjust the structure of a menu in order to add and remove buttons on the fly.

::: danger Changing a Menu During Message Handling
You cannot create or change your menus during message handling.
All menus must be fully created and registered before your bot starts.
This means that you cannot do `new Menu("id")` in a handler of your bot.
You cannot call `menu.text` or the like in a handler of your bot.

Adding new menus while your bot is running would cause a memory leak.
Your bot would slow down more and more, and eventually crash.

However, you can make use of the dynamic ranges described in this section.
They allow you to arbitrarily change the structure of an existing menu instance, so they are equally powerful.
Use dynamic ranges!
:::

You can let a part of a menu's buttons be generated on the fly (or all of them if you want).
We call this part of the menu a _dynamic range_.
In other words, instead of defining the buttons directly on the menu, you can pass a factory function that creates the buttons when the menu is rendered.
The easiest way to create a dynamic range in this function is by using the `MenuRange` class that this plugin provides.
A `MenuRange` provides you with exactly the same functions as a menu, but it does not have an identifier, and it cannot be registered.

```ts
const menu = new Menu("dynamic");
menu
  .url("About", "https://grammy.dev/plugins/menu").row()
  .dynamic(() => {
    // Generate a part of the menu dynamically!
    const range = new MenuRange();
    for (let i = 0; i < 3; i++) {
      range
        .text(i.toString(), (ctx) => ctx.reply(`You chose ${i}`))
        .row();
    }
    return range;
  })
  .text("Cancel", (ctx) => ctx.deleteMessage());
```

The range builder function that you pass to `dynamic` may be `async`, so you can even read data from an API or a database before returning your new menu range.
**In many cases, it makes sense to generate a dynamic range based on [session](./session) data.**

The range builder function takes a context object as the first argument.
(This is not specified in the example above.)
Optionally, as a second argument after `ctx`, you can receive a fresh instance of `MenuRange`.
You can modify it instead of returning your own instance if that's what you prefer.
Here is how you can use the two parameters of the range builder function.

```ts
menu.dynamic((ctx, range) => {
  for (const text of ctx.session.items) {
    range // no need for `new MenuRange()` or a `return`
      .text(text, (ctx) => ctx.reply(text))
      .row();
  }
});
```

It is important that your factory function works in a certain way, otherwise your menus may show strange behavior or even throw errors.
As menus are always [rendered twice](#how-does-it-work) (once when the menu is sent, and once when a button is pressed), you need to make sure that:

1. **You do not have any side-effects in the function that builds the dynamic range.**
   Do not send messages.
   Do not write to the session data.
   Do not change any variables outside of the function.
   Check out [Wikipedia on side-effects](https://en.wikipedia.org/wiki/Side_effect_(computer_science)).
2. **Your function is stable**, i.e. it does not depend on randomness, the current time, or other fast-changing data sources.
   It has to generate the same buttons the first and the second time the menu is rendered.
   Otherwise, the menu plugin cannot match the correct handler with the pressed button.
   Instead, it will [detect](#outdated-menus-and-fingerprints) that your menu is outdated, and refuse to call the handlers.

## Answering Callback Queries Manually

The menu plugin will call `answerCallbackQuery` automatically for its own buttons.
You can set `autoAnswer: false` if you want to disable this.

```ts
const menu = new Menu("id", { autoAnswer: false });
```

You will now have to call `answerCallbackQuery` yourself.
This allows you to pass custom messages that are displayed to the user.

## Outdated Menus and Fingerprints

Let's say you have a menu where a user can toggle notifications on and off, such as in the example [up here](#dynamic-labels).
Now, if a user sends `/settings` twice, they will get the same menu twice.
But, changing the notification setting on one of the two messages will not update the other!

It is clear that we cannot keep track of all settings messages in a chat, and update all old menus across the entire chat history.
You would have to use so many API calls for this that Telegram would rate-limit your bot.
You would also require a lot of storage to remember all of the message identifiers of every menu, across all chats.
This is not practical.

The solution is to check if a menu is outdated _before_ performing any action.
This way, we will only update old menus if a user actually starts clicking the buttons on them.
The menu plugin handles this automatically for you, so you don't need to worry about it.

You can configure exactly what happens when an outdated menu is detected.
By default, the message "Menu was outdated, try again!" will be displayed to the user, and the menu will be updated.
You can define custom behavior in the config under `onMenuOutdated`.

```ts
// Custom message to be displayed
const menu0 = new Menu("id", { onMenuOutdated: "Updated, try now." });
// Custom handler function
const menu1 = new Menu("id", {
  onMenuOutdated: async (ctx) => {
    await ctx.answerCallbackQuery();
    await ctx.reply("Here is a fresh menu", { reply_markup: menu1 });
  },
});
// Completely disable outdated check (may run wrong button handlers).
const menu2 = new Menu("id", { onMenuOutdated: false });
```

We have a heuristic to check if the menu is outdated.
We consider it outdated if:

- The shape of the menu changed (number of rows, or number of buttons in any row).
- The row/column position of the pressed button is out of range.
- The label on the pressed button changed.
- The pressed button does not contain a handler.

It is possible that your menu changes, while all of the above things stay the same.
It is also possible that your menu does not change fundamentally (i.e. the behavior of the handlers does not change), even though the above heuristic indicates that the menu is outdates.
Both scenarios are unlikely to happen for most bots, but if you are creating a menu where this is the case, you should use a fingerprint function.

```ts
function ident(ctx: Context): string {
  // Return a string that would change if and only if your menu changes
  // so significantly that it should be considered outdated.
  return ctx.session.myStateIdentifier;
}
const menu = new Menu("id", { fingerprint: (ctx) => ident(ctx) });
```

The fingerprint string will replace the above heuristic.
This way, you can be sure that outdated menus are always detected.

## How Does It Work

The menu plugin works completely without storing any data.
This is important for large bots with millions of users.
Saving the state of all menus would consume too much memory.

When you create your menu objects and link them together via `register` calls, no menus are actually built.
Instead, the menu plugin will remember how to assemble new menus based on your operations.
Whenever a menu is sent, it will replay these operations to render your menu.
This includes laying out all dynamic ranges and generating all dynamic labels.
Once the menu is sent, the rendered button array will be forgotten again.

When a menu is sent, every button contains callback query that stores:

- The menu identifier.
- The row/column position of the button.
- An optional payload.
- A fingerprint flag that stores whether or not a fingerprint was used in the menu.
- A 4-byte hash that encodes either the fingerprint, or the menu layout and the button label.

That way, we can identify exactly which button of which menu was pressed.
A menu will only handle button presses if:

- The menu identifiers match.
- The row/column is specified.
- The fingerprint flag exists.

When a user presses a menu's button, we need to find the handler that was added to that button at the time the menu was rendered.
Hence, we simply render the old menu again.
However, this time, we don't actually need the full layout---all we need is the overall structure, and that one specific button.
Consequently, the menu plugin will perform a shallow rendering in order to be more efficient.
In other words, the menu will only be rendered partially.

Once the pressed button is known again (and we have checked that the menu is not [outdated](#outdated-menus-and-fingerprints)), we invoke the handler.

Internally, the menu plugin makes heavy use of [API Transformer Functions](../advanced/transformers), for example, to quickly render outgoing menus on the fly.

When you register the menus in a large navigation hierarchy, they will in fact not store these references explicitly.
Under the hood, all menus of that one structure are added to the same large pool, and that pool is shared across all contained instances.
Every menu is responsible for every other one in the index, and they can handle and render each other.
(Most often, it is only the root menu that is actually passed to `bot.use` and that receives any updates.
In such cases, this one instance will handle the complete pool.)
As a result, you are able to navigate between arbitrary menus without limit, all while the update handling can happen in [`O(1)` time complexity](https://en.wikipedia.org/wiki/Time_complexity#Constant_time) because there is no need to search through entire hierarchies to find the right menu to handle any given button click.

## Plugin Summary

- Name: `menu`
- [Source](https://github.com/grammyjs/menu)
- [Reference](/ref/menu/)
</file>

<file path="site/docs/plugins/middlewares.md">
---
prev: false
next: false
---

# Set of useful middlewares

I kept rewriting the same middlewares again and again for all of my bots so I decided to extract them all to a separate package.

## Installation

`yarn add grammy-middlewares`

## Usage

All the middleware accessors are factories, even though not all of them have to be.
I decided to make API homogeneous.

Some of the factories consume optional or required parameters.

```ts
import {
  ignoreOld,
  onlyAdmin,
  onlyPublic,
  onlySuperAdmin,
  sequentialize,
} from "grammy-middlewares";

// ...

bot.use(
  ignoreOld(),
  onlyAdmin((ctx) => ctx.reply("Only admins can do this")),
  onlyPublic((ctx) => ctx.reply("You can only use public chats")),
  onlySuperAdmin(env.SUPER_ADMIN_ID),
  sequentialize(),
);
```

## Middlewares

### `ignoreOld`

Ignores old updates, useful when bot has been down for a while.
You can optionally specify the timeout in seconds which defaults to `5 * 60`.

### `onlyAdmin`

Checks if the user is an admin.
You can optionally specify `errorHandler` that is called with the context if the user is not an admin.

### `onlyPublic`

Checks if it is a group chat or a channel.
You can optionally specify `errorHandler` that is called with the context if it is not a group chat or a channel.

### `onlySuperAdmin`

Checks if the user is a super admin.
You have to provide the super admin id.

### `sequentialize`

The basic [sequentialize](../advanced/scaling#concurrency-is-hard) middleware that takes the chat id as a sequential identifier.

## Plugin Summary

- Name: `grammy-middlewares`
- [Source](https://github.com/backmeupplz/grammy-middlewares)
- Reference: <https://github.com/backmeupplz/grammy-middlewares>
</file>

<file path="site/docs/plugins/parse-mode.md">
---
prev: false
next: false
---

# Parse Mode Plugin (`parse-mode`)

This plugin provides a transformer for setting default `parse_mode`, and a middleware for hydrating `Context` with familiar `reply` variant methods - i.e. `replyWithHTML`, `replyWithMarkdown`, etc.

## Usage (Improving Formatting Experience)

::: code-group

```ts [TypeScript]
import { Bot, Context } from "grammy";
import { bold, fmt, hydrateReply, italic, link } from "@grammyjs/parse-mode";

import type { ParseModeFlavor } from "@grammyjs/parse-mode";

const bot = new Bot<ParseModeFlavor<Context>>("");

// Install the plugin.
bot.use(hydrateReply);

bot.command("demo", async (ctx) => {
  await ctx.replyFmt(fmt`${bold("bold!")}
${bold(italic("bitalic!"))}
${bold(fmt`bold ${link("blink", "example.com")} bold`)}`);

  // fmt can also be called like any other function.
  await ctx.replyFmt(
    fmt(
      ["", " and ", " and ", ""],
      fmt`${bold("bold")}`,
      fmt`${bold(italic("bitalic"))}`,
      fmt`${italic("italic")}`,
    ),
  );
});

bot.start();
```

```js [JavaScript]
const { Bot, Context } = require("grammy");
const { bold, fmt, hydrateReply, italic, link } = require(
  "@grammyjs/parse-mode",
);

const bot = new Bot("");

// Install the plugin.
bot.use(hydrateReply);

bot.command("demo", async (ctx) => {
  await ctx.replyFmt(fmt`${bold("bold!")}
${bold(italic("bitalic!"))}
${bold(fmt`bold ${link("blink", "example.com")} bold`)}`);

  // fmt can also be called like any other function.
  await ctx.replyFmt(
    fmt(
      ["", " and ", " and ", ""],
      fmt`${bold("bold")}`,
      fmt`${bold(italic("bitalic"))}`,
      fmt`${italic("italic")}`,
    ),
  );
});

bot.start();
```

```ts [Deno]
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
  bold,
  fmt,
  hydrateReply,
  italic,
  link,
} from "https://deno.land/x/grammy_parse_mode/mod.ts";

import type { ParseModeFlavor } from "https://deno.land/x/grammy_parse_mode/mod.ts";

const bot = new Bot<ParseModeFlavor<Context>>("");

// Install the plugin.
bot.use(hydrateReply);

bot.command("demo", async (ctx) => {
  await ctx.replyFmt(fmt`${bold("bold!")}
${bold(italic("bitalic!"))}
${bold(fmt`bold ${link("blink", "example.com")} bold`)}`);

  // fmt can also be called like any other function.
  await ctx.replyFmt(
    fmt(
      ["", " and ", " and ", ""],
      fmt`${bold("bold")}`,
      fmt`${bold(italic("bitalic"))}`,
      fmt`${italic("italic")}`,
    ),
  );
});

bot.start();
```

:::

## Usage (Default Parse Mode and Reply Methods)

::: code-group

```ts [TypeScript]
import { Bot, Context } from "grammy";
import { hydrateReply, parseMode } from "@grammyjs/parse-mode";

import type { ParseModeFlavor } from "@grammyjs/parse-mode";

const bot = new Bot<ParseModeFlavor<Context>>("");

// Install the plugin.
bot.use(hydrateReply);

// Sets default parse_mode for ctx.reply
bot.api.config.use(parseMode("MarkdownV2"));

bot.command("demo", async (ctx) => {
  await ctx.reply("*This* is _the_ default `formatting`");
  await ctx.replyWithHTML(
    "<b>This</b> is <i>withHTML</i> <code>formatting</code>",
  );
  await ctx.replyWithMarkdown("*This* is _withMarkdown_ `formatting`");
  await ctx.replyWithMarkdownV1("*This* is _withMarkdownV1_ `formatting`");
  await ctx.replyWithMarkdownV2("*This* is _withMarkdownV2_ `formatting`");
});

bot.start();
```

```js [JavaScript]
const { Bot, Context } = require("grammy");
const { hydrateReply, parseMode } = require("@grammyjs/parse-mode");

const bot = new Bot("");

// Install the plugin.
bot.use(hydrateReply);

// Set the default parse mode for ctx.reply.
bot.api.config.use(parseMode("MarkdownV2"));

bot.command("demo", async (ctx) => {
  await ctx.reply("*This* is _the_ default `formatting`");
  await ctx.replyWithHTML(
    "<b>This</b> is <i>withHTML</i> <code>formatting</code>",
  );
  await ctx.replyWithMarkdown("*This* is _withMarkdown_ `formatting`");
  await ctx.replyWithMarkdownV1("*This* is _withMarkdownV1_ `formatting`");
  await ctx.replyWithMarkdownV2("*This* is _withMarkdownV2_ `formatting`");
});

bot.start();
```

```ts [Deno]
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
  hydrateReply,
  parseMode,
} from "https://deno.land/x/grammy_parse_mode/mod.ts";

import type { ParseModeFlavor } from "https://deno.land/x/grammy_parse_mode/mod.ts";

const bot = new Bot<ParseModeFlavor<Context>>("");

// Install the plugin.
bot.use(hydrateReply);

// Set the default parse mode for ctx.reply.
bot.api.config.use(parseMode("MarkdownV2"));

bot.command("demo", async (ctx) => {
  await ctx.reply("*This* is _the_ default `formatting`");
  await ctx.replyWithHTML(
    "<b>This</b> is <i>withHTML</i> <code>formatting</code>",
  );
  await ctx.replyWithMarkdown("*This* is _withMarkdown_ `formatting`");
  await ctx.replyWithMarkdownV1("*This* is _withMarkdownV1_ `formatting`");
  await ctx.replyWithMarkdownV2("*This* is _withMarkdownV2_ `formatting`");
});

bot.start();
```

:::

## Plugin Summary

- Name: `parse-mode`
- [Source](https://github.com/grammyjs/parse-mode)
- [Reference](/ref/parse-mode/)
</file>

<file path="site/docs/plugins/ratelimiter.md">
---
prev: false
next: false
---

# Rate Limit Users (`ratelimiter`)

ratelimiter is a rate-limiting middleware for Telegram bots made with grammY or [Telegraf](https://github.com/telegraf/telegraf) bot frameworks.
In simple terms, it is a plugin that helps you deflect heavy spamming in your bots.
To understand ratelimiter better, you can take a look at the following illustration:

![ratelimiter's role in deflecting spam](/images/ratelimiter-role.png)

## How Does It Work Exactly?

Under normal circumstances every request will be processed and answered by your bot which means spamming it will not be that difficult.
Each user might send multiple requests per second and your script has to process each request, but how can you stop it?
With ratelimiter!

::: warning Rate-Limiting Users, Not Telegram Servers!
You should note that this package **DOES NOT** rate limit the incoming requests from Telegram servers, instead, it tracks the incoming requests by `from.id` and dismisses them on arrival, so no further processing load is added to your servers.
:::

## Customizability

This plugin exposes 5 customizable options:

- `timeFrame`: The time frame during which the requests will be monitored (defaults to `1000` ms).
- `limit`: The number of requests allowed within each `timeFrame` (defaults to `1`).
- `storageClient`: The type of storage to use for keeping track of users and their requests.
  The default value is `MEMORY_STORE` which uses an in-memory [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), but you can also pass in a Redis client as well (more info at [About storageClient](#about-storageclient)).
- `onLimitExceeded`: A function that describes what to do if the user exceeds the limit (ignores the extra requests by default).
- `keyGenerator`: A function that returns a unique key generated for each user (it uses `from.id` by default).
  This key is used to identify the user, therefore it should be unique, user specific and in string format.

### About `storageClient`

The `MEMORY_STORE` or the in-memory tracking is suitable for most bots, however if you implement clustering for your bot you will not be able to use the in-memory storage effectively.
That's why the Redis option is provided as well.
You can pass a Redis client from [ioredis](https://github.com/redis/ioredis) or [redis](https://deno.land/x/redis) in case you use Deno.
In reality, any Redis driver that implements the `incr` and `pexpire` methods should work just fine.
ratelimiter is driver agnostic.

> Note: You must have redis-server **2.6.0** and above on your server to use Redis storage client with ratelimiter.
> Older versions of Redis are not supported.

## How to Use

There are two ways of using ratelimiter:

- Accepting the defaults ([Default Configuration](#default-configuration)).
- Passing a custom object containing your settings ([Manual Configuration](#manual-configuration)).

### Default Configuration

This snippet demonstrates the easiest way of using ratelimiter, which is accepting the default behavior:

::: code-group

```ts [TypeScript]
import { limit } from "@grammyjs/ratelimiter";

// Limits message handling to a message per second for each user.
bot.use(limit());
```

```js [JavaScript]
const { limit } = require("@grammyjs/ratelimiter");

// Limits message handling to a message per second for each user.
bot.use(limit());
```

```ts [Deno]
import { limit } from "https://deno.land/x/grammy_ratelimiter/mod.ts";

// Limits message handling to a message per second for each user.
bot.use(limit());
```

:::

### Manual Configuration

As mentioned earlier, you can pass an `Options` object to the `limit()` method to alter the limiter's behavior.

::: code-group

```ts [TypeScript]
import Redis from "ioredis";
import { limit } from "@grammyjs/ratelimiter";

const redis = new Redis(...);

bot.use(
  limit({
    // Allow only 3 messages to be handled every 2 seconds.
    timeFrame: 2000,
    limit: 3,

    // "MEMORY_STORE" is the default value. If you do not want to use Redis, do not pass storageClient at all.
    storageClient: redis,

    // This is called when the limit is exceeded.
    onLimitExceeded: async (ctx) => {
      await ctx.reply("Please refrain from sending too many requests!");
    },

    // Note that the key should be a number in string format such as "123456789".
    keyGenerator: (ctx) => {
      return ctx.from?.id.toString();
    },
  })
);
```

```js [JavaScript]
const Redis = require("ioredis");
const { limit } = require("@grammyjs/ratelimiter");

const redis = new Redis(...);

bot.use(
  limit({
    // Allow only 3 messages to be handled every 2 seconds.
    timeFrame: 2000,
    limit: 3,

    // "MEMORY_STORE" is the default value. If you do not want to use Redis, do not pass storageClient at all.
    storageClient: redis,

    // This is called when the limit is exceeded.
    onLimitExceeded: async (ctx) => {
      await ctx.reply("Please refrain from sending too many requests!");
    },

    // Note that the key should be a number in string format such as "123456789".
    keyGenerator: (ctx) => {
      return ctx.from?.id.toString();
    },
  })
);
```

```ts [Deno]
import { connect } from "https://deno.land/x/redis/mod.ts";
import { limit } from "https://deno.land/x/grammy_ratelimiter/mod.ts";

const redis = await connect(...);

bot.use(
  limit({
    // Allow only 3 messages to be handled every 2 seconds.
    timeFrame: 2000,
    limit: 3,

    // "MEMORY_STORE" is the default value. If you do not want to use Redis, do not pass storageClient at all.
    storageClient: redis,

    // This is called when the limit is exceeded.
    onLimitExceeded: async (ctx) => {
      await ctx.reply("Please refrain from sending too many requests!");
    },

    // Note that the key should be a number in string format such as "123456789".
    keyGenerator: (ctx) => {
      return ctx.from?.id.toString();
    },
  })
);
```

:::

As you can see in the example above, each user is allowed to send 3 requests every 2 seconds.
If said user sends more requests, the bot replies with _Please refrain from sending too many requests_.
That request will not travel further and dies immediately as we do not call [next()](../guide/middleware#the-middleware-stack) in the middleware.

> Note: To avoid flooding Telegram servers, `onLimitExceeded` is only executed once in every `timeFrame`.

Another use case would be limiting the incoming requests from a chat instead of a specific user:

::: code-group

```ts [TypeScript]
import { limit } from "@grammyjs/ratelimiter";

bot.use(
  limit({
    keyGenerator: (ctx) => {
      if (ctx.hasChatType(["group", "supergroup"])) {
        // Note that the key should be a number in string format, such as "123456789".
        return ctx.chat.id.toString();
      }
    },
  }),
);
```

```js [JavaScript]
const { limit } = require("@grammyjs/ratelimiter");

bot.use(
  limit({
    keyGenerator: (ctx) => {
      if (ctx.hasChatType(["group", "supergroup"])) {
        // Note that the key should be a number in string format, such as "123456789".
        return ctx.chat.id.toString();
      }
    },
  }),
);
```

```ts [Deno]
import { limit } from "https://deno.land/x/grammy_ratelimiter/mod.ts";

bot.use(
  limit({
    keyGenerator: (ctx) => {
      if (ctx.hasChatType(["group", "supergroup"])) {
        // Note that the key should be a number in string format, such as "123456789".
        return ctx.chat.id.toString();
      }
    },
  }),
);
```

:::

In this example, I have used `chat.id` as the unique key for rate-limiting.

## Plugin Summary

- Name: `ratelimiter`
- [Source](https://github.com/grammyjs/ratelimiter)
- [Reference](/ref/ratelimiter/)
</file>

<file path="site/docs/plugins/README.md">
# What Is a Plugin?

We want grammY to be concise and minimal, but extensible.
Why?
Because not everyone uses everything!
Plugins are designed as extra functionalities added to said pieces of software.

## Plugins in grammY

Some plugins are right **built-in** into the grammY core library because we assume that many bots need them.
This makes it easier for new users to use them, without having to install a new package first.

Most plugins are published alongside the core package of grammY, we call them **official** plugins.
They are installed from `@grammyjs/*` on npm, and they are published under the [@grammyjs](https://github.com/grammyjs) organization on GitHub.
We coordinate their releases with the releases of grammY, and we make sure that everything works well together.
Every section of the plugin docs for an official plugin has the package name in its title.
As an example, the [grammY runner](./runner) plugin (`runner`) needs to be installed via `npm install @grammyjs/runner`.
(If you are using Deno and not Node.js, you should import the plugin from <https://deno.land/x> instead, so from the `grammy_runner` module's `mod.ts` file.)

There are also a few **third-party** plugins.
Anyone can publish them.
We don't provide any guarantees that they are up to date, well-documented, or work together with other plugins.
If you want, your own third-party plugin can also be listed on the website so that more people can find out about it.

## Overview

We compiled a neat overview for you with short descriptions for each plugin.
Installing plugins is fun and easy, and we want you to know what we have in store for you.

> Click on any package name to learn more about the respective plugin.

| Plugin                                     | Package                                            | Description                                          |
| ------------------------------------------ | -------------------------------------------------- | ---------------------------------------------------- |
| [Sessions](./session)                      | _built-in_                                         | Store user data in your database                     |
| [Inline and Custom Keyboards](./keyboard)  | _built-in_                                         | Simplify building inline and custom keyboards        |
| [Media Groups](./media-group)              | _built-in_                                         | Simplify sending media groups and editing media      |
| [Inline Queries](./inline-query)           | _built-in_                                         | Easily build results for inline queries              |
| [Auto-retry](./auto-retry)                 | [`auto-retry`](./auto-retry)                       | Automatically handle rate limiting                   |
| [Conversations](./conversations)           | [`conversations`](./conversations)                 | Build powerful conversational interfaces and dialogs |
| [Chat Members](./chat-members)             | [`chat-members`](./chat-members)                   | Track which user joined which chat                   |
| [Emoji](./emoji)                           | [`emoji`](./emoji)                                 | Simplify using emoji in code                         |
| [Files](./files)                           | [`files`](./files)                                 | Easily handle files                                  |
| [Hydration](./hydrate)                     | [`hydrate`](./hydrate)                             | Call methods on objects returned from API calls      |
| [Internationalization](./i18n)             | [`i18n`](./i18n) or [`fluent`](./fluent)           | Let your bot speak multiple languages                |
| [Interactive Menus](./menu)                | [`menu`](./menu)                                   | Design dynamic button menus with flexible navigation |
| [Parse Mode](./parse-mode)                 | [`parse-mode`](./parse-mode)                       | Simplify message formatting                          |
| [Rate Limiter](./ratelimiter)              | [`ratelimiter`](./ratelimiter)                     | Automatically restrict users who spam your bot       |
| [Router](./router)                         | [`router`](./router)                               | Route messages to different parts of your code       |
| [Runner](./runner)                         | [`runner`](./runner)                               | Perform long polling concurrently and at scale       |
| [Stateless Question](./stateless-question) | [`stateless-question`](./stateless-question)       | Create dialogs without a data storage                |
| [Throttler](./transformer-throttler)       | [`transformer-throttler`](./transformer-throttler) | Slow down API calls                                  |

We also have some third-party plugins!
You can find them in the navigation menu under _Plugins_ > _Third-Party_.
Be sure to check them out, too!

## Types of Plugins in grammY

All that glitters is gold, right?
Well, a different kind of gold!
grammY can take advantage of two types of plugins: _middleware plugins_ and _transformer plugins_.
In simple terms, plugins in grammY return either a middleware function or a transformer one.
Let's talk about the differences.

### Type I: Middleware Plugins

[Middleware](../guide/middleware) is a function that handles incoming data in various forms.
Middleware plugins are plugins that are fed to a bot as---well, you guessed it---middleware.
This means that you install them via `bot.use`.

### Type II: Transformer Plugins

A [transformer function](../advanced/transformers) is the opposite of middleware!
It is a function that handles outgoing data.
Transformer plugins are plugins that are fed to a bot as a---crazy! guessed it again---transformer function.
This means that you install them via `bot.api.config.use`.

## Create Your Own Plugins

If you want to develop a plugin and share it with other users (even published on the official website of grammY), there is a [useful guide](./guide) that you can check out.

## Ideas for More Plugins

We are collecting ideas for new plugins [on GitHub in this issue](https://github.com/grammyjs/grammY/issues/110).
</file>

<file path="site/docs/plugins/router.md">
---
prev: false
next: false
---

# Router (`router`)

The `Router` class ([API Reference](/ref/router/)) provides a way to structure your bot by routing context objects to different parts of your code.
It is a more sophisticated version of `bot.route` on `Composer` ([grammY API Reference](/ref/core/composer#route)).

## Example

Here is an example of a router usage that speaks for itself.

```ts
const router = new Router((ctx) => {
  // Determine route to pick here.
  return "key";
});

router.route("key", async (ctx) => {/* ... */});
router.route("other-key", async (ctx) => {/* ... */});
router.otherwise((ctx) => {/* ... */}); // called if no route matches

bot.use(router);
```

## Integration With Middleware

Naturally, the router plugin integrates seamlessly with grammY's [middleware trees](../advanced/middleware).
For example, you filter down updates further after routing them.

```ts
router.route("key").on("message:text", async (ctx) => {/* ... */});

const other = router.otherwise();
other.on(":text", async (ctx) => {/* ... */});
other.use((ctx) => {/* ... */});
```

You may also want to revisit this [section](../guide/filter-queries#combining-queries-with-other-methods) about combining middleware handlers.

## Combining Routers With Sessions

Routers work well together with [sessions](./session).
As an example, combining the two concepts allows you to re-create forms in the chat interface.

> Note that a much better solution is to use the [conversations plugin](./conversations).
> The remainder of this page is obsolete since that plugin was created.
> We will keep this page as a reference for those who used the router for forms.

Let's say that you want to build a bot that tells users how many days are left until it is their birthday.
In order to compute the number of days, the bot has to know the month (e.g. June) and the day of month (e.g. 15) of the birthday.

The bot therefore has to ask two questions:

1. In what month is the user born?
2. What day of the month is the user born?

Only if both values are known, the bot can tell the user how many days are left.

This is how a bot like that could be implemented:

::: code-group

```ts [TypeScript]
import { Bot, Context, Keyboard, session, SessionFlavor } from "grammy";
import { Router } from "@grammyjs/router";

interface SessionData {
  step: "idle" | "day" | "month"; // which step of the form we are on
  dayOfMonth?: number; // day of birthday
  month?: number; // month of birthday
}
type MyContext = Context & SessionFlavor<SessionData>;

const bot = new Bot<MyContext>("");

// Use session.
bot.use(session({ initial: (): SessionData => ({ step: "idle" }) }));

// Define some commands.
bot.command("start", async (ctx) => {
  await ctx.reply(`Welcome!
I can tell you in how many days it is your birthday!
Send /birthday to start`);
});

bot.command("birthday", async (ctx) => {
  const day = ctx.session.dayOfMonth;
  const month = ctx.session.month;
  if (day !== undefined && month !== undefined) {
    // Information already provided!
    await ctx.reply(`Your birthday is in ${getDays(month, day)} days!`);
  } else {
    // Missing information, enter router-based form
    ctx.session.step = "day";
    await ctx.reply(
      "Please send me the day of month \
of your birthday as a number!",
    );
  }
});

// Use router.
const router = new Router<MyContext>((ctx) => ctx.session.step);

// Define step that handles the day.
const day = router.route("day");
day.on("message:text", async (ctx) => {
  const day = parseInt(ctx.msg.text, 10);
  if (isNaN(day) || day < 1 || 31 < day) {
    await ctx.reply("That is not a valid day, try again!");
    return;
  }
  ctx.session.dayOfMonth = day;
  // Advance form to step for month
  ctx.session.step = "month";
  await ctx.reply("Got it! Now, send me the month!", {
    reply_markup: {
      one_time_keyboard: true,
      keyboard: new Keyboard()
        .text("Jan").text("Feb").text("Mar").row()
        .text("Apr").text("May").text("Jun").row()
        .text("Jul").text("Aug").text("Sep").row()
        .text("Oct").text("Nov").text("Dec").build(),
    },
  });
});
day.use((ctx) => ctx.reply("Please send me the day as a text message!"));

// Define step that handles the month.
const month = router.route("month");
month.on("message:text", async (ctx) => {
  // Should not happen, unless session data is corrupted.
  const day = ctx.session.dayOfMonth;
  if (day === undefined) {
    await ctx.reply("I need your day of month!");
    ctx.session.step = "day";
    return;
  }

  const month = months.indexOf(ctx.msg.text);
  if (month === -1) {
    await ctx.reply(
      "That is not a valid month, \
please use one of the buttons!",
    );
    return;
  }

  ctx.session.month = month;
  const diff = getDays(month, day);
  await ctx.reply(
    `Your birthday is on ${months[month]} ${day}.
That is in ${diff} days!`,
    { reply_markup: { remove_keyboard: true } },
  );
  ctx.session.step = "idle";
});
month.use((ctx) => ctx.reply("Please tap one of the buttons!"));

// Define step that handles all other cases.
router.otherwise(async (ctx) => { // idle
  await ctx.reply("Send /birthday to find out how long you have to wait.");
});

bot.use(router); // register the router
bot.start();

// Date conversion utils
const months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];
function getDays(month: number, day: number) {
  const bday = new Date();
  const now = Date.now();
  bday.setMonth(month);
  bday.setDate(day);
  if (bday.getTime() < now) bday.setFullYear(bday.getFullYear() + 1);
  const diff = (bday.getTime() - now) / (1000 * 60 * 60 * 24);
  return diff;
}
```

```js [JavaScript]
const { Bot, Context, Keyboard, session, SessionFlavor } = require("grammy");
const { Router } = require("@grammyjs/router");

const bot = new Bot("");

// Use session.
bot.use(session({ initial: () => ({ step: "idle" }) }));

// Define some commands.
bot.command("start", async (ctx) => {
  await ctx.reply(`Welcome!
I can tell you in how many days it is your birthday!
Send /birthday to start`);
});

bot.command("birthday", async (ctx) => {
  const day = ctx.session.dayOfMonth;
  const month = ctx.session.month;
  if (day !== undefined && month !== undefined) {
    // Information already provided!
    await ctx.reply(`Your birthday is in ${getDays(month, day)} days!`);
  } else {
    // Missing information, enter router-based form
    ctx.session.step = "day";
    await ctx.reply(
      "Please send me the day of month \
of your birthday as a number!",
    );
  }
});

// Use router.
const router = new Router((ctx) => ctx.session.step);

// Define step that handles the day.
const day = router.route("day");
day.on("message:text", async (ctx) => {
  const day = parseInt(ctx.msg.text, 10);
  if (isNaN(day) || day < 1 || 31 < day) {
    await ctx.reply("That is not a valid day, try again!");
    return;
  }
  ctx.session.dayOfMonth = day;
  // Advance form to step for month
  ctx.session.step = "month";
  await ctx.reply("Got it! Now, send me the month!", {
    reply_markup: {
      one_time_keyboard: true,
      keyboard: new Keyboard()
        .text("Jan").text("Feb").text("Mar").row()
        .text("Apr").text("May").text("Jun").row()
        .text("Jul").text("Aug").text("Sep").row()
        .text("Oct").text("Nov").text("Dec").build(),
    },
  });
});
day.use((ctx) => ctx.reply("Please send me the day as a text message!"));

// Define step that handles the month.
const month = router.route("month");
month.on("message:text", async (ctx) => {
  // Should not happen, unless session data is corrupted.
  const day = ctx.session.dayOfMonth;
  if (day === undefined) {
    await ctx.reply("I need your day of month!");
    ctx.session.step = "day";
    return;
  }

  const month = months.indexOf(ctx.msg.text);
  if (month === -1) {
    await ctx.reply(
      "That is not a valid month, \
please use one of the buttons!",
    );
    return;
  }

  ctx.session.month = month;
  const diff = getDays(month, day);
  await ctx.reply(
    `Your birthday is on ${months[month]} ${day}.
That is in ${diff} days!`,
    { reply_markup: { remove_keyboard: true } },
  );
  ctx.session.step = "idle";
});
month.use((ctx) => ctx.reply("Please tap one of the buttons!"));

// Define step that handles all other cases.
router.otherwise(async (ctx) => { // idle
  await ctx.reply("Send /birthday to find out how long you have to wait.");
});

bot.use(router); // register the router
bot.start();

// Date conversion utils
const months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];
function getDays(month, day) {
  const bday = new Date();
  const now = Date.now();
  bday.setMonth(month);
  bday.setDate(day);
  if (bday.getTime() < now) bday.setFullYear(bday.getFullYear() + 1);
  const diff = (bday.getTime() - now) / (1000 * 60 * 60 * 24);
  return diff;
}
```

```ts [Deno]
import {
  Bot,
  Context,
  Keyboard,
  session,
  SessionFlavor,
} from "https://deno.land/x/grammy/mod.ts";
import { Router } from "https://deno.land/x/grammy_router/router.ts";

interface SessionData {
  step: "idle" | "day" | "month"; // which step of the form we are on
  dayOfMonth?: number; // day of birthday
  month?: number; // month of birthday
}
type MyContext = Context & SessionFlavor<SessionData>;

const bot = new Bot<MyContext>("");

// Use session.
bot.use(session({ initial: (): SessionData => ({ step: "idle" }) }));

// Define some commands.
bot.command("start", async (ctx) => {
  await ctx.reply(`Welcome!
I can tell you in how many days it is your birthday!
Send /birthday to start`);
});

bot.command("birthday", async (ctx) => {
  const day = ctx.session.dayOfMonth;
  const month = ctx.session.month;
  if (day !== undefined && month !== undefined) {
    // Information already provided!
    await ctx.reply(`Your birthday is in ${getDays(month, day)} days!`);
  } else {
    // Missing information, enter router-based form
    ctx.session.step = "day";
    await ctx.reply(
      "Please send me the day of month \
of your birthday as a number!",
    );
  }
});

// Use router.
const router = new Router<MyContext>((ctx) => ctx.session.step);

// Define step that handles the day.
const day = router.route("day");
day.on("message:text", async (ctx) => {
  const day = parseInt(ctx.msg.text, 10);
  if (isNaN(day) || day < 1 || 31 < day) {
    await ctx.reply("That is not a valid day, try again!");
    return;
  }
  ctx.session.dayOfMonth = day;
  // Advance form to step for month
  ctx.session.step = "month";
  await ctx.reply("Got it! Now, send me the month!", {
    reply_markup: {
      one_time_keyboard: true,
      keyboard: new Keyboard()
        .text("Jan").text("Feb").text("Mar").row()
        .text("Apr").text("May").text("Jun").row()
        .text("Jul").text("Aug").text("Sep").row()
        .text("Oct").text("Nov").text("Dec").build(),
    },
  });
});
day.use((ctx) => ctx.reply("Please send me the day as a text message!"));

// Define step that handles the month.
const month = router.route("month");
month.on("message:text", async (ctx) => {
  // Should not happen, unless session data is corrupted.
  const day = ctx.session.dayOfMonth;
  if (day === undefined) {
    await ctx.reply("I need your day of month!");
    ctx.session.step = "day";
    return;
  }

  const month = months.indexOf(ctx.msg.text);
  if (month === -1) {
    await ctx.reply(
      "That is not a valid month, \
please use one of the buttons!",
    );
    return;
  }

  ctx.session.month = month;
  const diff = getDays(month, day);
  await ctx.reply(
    `Your birthday is on ${months[month]} ${day}.
That is in ${diff} days!`,
    { reply_markup: { remove_keyboard: true } },
  );
  ctx.session.step = "idle";
});
month.use((ctx) => ctx.reply("Please tap one of the buttons!"));

// Define step that handles all other cases.
router.otherwise(async (ctx) => { // idle
  await ctx.reply("Send /birthday to find out how long you have to wait.");
});

bot.use(router); // register the router
bot.start();

// Date conversion utils
const months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];
function getDays(month: number, day: number) {
  const bday = new Date();
  const now = Date.now();
  bday.setMonth(month);
  bday.setDate(day);
  if (bday.getTime() < now) bday.setFullYear(bday.getFullYear() + 1);
  const diff = (bday.getTime() - now) / (1000 * 60 * 60 * 24);
  return diff;
}
```

:::

Note how the session has a property `step` that stores the step of the form, i.e. which value is currently being filled.
The router is used to jump between different middleware that completes both the `month` and the `dayOfMonth` fields on the session.
If both values are known, the bot computes the remaining days and sends it back to the user.

## Plugin Summary

- Name: `router`
- [Source](https://github.com/grammyjs/router)
- [Reference](/ref/router/)
</file>

<file path="site/docs/plugins/runner.md">
---
prev: false
next: false
---

# Concurrency With grammY runner (`runner`)

This package can be used if you run your bot [using long polling](../guide/deployment-types), and you want messages to be processed concurrently.

> Make sure to understand [Scaling Up II](../advanced/scaling#long-polling) before you use grammY runner.

## Why We Need a Bot Runner

If you are hosting your bot using long polling and you want to make it scale up, there is no way around processing updates concurrently as sequential update processing is way too slow.
As a result, bots face a number of challenges.

- Are there race conditions?
- Can we still `await` the middleware stack? We must have this for error handling!
- What if middleware never resolves for some reason, does this block the bot?
- Can we process some selected updates in sequence?
- Can we constrain the server load?
- Can we process updates on multiple cores?

As you can see, we need a solution that can solve all of the above problems to achieve proper long polling for a bot.
This is a problem that is very distinct from composing middleware or sending messages to Telegram.
Consequently, it is not solved by the grammY core package.
Instead, you can use [grammY runner](https://github.com/grammyjs/runner).
It has its own [API Reference](/ref/runner/), too.

## Usage

Here is a simple example.

::: code-group

```ts [TypeScript]
import { Bot } from "grammy";
import { run } from "@grammyjs/runner";

// Create a bot.
const bot = new Bot("");

// Add the usual middleware, yada yada
bot.on("message", (ctx) => ctx.reply("Got your message."));

// Run it concurrently!
run(bot);
```

```js [JavaScript]
const { Bot } = require("grammy");
const { run } = require("@grammyjs/runner");

// Create a bot.
const bot = new Bot("");

// Add the usual middleware, yada yada
bot.on("message", (ctx) => ctx.reply("Got your message."));

// Run it concurrently!
run(bot);
```

```ts [Deno]
import { Bot } from "https://deno.land/x/grammy/mod.ts";
import { run } from "https://deno.land/x/grammy_runner/mod.ts";

// Create a bot.
const bot = new Bot("");

// Add the usual middleware, yada yada
bot.on("message", (ctx) => ctx.reply("Got your message."));

// Run it concurrently!
run(bot);
```

:::

## Sequential Processing Where Necessary

Most likely, you want to be guaranteed that messages from the same chat are processed in order.
This is useful when installing [session middleware](./session), but it also makes sure that your bot does not confuse the order of messages in the same chat.

grammY runner exports the `sequentialize` middleware that takes care of this.
You can check out this [section](../advanced/scaling#concurrency-is-hard) to learn how to use it.

We are now going to look at more advanced usage of the plugin.

The supplied constraint function can be used not only to specify chat identifier, or user identifier.
Instead, you can return _a list of constraint identifier strings_ that determine for every update individually what other computations it must wait for before processing can begin.

As an example, you could return both the chat identifier, and the user identifier of the message author.

```ts
bot.use(sequentialize((ctx) => {
  const chat = ctx.chat?.id.toString();
  const user = ctx.from?.id.toString();
  return [chat, user].filter((con) => con !== undefined);
}));
```

This would make sure that messages in the same chat are ordered correctly.
In addition, if Alice sends message in a group, and then sends a message to your bot in the private chat, then these two messages are ordered correctly.

In a sense, you can therefore specify a graph of dependencies between updates.
grammY runner will resolve all necessary constraints on the fly and block those updates as long as necessary to ensure correct message ordering.

The implementation of this is very efficient.
It needs constant memory (unless you specify infinite concurrency), and it needs (amortized) constant processing time per update.

## Graceful Shutdown

In order for the bot to complete its work correctly, you [should signal it](../advanced/reliability#using-grammy-runner) to stop when the process is about to be destroyed.

Note that you can wait for the runner to terminate by `await`ing the `task` in the [`RunnerHandle`](/ref/runner/runnerhandle) returned from `run`.

```ts
const handle = run(bot);

// This will get called when the bot stops.
handle.task().then(() => {
  console.log("Bot done processing!");
});

// Later, stop the bot via the handle of the runner.
await handle.stop();
```

## Advanced Options

grammY runner consists of three things: a source, a sink, and a runner.
The source pulls in updates, the sink consumes updates, and the runner configures and connects the two.

> An in-depth description on how the runner works internally can be found [down here](#how-it-works-behind-the-scenes).

Each of these three parts can be configured through various options.
This can reduce the network traffic, let you specify allowed updates, and more.

Each part of the runner accepts its configuration through a dedicated options object.

```ts
run(bot, {
  source: {},
  runner: {},
  sink: {},
});
```

You should check out the `RunOptions` in the [API reference](/ref/runner/runoptions) to see which options are available.

For example, you will there find out that `allowed_updates` can be enabled using the following code snippet.

```ts
run(bot, { runner: { fetch: { allowed_updates: [] } } });
```

## Multithreading

> There is no point to multithreading if your bot does not process at least 50 million updates per day (>500 per second).
> [Skip this section](#how-it-works-behind-the-scenes) if your bot handles less traffic than that.

JavaScript is single-threaded.
This is amazing because [concurrency is hard](../advanced/scaling#concurrency-is-hard), meaning that if there is only a single thread, a lot of headache is naturally removed.

However, if your bot has an extremely high load (we are talking about 1000 updates per second and up), then doing everything on a single core might not be enough anymore.
Basically, a single core will start struggling with the JSON processing of all the messages your bot has to handle.

### Bot Workers for Update Handling

There is a simple way out: bot workers!
grammY runner lets you create several workers which can process your updates in parallel on actually different cores (using different event loops and with separate memory).

On Node.js, grammY runner uses [Worker Threads](https://nodejs.org/api/worker_threads.html).
On Deno, grammY runner uses [Web Workers](https://docs.deno.com/runtime/reference/web_platform_apis/).

Conceptually, grammY runner provides you with a class called `BotWorker` which can handle updates.
It is equivalent to the regular class `Bot` (in fact, it even `extends Bot`).
The main difference between `BotWorker` and `Bot` is that `BotWorker` cannot fetch updates.
Instead, it has to receive them from a regular `Bot` that controls its workers.

```asciiart:no-line-numbers
1. fetch updates                                 Bot
                                              __// \\__
                                           __/  /   \  \__
2. send updates to workers              __/    /     \    \__
                                     __/      /       \      \__
                                    /        /         \        \
3. process updates          BotWorker   BotWorker   BotWorker   BotWorker
```

grammY runner provides you with middleware that can send updates to bot workers.
The bot workers can then receive this update and handle it.
This way, the central bot only has to concern itself with pulling in and distributing updates among the bot workers it orchestrates.
The actual update handling (filtering messages, sending replies, etc.) is performed by the bot workers.

Let's now see how this can be used.

### Using Bot Workers

> Examples of this can be found in the [grammY runner repository](https://github.com/grammyjs/runner/tree/main/examples).

We will start out by creating the central bot instance that fetches updates and distributes them among workers.
Let's start by creating a file called `bot.ts` with the following content.

::: code-group

```ts [TypeScript]
// bot.ts
import { Bot } from "grammy";
import { distribute, run } from "@grammyjs/runner";

// Create the bot.
const bot = new Bot(""); // <-- put your bot token between the ""

// Optionally, sequentialize updates here.
// bot.use(sequentialize(...))

// Distribute the updates among bot workers.
bot.use(distribute(__dirname + "/worker"));

// Run the bot concurrently with multi-threading.
run(bot);
```

```js [JavaScript]
// bot.js
const { Bot } = require("grammy");
const { distribute, run } = require("@grammyjs/runner");

// Create the bot.
const bot = new Bot(""); // <-- put your bot token between the ""

// Optionally, sequentialize updates here.
// bot.use(sequentialize(...))

// Distribute the updates among bot workers.
bot.use(distribute(__dirname + "/worker"));

// Run the bot concurrently with multi-threading.
run(bot);
```

```ts [Deno]
// bot.ts
import { Bot } from "https://deno.land/x/grammy/mod.ts";
import { distribute, run } from "https://deno.land/x/grammy_runner/mod.ts";

// Create the bot.
const bot = new Bot(""); // <-- put your bot token between the ""

// Optionally, sequentialize updates here.
// bot.use(sequentialize(...))

// Distribute the updates among bot workers.
bot.use(distribute(new URL("./worker.ts", import.meta.url)));

// Run the bot concurrently with multi-threading.
run(bot);
```

:::

Next to `bot.ts`, we create a second file called `worker.ts` (as specified on line 12 in the code above).
This will contain the actual bot logic.

::: code-group

```ts [TypeScript]
// worker.ts
import { BotWorker } from "@grammyjs/runner";

// Create a new bot worker.
const bot = new BotWorker(""); // <-- pass your bot token here again

// Add message handling logic.
bot.on("message", (ctx) => ctx.reply("yay!"));
```

```js [JavaScript]
// worker.js
const { BotWorker } = require("@grammyjs/runner");

// Create a new bot worker.
const bot = new BotWorker(""); // <-- pass your bot token here again

// Add message handling logic.
bot.on("message", (ctx) => ctx.reply("yay!"));
```

```ts [Deno]
// worker.ts
import { BotWorker } from "https://deno.land/x/grammy_runner/mod.ts";

// Create a new bot worker.
const bot = new BotWorker(""); // <-- pass your bot token here again

// Add message handling logic.
bot.on("message", (ctx) => ctx.reply("yay!"));
```

:::

> Note that each worker is able to send messages back to Telegram.
> This is why you must give your bot token to each worker, too.

You do not have to start the bot workers, or export anything from the file.
It is enough to create an instance of `BotWorker`.
It will listen for updates automatically.

It is important to understand that **only the raw updates** are sent to bot workers.
In other words, the [context objects](../guide/context) are created twice for each update: once in `bot.ts` so it can be distributed to a bot worker, and once in `worker.ts` so it can actually be handled.
What's more: the properties that are installed on the context object in `bot.ts` are not sent to the bot workers.
This means that all plugins must be installed in the bot workers.

::: tip Distribute Only Some Updates
As a performance optimization, you can drop updates that you do not want to handle.
That way, your bot does not have to send the update to a worker, only for it to be ignored there.

::: code-group

```ts [Node.js]
// Our bot only handles messages, edits, and callback queries,
// so we can ignore all other updates and not distribute them.
bot.on(
  ["message", "edited_message", "callback_query"],
  distribute(__dirname + "/worker"),
);
```

```ts [Deno]
// Our bot only handles messages, edits, and callback queries,
// so we can ignore all other updates and not distribute them.
bot.on(
  ["message", "edited_message", "callback_query"],
  distribute(new URL("./worker.ts", import.meta.url)),
);
```

:::

By default, `distribute` creates 4 bot workers.
You can easily adjust this number.

```ts
// Distribute updates among 8 bot workers.
bot.use(distribute(workerFile, { count: 8 }));
```

Note that your application should never spawn more threads than there are physical cores on your CPU.
This will not improve performance, but rather degrade it.

## How It Works Behind the Scenes

Of course, while using grammY runner looks very simple, a lot is going on under the hood.

Every runner consists of three different parts.

1. The **source** pulls in updates from Telegram.
2. The **sink** supplies the bot instance with updates.
3. The **runner** component connects source and sink, and allows you to start and stop your bot.

```asciiart:no-line-numbers
api.telegram.org <—> source <—> runner <—> sink <—> bot
```

### Source

grammY runner ships with one default source that can operate on any `UpdateSupplier` ([API reference](/ref/runner/updatesupplier)).
Such an update supplier is straightforward to create from a bot instance.
If you want make one yourself, be sure to check out `createUpdateFetcher` ([API reference](/ref/runner/createupdatefetcher)).

The source is an async iterator of update batches, but it can be active or inactive, and you can `close` it in order to disconnect from the Telegram servers.

### Sink

grammY runner ships with three possible sink implementations, a sequential one (same behavior as `bot.start()`), a batched one (mainly useful for backwards compatibility with other frameworks), and a fully concurrent one (used by `run`).
All of them operate on `UpdateConsumer` objects ([API reference](/ref/runner/updateconsumer)) which are straightforward to create from a bot instance.
If you want make one yourself, be sure to check out `handleUpdate` on the `Bot` instance of grammY ([API reference](/ref/core/bot#handleupdate)).

The sink contains a queue ([API reference](/ref/runner/decayingdeque)) of individual updates that are currently being processed.
Adding new updates to the queue will immediately make the update consumer handle them, and return a promise that resolves as soon as there is capacity in the queue again.
The resolved integral number determines the free space.
Setting a concurrency limit for the grammY runner is therefore respected through the underlying queue instance.

The queue also throws out updates that take too long processing, and you can specify a `timeoutHandler` when creating the respective sink.
Of course, you should also provide an error handler when creating a sink.

If you're using `run(bot)`, the error handler from `bot.catch` will be used.

### Runner

The runner is a plain loop that pulls in updates from the source and supplies them to the sink.
Once the sink has space again, the runner will fetch the next batch of updates from the source.

When you create a runner with `createRunner` ([API reference](/ref/runner/createrunner)), you obtain a handle that you can use to control the runner.
For instance, it allows you start and stop it, or obtain a promise that resolves if the runner stops.
(This handle is also returned by `run`.)
Check out the [API reference](/ref/runner/runnerhandle) of the `RunnerHandle`.

### The `run` Function

The `run` function does a few things to help you use the above structure with ease.

1. It creates an update supplier from your bot.
2. It creates a [source](#source) from the update supplier.
3. It creates an update consumer from your bot.
4. It creates a [sink](#sink) from the update consumer.
5. It creates a [runner](#runner) from the source and the sink.
6. It starts the runner.

The handle of the created runner is returned, which lets you control the runner.

## Plugin Summary

- Name: `runner`
- [Source](https://github.com/grammyjs/runner)
- [Reference](/ref/runner/)
</file>

<file path="site/docs/plugins/session.md">
---
prev: false
next: false
---

# Sessions and Storing Data (built-in)

While you can always just write you own code to connect to a data storage of your choice, grammY supports a very convenient storage pattern called _sessions_.

> [Jump down](#how-to-use-sessions) if you know how sessions work.

## Why Must We Think About Storage?

In opposite to regular user accounts on Telegram, bots have [limited cloud storage](https://core.telegram.org/bots#how-are-bots-different-from-users) in the Telegram cloud.
As a result, there are a few things you cannot do with bots:

1. You cannot access old messages that your bot received.
2. You cannot access old messages that your bot sent.
3. You cannot get a list of all chats with your bot.
4. More things, e.g. no media overview, etc

Basically, it boils down to the fact that **a bot only has access to the information of the currently incoming update** (e.g. message), i.e. the information that is available on the context object `ctx`.

Consequently, if you _do want to access_ old data, you have to store it as soon as it arrives.
This means that you must have a data storage, such as a file, a database, or an in-memory storage.

Of course, grammY has you covered here: you don't have to host this yourself.
You can just use the grammY session storage which needs zero setup and is free forever.

> Naturally, there are plenty of other services that offer data storage as a service, and grammY integrates seamlessly with them, too.
> If you want to run your own database, rest assured that grammY supports this equally well.
> [Scroll down](#known-storage-adapters) to see which integrations are currently available.

## What Are Sessions?

It is a very common thing for bots to store some piece of data per chat.
For example, let's say we want to build a bot that counts the number of times that a message contains the pizza emoji :pizza: in its text.
This bot could be added to a group, and it can tell you how much you and your friends like pizza.

When our pizza bot receives a message, it has to remember how many times it saw a :pizza: in that chat before.
Your pizza count should of course not change when your sister adds the pizza bot to her group chat, so what we really want is to store _one counter per chat_.

Sessions are an elegant way to store data _per chat_.
You would use the chat identifier as the key in your database, and a counter as the value.
In this case, we would call the chat identifier the _session key_.
(You can read more about session keys [down here](#session-keys).)
Effectively, your bot will store a map from a chat identifier to some custom session data, i.e. something like this:

```json
{
  "424242": { "pizzaCount": 24 },
  "987654": { "pizzaCount": 1729 }
}
```

> When we say database, we really mean any data storage solution.
> This includes files, cloud storage, or anything else.

Okay, but what are sessions now?

We can install middleware on the bot that will provide a chat's session data on `ctx.session` for every update.
The installed plugin will do something before and after our handlers are called:

1. **Before our middleware.**
   The session plugin loads the session data for the current chat from the database.
   It stores the data on the context object under `ctx.session`.
2. **Our middleware runs.**
   We can _read_ `ctx.session` to inspect which value was in the database.
   For example, if a message is sent to the chat with the identifier `424242`, it would be `ctx.session = { pizzaCount: 24 }` while our middleware runs (at least with the example database state above).
   We can also _modify_ `ctx.session` arbitrarily, so we can add, remove, and change fields as we like.
3. **After our middleware.**
   The session middleware makes sure that the data is written back to the database.
   Whatever the value of `ctx.session` is after the middleware is done executing, it will be saved in the database.

As a result, we never have to worry about actually communicating with the data storage anymore.
We just modify the data in `ctx.session`, and the plugin will take care of the rest.

## When to Use Sessions

> [Skip ahead](#how-to-use-sessions) if you already know that you want to use sessions.

You may think, this is great, I never have to worry about databases again!
And you are right, sessions are an ideal solution---but only for some types of data.

In our experience, there are use cases where sessions truly shine.
On the other hand, there are cases where a traditional database may be better suited.

This comparison may help you decide whether to use sessions or not.

|                     | Sessions                                                    | Database                                                           |
| ------------------- | ----------------------------------------------------------- | ------------------------------------------------------------------ |
| _Access_            | one isolated storage **per chat**                           | access same data from **multiple chats**                           |
| _Sharing_           | data is **only used by bot**                                | data is **used by other systems** (e.g. by a connected web server) |
| _Format_            | any JavaScript objects: strings, numbers, arrays, and so on | any data (binary, files, structured, etc)                          |
| _Size per chat_     | preferably less than ~3 MB per chat                         | any size                                                           |
| _Exclusive feature_ | Required by some grammY plugins.                            | Supports database transactions.                                    |

This does not mean that things _cannot work_ if you pick sessions/databases over the other.
For example, you can of course store large binary data in your session.
However, your bot would not perform as well as it could otherwise, so we recommend using sessions only where they make sense.

## How to Use Sessions

You can add session support to grammY by using the built-in session middleware.

### Example Usage

Here is an example bot that counts messages containing a pizza emoji :pizza::

::: code-group

```ts [TypeScript]
import { Bot, Context, session, SessionFlavor } from "grammy";

// Define the shape of our session.
interface SessionData {
  pizzaCount: number;
}

// Flavor the context type to include sessions.
type MyContext = Context & SessionFlavor<SessionData>;

const bot = new Bot<MyContext>("");

// Install session middleware, and define the initial session value.
function initial(): SessionData {
  return { pizzaCount: 0 };
}
bot.use(session({ initial }));

bot.command("hunger", async (ctx) => {
  const count = ctx.session.pizzaCount;
  await ctx.reply(`Your hunger level is ${count}!`);
});

bot.hears(/.*🍕.*/, (ctx) => ctx.session.pizzaCount++);

bot.start();
```

```js [JavaScript]
const { Bot, session } = require("grammy");

const bot = new Bot("");

// Install session middleware, and define the initial session value.
function initial() {
  return { pizzaCount: 0 };
}
bot.use(session({ initial }));

bot.command("hunger", async (ctx) => {
  const count = ctx.session.pizzaCount;
  await ctx.reply(`Your hunger level is ${count}!`);
});

bot.hears(/.*🍕.*/, (ctx) => ctx.session.pizzaCount++);

bot.start();
```

```ts [Deno]
import {
  Bot,
  Context,
  session,
  SessionFlavor,
} from "https://deno.land/x/grammy/mod.ts";

// Define shape of our session.
interface SessionData {
  pizzaCount: number;
}

// Flavor the context type to include sessions.
type MyContext = Context & SessionFlavor<SessionData>;

const bot = new Bot<MyContext>("");

// Install session middleware, and define the initial session value.
function initial(): SessionData {
  return { pizzaCount: 0 };
}
bot.use(session({ initial }));

bot.command("hunger", async (ctx) => {
  const count = ctx.session.pizzaCount;
  await ctx.reply(`Your hunger level is ${count}!`);
});

bot.hears(/.*🍕.*/, (ctx) => ctx.session.pizzaCount++);

bot.start();
```

:::

Note how we also have to [adjust the context type](../guide/context#customizing-the-context-object) to make the session available on it.
The context flavor is called `SessionFlavor`.

### Initial Session Data

When a user first contacts your bot, no session data is available for them.
It is therefore important that you specify the `initial` option for the session middleware.
Pass a function that generates a new object with initial session data for new chats.

```ts
// Creates a new object that will be used as initial session data.
function createInitialSessionData() {
  return {
    pizzaCount: 0,
    // more data here
  };
}
bot.use(session({ initial: createInitialSessionData }));
```

Same but much shorter:

```ts
bot.use(session({ initial: () => ({ pizzaCount: 0 }) }));
```

::: warning Sharing Objects
Make sure to always create a _new object_.
Do **NOT** do this:

```ts
// DANGER, BAD, WRONG, STOP
const initialData = { pizzaCount: 0 }; // NOPE
bot.use(session({ initial: () => initialData })); // EVIL
```

If you would do this, several chats might share the same session object in memory.
Hence, changing the session data in one chat may accidentally impact the session data in the other chat.
:::

You may also omit the `initial` option entirely, even though you are well advised not to do that.
If you don't specify it, reading `ctx.session` will throw an error for new users.

### Session Keys

> This section describes an advanced feature that most people do not have to worry about.
> You may want to continue with the section about [storing your data](#storing-your-data).

You can specify which session key to use by passing a function called `getSessionKey` to the [options](/ref/core/sessionoptions#getsessionkey).
That way, you can fundamentally change the way how the session plugin works.
By default, data is stored per chat.
Using `getSessionKey` allows you to store data per user, or per user-chat combination, or however you want.
Here are three examples:

::: code-group

```ts [TypeScript]
// Stores data per chat (default).
function getSessionKey(ctx: Context): string | undefined {
  // Let all users in a group chat share the same session,
  // but give an independent private one to each user in private chats
  return ctx.chat?.id.toString();
}

// Stores data per user.
function getSessionKey(ctx: Context): string | undefined {
  // Give every user their personal session storage
  // (will be shared across groups and in their private chat)
  return ctx.from?.id.toString();
}

// Stores data per user-chat combination.
function getSessionKey(ctx: Context): string | undefined {
  // Give every user their one personal session storage per chat with the bot
  // (an independent session for each group and their private chat)
  return ctx.from === undefined || ctx.chat === undefined
    ? undefined
    : `${ctx.from.id}/${ctx.chat.id}`;
}

bot.use(session({ getSessionKey }));
```

```js [JavaScript]
// Stores data per chat (default).
function getSessionKey(ctx) {
  // Let all users in a group chat share the same session,
  // but give an independent private one to each user in private chats
  return ctx.chat?.id.toString();
}

// Stores data per user.
function getSessionKey(ctx) {
  // Give every user their personal session storage
  // (will be shared across groups and in their private chat)
  return ctx.from?.id.toString();
}

// Stores data per user-chat combination.
function getSessionKey(ctx) {
  // Give every user their one personal session storage per chat with the bot
  // (an independent session for each group and their private chat)
  return ctx.from === undefined || ctx.chat === undefined
    ? undefined
    : `${ctx.from.id}/${ctx.chat.id}`;
}

bot.use(session({ getSessionKey }));
```

:::

Whenever `getSessionKey` returns `undefined`, `ctx.session` will be `undefined`.
For example, the default session key resolver will not work for `poll`/`poll_answer` updates or `inline_query` updates because they do not belong to a chat (`ctx.chat` is `undefined`).

::: warning Session Keys and Webhooks
When you are running your bot on webhooks, you should avoid using the option `getSessionKey`.
Telegram sends webhooks sequentially per chat, so the default session key resolver is the only implementation that guarantees not to cause data loss.

If you must use the option (which is of course still possible), you should know what you are doing.
Make sure you understand the consequences of this configuration by reading [this](../guide/deployment-types) article and especially [this](./runner#sequential-processing-where-necessary) one.
:::

You can also specify a prefix if you want to add additional namespacing to your session keys.
For example, this is how you can store session data per user but with a prefix called `user-`.

```ts
bot.use(session({
  getSessionKey: (ctx) => ctx.from?.id,
  prefix: "user-",
}));
```

For a user who has the user identifier `424242`, the session key will now be `user-424242`.

### Chat Migrations

If you are using sessions for groups, you should be aware that Telegram migrates regular groups to supergroups under certain circumstances (e.g. [here](https://github.com/telegramdesktop/tdesktop/issues/5593)).

This migration only occurs once for each group, but it can cause inconsistencies.
This is because the migrated chat is technically a completely different chat that has a different identifier, and hence its session will be identified differently.

Currently, there is no safe solution for this problem because messages from the two chats are also differently identified.
This can lead to data races.
However, there are several ways of dealing with this issue:

- Ignoring the problem.
  The bot's session data will effectively reset when a group is migrated.
  Simple, reliable, default behavior, but potentially unexpected once per chat.
  For example, if a migration happens while a user is in a conversation powered by the [conversations plugin](./conversations), the conversation will be reset.

- Only storing temporary data (or data with timeouts) in the session, and using a database for the important things that need to be migrated when a chat migrates.
  This can then use transactions and custom logic to handle concurrent data access from the old and the new chat.
  A lot of effort and has a performance cost, but the only truly reliable way to solve this problem.

- It is theoretically possible to implement a workaround that matches both chats **without guarantee of reliability**.
  The Telegram Bot API sends a migration update for each of the two chats once the migration was triggered (see the properties `migrate_to_chat_id` or `migrate_from_chat_id` in the [Telegram API Docs](https://core.telegram.org/bots/api#message)).
  The issue is that there is no guarantee that these messages are sent before a new message in the supergroup appears.
  Hence, the bot could receive a message from the new supergroup before it is aware of any migration and thus, it can not match the two chats, resulting in the aforementioned problems.

- Another workaround would be to limit the bot only for supergroups with [filtering](../guide/filter-queries) (or limit only session related features to supergroups).
  However, this shifts the problematic / inconvenience to the users.

- Letting the users decide explicitly.
  ("This chat was migrated, do you want to transfer the bot data?")
  Much more reliable and transparent than automatic migrations due to the artificially added delay, but worse UX.

Finally, it is up to the developer to decide how to deal with this edge case.
Depending on the bot functionalities one might choose one way or another.
If the data in question is short-lived (e.g. temporary, timeouts involved) the migration is less of a problem.
A user would experience the migration as a hiccup (if the timing is bad) and would simply have to rerun the feature.

Ignoring the problem is surely the easiest way, nevertheless it is important to know about this behavior.
Otherwise it can cause confusion and might cost hours of debugging time.

### Storing Your Data

In all examples above, the session data is stored in your RAM, so as soon as your bot is stopped, all data is lost.
This is convenient when you develop your bot or if you run automatic tests (no database setup needed), however, **that is most likely not desired in production**.
In production, you would want to persist your data, for example in a file, a database, or some other storage.

You should use the `storage` option of the session middleware to connect it to your datastore.
There may already be a storage adapter written for grammY that you can use (see [below](#known-storage-adapters)), but if not, it usually only takes 5 lines of code to implement one yourself.

## Known Storage Adapters

By default, sessions will be stored [in your memory](#ram-default) by the built-in storage adapter.
You can also use persistent sessions that grammY [offers for free](#free-storage), or connect to [external storages](#external-storage-solutions).

This is how you can install one of the storage adapters from below.

```ts
const storageAdapter = ... // depends on setup

bot.use(session({
  initial: ...
  storage: storageAdapter,
}));
```

### RAM (default)

By default, all data will be stored in RAM.
This means that all sessions are lost as soon as your bot stops.

You can use the `MemorySessionStorage` class ([API Reference](/ref/core/memorysessionstorage)) from the grammY core package if you want to configure further things about storing data in RAM.

```ts
bot.use(session({
  initial: ...
  storage: new MemorySessionStorage() // also the default value
}));
```

### Free Storage

> The free storage is meant to be used in hobby projects.
> Production-scale applications should host their own database.
> The list of supported integrations of external storage solutions is [down here](#external-storage-solutions).

A benefit of using grammY is that you get access to free cloud storage.
It requires zero setup---all authentication is done using your bot token.
Check out the [repository](https://github.com/grammyjs/storages/tree/main/packages/free)!

It is very easy to use:

::: code-group

```ts [TypeScript]
import { freeStorage } from "@grammyjs/storage-free";

bot.use(session({
  initial: ...
  storage: freeStorage<SessionData>(bot.token),
}));
```

```js [JavaScript]
const { freeStorage } = require("@grammyjs/storage-free");

bot.use(session({
  initial: ...
  storage: freeStorage(bot.token),
}));
```

```ts [Deno]
import { freeStorage } from "https://deno.land/x/grammy_storages/free/src/mod.ts";

bot.use(session({
  initial: ...
  storage: freeStorage<SessionData>(bot.token),
}));
```

:::

Done!
Your bot will now use a persistent data storage.

Here is a full example bot that you can copy to try it out.

::: code-group

```ts [TypeScript]
import { Bot, Context, session, SessionFlavor } from "grammy";
import { freeStorage } from "@grammyjs/storage-free";

// Define the session structure.
interface SessionData {
  count: number;
}
type MyContext = Context & SessionFlavor<SessionData>;

// Create the bot and register the session middleware.
const bot = new Bot<MyContext>("");

bot.use(
  session({
    initial: () => ({ count: 0 }),
    storage: freeStorage<SessionData>(bot.token),
  }),
);

// Use persistent session data in update handlers.
bot.on("message", async (ctx) => {
  ctx.session.count++;
  await ctx.reply(`Message count: ${ctx.session.count}`);
});

bot.catch((err) => console.error(err));
bot.start();
```

```js [JavaScript]
const { Bot, session } = require("grammy");
const { freeStorage } = require("@grammyjs/storage-free");

// Create the bot and register the session middleware.
const bot = new Bot("");

bot.use(
  session({
    initial: () => ({ count: 0 }),
    storage: freeStorage(bot.token),
  }),
);

// Use persistent session data in update handlers.
bot.on("message", async (ctx) => {
  ctx.session.count++;
  await ctx.reply(`Message count: ${ctx.session.count}`);
});

bot.catch((err) => console.error(err));
bot.start();
```

```ts [Deno]
import {
  Bot,
  Context,
  session,
  SessionFlavor,
} from "https://deno.land/x/grammy/mod.ts";
import { freeStorage } from "https://deno.land/x/grammy_storages/free/src/mod.ts";

// Define the session structure.
interface SessionData {
  count: number;
}
type MyContext = Context & SessionFlavor<SessionData>;

// Create the bot and register the session middleware.
const bot = new Bot<MyContext>("");

bot.use(
  session({
    initial: () => ({ count: 0 }),
    storage: freeStorage<SessionData>(bot.token),
  }),
);

// Use persistent session data in update handlers.
bot.on("message", async (ctx) => {
  ctx.session.count++;
  await ctx.reply(`Message count: ${ctx.session.count}`);
});

bot.catch((err) => console.error(err));
bot.start();
```

:::

### External Storage Solutions

We maintain a collection of official storage adapters that allow you to store your session data in different places.
Each of them will require you to register at a hosting provider, or to host your own storage solution.

Visit [here](https://github.com/grammyjs/storages/tree/main/packages#grammy-storages) to see a list of currently supported adapters and get guidance on using them.

::: tip Your storage is not supported? No problem!
Creating a custom storage adapter is extremely simple.
The `storage` option works with any object that adheres to this [interface](/ref/core/storageadapter), so you can connect to your storage just in a few lines of code.

> If you published your own storage adapter, feel free to edit this page and link it here, so that other people can use it.

:::

All storage adapters can be installed in the same way.
First, you should look out for the package name of the adapter of your choice.
For example, the storage adapter for Supabase is called `supabase`.

**On Node.js**, you can install the adapters via `npm i @grammyjs/storage-<name>`.
For example, the storage adapter for Supabase can be installed via `npm i @grammyjs/storage-supabase`.

**On Deno**, all storage adapters are published in the same Deno module.
You can then import the adapter you need from its subpath at `https://deno.land/x/grammy_storages/<adapter>/src/mod.ts`.
For example, the storage adapter for Supabase can be imported from `https://deno.land/x/grammy_storages/supabase/src/mod.ts`.

Check out the respective repositories about each individual setup.
They contain information about how to connect them to your storage solution.

You may also want to [scroll down](#storage-enhancements) to see how the session plugin is able to enhance any storage adapter.

## Multi Sessions

The session plugin is able to store different fragments of your session data in different places.
Basically, this works as if you would install multiple independent instances of the the session plugin, each with a different configuration.

Each of these data fragments will have a name under which they can store their data.
You will then be able to access `ctx.session.foo` and `ctx.session.bar` and these values were loaded from different data storages, and they will also be written back to different data storages.
Naturally, you can also use the same storage with different configuration.

It is also possible to use different [session keys](#session-keys) for each fragment.
As a result, you can store some data per chat and some data per user.

> If you are using [grammY runner](./runner), make sure to configure `sequentialize` correctly by returning **all** session keys as constraints from the function.

You can use this feature by passing `type: "multi"` to the session configuration.
In turn, you will need to configure each fragment with its own config.

```ts
bot.use(
  session({
    type: "multi",
    foo: {
      // these are also the default values
      storage: new MemorySessionStorage(),
      initial: () => undefined,
      getSessionKey: (ctx) => ctx.chat?.id.toString(),
      prefix: "",
    },
    bar: {
      initial: () => ({ prop: 0 }),
      storage: freeStorage(bot.token),
    },
    baz: {},
  }),
);
```

Note that you must add a configuration entry for every fragment you want to use.
If you wish to use the default configuration, you can specify an empty object (such as we do for `baz` in the above example).

Your session data will still consist of an object with multiple properties.
This is why your context flavor does not change.
The above example could use this interface when customizing the context object:

```ts
interface SessionData {
  foo?: string;
  bar: { prop: number };
  baz: { width?: number; height?: number };
}
```

You can then keep using `SessionFlavor<SessionData>` for your context object.

## Lazy Sessions

> This section describes a performance optimization that most people do not have to worry about.

Lazy sessions is an alternative implementation of sessions that can significantly reduce the database traffic of your bot by skipping superfluous read and write operations.

Let's assume that your bot is in a group chat where it does not respond to regular text messages, but only to commands.
Without sessions, this would happen:

1. Update with new text message is sent to your bot.
2. No handler is invoked, so no action is taken.
3. The middleware completes immediately.

As soon as you install default (strict) sessions, which directly provide the session data on the context object, this happens:

1. Update with new text message is sent to your bot.
2. Session data is loaded from session storage (e.g. database).
3. No handler is invoked, so no action is taken.
4. Identical session data is written back to session storage.
5. The middleware completes, and has performed a read and a write to the data storage.

Depending on the nature of your bot, this may lead to a lot of superfluous reads and writes.
Lazy sessions allow you to skip steps 2. and 4. if it turns out that no invoked handler needs session data.
In that case, no data will be read from the data storage, nor written back to it.

This is achieved by intercepting access to `ctx.session`.
If no handler is invoked, then `ctx.session` will never be accessed.
Lazy sessions use this as an indicator to prevent database communication.

In practice, instead of having the session data available under `ctx.session`, you will now have _a promise of the session data_ available under `ctx.session`.

```ts
// Default sessions (strict sessions)
bot.command("settings", async (ctx) => {
  // `session` is the session data
  const session = ctx.session;
});

// Lazy sessions
bot.command("settings", async (ctx) => {
  // `promise` is a Promise of the session data, and
  const promise = ctx.session;
  // `session` is the session data
  const session = await ctx.session;
});
```

If you never access `ctx.session`, no operations will be performed, but as soon as you access the `session` property on the context object, the read operation will be triggered.
If you never trigger the read (or directly assign a new value to `ctx.session`), we know that we also won't need to write any data back, because there is no way it could have been altered.
Consequently, we skip the write operation, too.
As a result, we achieve minimal read and write operations, but you can use session almost identical to before, just with a few `async` and `await` keywords mixed into your code.

So what is necessary to use lazy sessions instead of the default (strict) ones?
You mainly have to do three things:

1. Flavor your context with `LazySessionFlavor` instead of `SessionFlavor`.
   They work the same way, just that `ctx.session` is wrapped inside a promise for the lazy variant.
2. Use `lazySession` instead of `session` to register your session middleware.
3. Always put an inline `await ctx.session` instead of `ctx.session` everywhere in your middleware, for both reads and writes.
   Don't worry: You can `await` the promise with your session data as many times as you want, but you will always refer to the same value, so there are never going to be duplicate reads for an update.

Note that with lazy sessions you can assign both objects and promises of objects to `ctx.session`.
If you set `ctx.session` to be a promise, it will be `await`ed before writing the data back to the data storage.
This would allow for the following code:

```ts
bot.command("reset", async (ctx) => {
  // Much shorter than having to `await ctx.session` first:
  ctx.session = ctx.session.then((stats) => {
    stats.counter = 0;
  });
});
```

One may argue well that explicitly using `await` is preferable over assigning a promise to `ctx.session`, the point is that you _could_ do this if you like that style better for some reason.

::: tip Plugins That Need Sessions
Plugin developers that make use of `ctx.session` should always allow users to pass `SessionFlavor | LazySessionFlavor` and hence support both modes.
In the plugin code, simply await `ctx.session` all the time: if a non-promise object is passed, this will simply be evaluated to itself, so you effectively only write code for lazy sessions and thus support strict sessions automatically.
:::

## Storage Enhancements

The session plugin is able to enhance any storage adapter by adding more features to the storage: [timeouts](#timeouts) and [migrations](#migrations).

They can be installed using the `enhanceStorage` function.

```ts
// Use the enhanced storage adapter.
bot.use(
  session({
    storage: enhanceStorage({
      storage: freeStorage(bot.token), // adjust this
      // more config here
    }),
  }),
);
```

You can also use both at the same time.

### Timeouts

The timeouts enhancement can add an expiry date to the session data.
This means that you can specify a time period, and if the session is never changed during this time, the data for the particular chat will be deleted.

You can use session timeouts via the `millisecondsToLive` option.

```ts
const enhanced = enhanceStorage({
  storage,
  millisecondsToLive: 30 * 60 * 1000, // 30 min
});
```

Note that the actual deletion of the data will only happen the next time the respective session data is read.

### Migrations

Migrations are useful if you develop your bot further while there is already existing session data.
You can use them if you want to change your session data without breaking all previous data.

This works by giving version numbers to the data, and then writing small migration functions.
The migration functions define how to upgrade session data from one version to the next.

We will try to illustrate this by example.
Let's say that you stored information about the pet of a user.
So far, you only stored the names of the pets in a string array in `ctx.session.petNames`.

```ts
interface SessionData {
  petNames: string[];
}
```

Now, you get the idea that you also want to store the age of the pets.

You could do this:

```ts
interface SessionData {
  petNames: string[];
  petBirthdays?: number[];
}
```

This would not break your existing session data.
However, this is not so great, because the names and the birthdays are now stored in different places.
Ideally, your session data should look like this:

```ts
interface Pet {
  name: string;
  birthday?: number;
}

interface SessionData {
  pets: Pet[];
}
```

Migration functions let you transform the old string array into the new array of pet objects.

::: code-group

```ts [TypeScript]
interface OldSessionData {
  petNames: string[];
}

function addBirthdayToPets(old: OldSessionData): SessionData {
  return {
    pets: old.petNames.map((name) => ({ name })),
  };
}

const enhanced = enhanceStorage({
  storage,
  migrations: {
    1: addBirthdayToPets,
  },
});
```

```js [JavaScript]
function addBirthdayToPets(old) {
  return {
    pets: old.petNames.map((name) => ({ name })),
  };
}

const enhanced = enhanceStorage({
  storage,
  migrations: {
    1: addBirthdayToPets,
  },
});
```

:::

Whenever session data is read, the storage enhancement will check if the session data is already at version `1`.
If the version is lower (or missing because you were not using this feature before) then the migration function will be run.
This upgrades the data to version `1`.
Hence, in your bot, you can always just assume that your session data has the most up to date structure, and the storage enhancement will take care of the rest and migrate your data as necessary.

As time evolves and your bot changes further, you can add more and more migration functions:

```ts
const enhanced = enhanceStorage({
  storage,
  migrations: {
    1: addBirthdayToPets,
    2: addIsFavoriteFlagToPets,
    3: addUserSettings,
    10: extendUserSettings,
    10.1: fixUserSettings,
    11: compressData,
  },
});
```

You can pick any JavaScript numbers as versions.
No matter how far the session data for a chat has evolved, as soon as it is read, it will be migrated through the versions until it uses the most recent structure.

### Types for Storage Enhancements

When you use storage enhancements, your storage adapter will have to store more data than just your session data.
For example, it has to store the time when the session was last stored so that it can correctly [expire](#timeouts) the data upon timeout.
In some cases, TypeScript will be able to infer the correct types for your storage adapter.
However, more often than not, you need to annotate the types of the session data explicitly in several places.

The following example code snippet illustrates how to use the timeout enhancement with correct TypeScript types.

```ts
interface SessionData {
  count: number;
}

type MyContext = Context & SessionFlavor<SessionData>;

const bot = new Bot<MyContext>("");

bot.use(
  session({
    initial(): SessionData {
      return { count: 0 };
    },
    storage: enhanceStorage({
      storage: new MemorySessionStorage<Enhance<SessionData>>(),
      millisecondsToLive: 60_000,
    }),
  }),
);

bot.on("message", (ctx) => ctx.reply(`Chat count is ${ctx.session.count++}`));

bot.start();
```

Note that every [storage adapter](#known-storage-adapters) is able to take a type parameter.
For example, for [free sessions](#free-storage), you can use `freeStorage<Enhance<SessionData>>` instead of `MemorySessionStorage<Enhance<SessionData>>`.
The same is true for all other storage adapters.

## Plugin Summary

This plugin is built-in into the core of grammY.
You don't need to install anything to use it.
Simply import everything from grammY itself.

Also, both the documentation and the API reference of this plugin are unified with the core package.
</file>

<file path="site/docs/plugins/stateless-question.md">
---
prev: false
next: false
---

# Stateless Question (`stateless-question`)

> Create stateless questions to Telegram users working in privacy mode

You want to keep the privacy of the user with [Telegrams privacy mode enabled (by default)](https://core.telegram.org/bots/features#privacy-mode), send users translated questions in their language and don't save the state what users are currently doing?

This plugin wants to solve this problem.

The basic idea is to send your question with a [special text](https://en.wikipedia.org/wiki/Zero-width_non-joiner) at the end.
This text is invisible to the user but still visible for your bot.
When the user replies to a message, the message is checked.
If it is containing this special text at the end, then it is an answer to the question.
This way you can have many strings for the same questions as when having translations.
You only have to make sure the `uniqueIdentifier` is unique within your bot.

## Usage

```ts
import { StatelessQuestion } from "@grammyjs/stateless-question";

const bot = new Bot("");

const unicornQuestion = new StatelessQuestion("unicorns", async (ctx) => {
  console.log("User thinks unicorns are doing:", ctx.message);
});

// Don't forget to use the middleware.
bot.use(unicornQuestion.middleware());

bot.command("rainbows", async (ctx) => {
  let text;
  if (ctx.session.language === "de") {
    text = "Was machen Einhörner?";
  } else {
    text = "What are unicorns doing?";
  }

  return unicornQuestion.replyWithMarkdown(ctx, text);
});

// Or send your question manually (make sure to use a parse_mode and force_reply!).
bot.command("unicorn", async (ctx) => {
  await ctx.replyWithMarkdown(
    "What are unicorns doing?" + unicornQuestion.messageSuffixMarkdown(),
    { parse_mode: "Markdown", reply_markup: { force_reply: true } },
  );
});
bot.command("unicorn", async (ctx) => {
  await ctx.replyWithHTML(
    "What are unicorns doing?" + unicornQuestion.messageSuffixHTML(),
    { parse_mode: "HTML", reply_markup: { force_reply: true } },
  );
});
```

See the [plugin repo README](https://github.com/grammyjs/stateless-question) for more information.

## Plugin Summary

- Name: `stateless-question`
- [Source](https://github.com/grammyjs/stateless-question)
</file>

<file path="site/docs/plugins/transformer-throttler.md">
---
prev: false
next: false
---

# Flood Control (`transformer-throttler`)

> Consider using the [auto-retry plugin](./auto-retry) instead.

This plugin enqueues outgoing API requests instance via [Bottleneck](https://github.com/SGrondin/bottleneck) in order to prevent your bot from hitting [rate limits](https://core.telegram.org/bots/faq#my-bot-is-hitting-limits-how-do-i-avoid-this) as described in this [advanced section](../advanced/flood) of the documentation.

::: warning Undocumented API Limits Exist
Telegram implements unspecified and undocumented rate limits for some API calls.
These undocumented limits are **not accounted for** by the throttler.
If you still want to use this plugin, consider using the [auto-retry plugin](./auto-retry) together with it.
:::

## Usage

Here is an example of how to use this plugin with the default options.
Note that the default options are aligned with the actual rate limits enforced by Telegram, so they should be good to go.

::: code-group

```ts [TypeScript]
import { Bot } from "grammy";
import { run } from "@grammyjs/runner";
import { apiThrottler } from "@grammyjs/transformer-throttler";

const bot = new Bot("");

const throttler = apiThrottler();
bot.api.config.use(throttler);

bot.command("example", (ctx) => ctx.reply("I am throttled"));

// If you are using throttler, you most likely want to use a runner to handle updates concurrently.
run(bot);
```

```js [JavaScript]
const { Bot } = require("grammy");
const { run } = require("@grammyjs/runner");
const { apiThrottler } = require("@grammyjs/transformer-throttler");

const bot = new Bot("");

const throttler = apiThrottler();
bot.api.config.use(throttler);

bot.command("example", (ctx) => ctx.reply("I am throttled"));

// If you are using throttler, you most likely want to use a runner to handle updates concurrently.
run(bot);
```

```ts [Deno]
import { Bot } from "https://deno.land/x/grammy/mod.ts";
import { run } from "https://deno.land/x/grammy_runner/mod.ts";
import { apiThrottler } from "https://deno.land/x/grammy_transformer_throttler/mod.ts";

const bot = new Bot("");

const throttler = apiThrottler();
bot.api.config.use(throttler);

bot.command("example", (ctx) => ctx.reply("I am throttled"));

// If you are using throttler, you most likely want to use a runner to handle updates concurrently.
run(bot);
```

:::

## Configuration

The throttler accepts a single optional argument of the following form:

```ts
type ThrottlerOptions = {
  global?: Bottleneck.ConstructorOptions; // for throttling all api calls
  group?: Bottleneck.ConstructorOptions; // for throttling outgoing group messages
  out?: Bottleneck.ConstructorOptions; // for throttling outgoing private messages
};
```

The full list of object properties available for `Bottleneck.ConstructorOptions` can be found at [Bottleneck](https://github.com/SGrondin/bottleneck#constructor).

If no argument is passed, the throttler created will use the default configuration settings which should be appropriate for most use cases.
The default configuration are as follows:

```ts
// Outgoing Global Throttler
const globalConfig = {
  reservoir: 30, // number of new jobs that throttler will accept at start
  reservoirRefreshAmount: 30, // number of jobs that throttler will accept after refresh
  reservoirRefreshInterval: 1000, // interval in milliseconds where reservoir will refresh
};

// Outgoing Group Throttler
const groupConfig = {
  maxConcurrent: 1, // only 1 job at a time
  minTime: 1000, // wait this many milliseconds to be ready, after a job
  reservoir: 20, // number of new jobs that throttler will accept at start
  reservoirRefreshAmount: 20, // number of jobs that throttler will accept after refresh
  reservoirRefreshInterval: 60000, // interval in milliseconds where reservoir will refresh
};

// Outgoing Private Throttler
const outConfig = {
  maxConcurrent: 1, // only 1 job at a time
  minTime: 1000, // wait this many milliseconds to be ready, after a job
};
```

## Plugin Summary

- Name: `transformer-throttler`
- [Source](https://github.com/grammyjs/transformer-throttler)
- [Reference](/ref/transformer-throttler/)
</file>

<file path="site/docs/public/icons/beach.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" style="width:100%;height:100%;transform:translate3d(0,0,0)">
  <defs>
    <radialGradient id="d" spreadMethod="pad" gradientUnits="userSpaceOnUse" cx="-69.533" cy="-144.056" r="156.714" fx="-69.533" fy="-144.056">
      <stop offset="0%" stop-color="#FFFFB0"/>
      <stop offset="45%" stop-color="#F5E99B"/>
      <stop offset="64%" stop-color="#EAD285"/>
      <stop offset="82%" stop-color="#E9CF80"/>
      <stop offset="100%" stop-color="#E7CC7A"/>
    </radialGradient>
    <radialGradient id="b" spreadMethod="pad" gradientUnits="userSpaceOnUse" cx="18.467" cy="140.419" r="295.812" fx="18.467" fy="140.419">
      <stop offset="22%" stop-color="#EBFBD8"/>
      <stop offset="34%" stop-color="#D3FBD7"/>
      <stop offset="47%" stop-color="#BBFBD6"/>
      <stop offset="66%" stop-color="#95F9E9"/>
      <stop offset="100%" stop-color="#6FF6FB"/>
    </radialGradient>
    <linearGradient id="c" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="15.467" y1="95" x2="26.853" y2="28.965">
      <stop offset="0%" stop-color="#FFF236"/>
      <stop offset="50%" stop-color="#FDC63C"/>
      <stop offset="100%" stop-color="#FC9A43"/>
    </linearGradient>
    <clipPath id="a">
      <path d="M0 0h512v512H0z"/>
    </clipPath>
  </defs>
  <g clip-path="url(#a)">
    <g style="display:block">
      <path fill="#FFF" d="M396.055 312.941c27.882 2.824 48.354 16.588 63.261 33.043 8.438 9.314 28.209 47.774-10.33 79.349-43.128 35.335-125.434 51.675-219.173 46.28-93.739-5.395-150.688-45.795-161.174-83.219-9.159-32.69 11.451-44.789 17.722-48.851 9.256-5.995 24.165-12.132 53.459-16.014 75.681-10.03 202.126-16.067 256.235-10.588z"/>
      <path fill="url(#b)" d="M-169.639 78.543s-26.881 16.161-17.722 48.851c10.486 37.424 67.435 77.824 161.174 83.219 93.739 5.395 176.045-10.945 219.173-46.28 38.539-31.575 18.112-72.431 10.33-79.349 0 0 8.17 29.148-19.456 31.927-21.055 2.118-34.397-11.777-53.04-5.852-16.673 5.299-15.983 20.438-50.442 19.792-43.939-.824-87.381-25.449-130.88-25.756-53.06-.375-130.758 25.351-119.137-26.552z" transform="translate(256 261)"/>
      <path fill="#FFF" d="M107.197 435.669c-.197 1.887 6.303 2.331 6.303.554 0-1.776-6.129-2.223-6.303-.554zm-9.349-5.084C97.5 432.945 109 433.5 109 431.28c0-2.22-10.844-2.779-11.152-.694zM139.301 453c7.572 2.975 19.95 7.062 26.094 8.124 4.144.638 11.105 3.376 17.105 4.888 13.172 3.318 25.665 4.83 33.234 5.712 4.516.526 17.246 1.576 22.935 1.762 8.081.264 25.016-.175 31.545-.175 6.79 0 18.269-.5 29.453-.713 10.341-.196 21.991-2.45 34.134-2.875 9.558-.334 12.592-1.664 17.654-2.199 4.024-.425 7.067-1.425 9.73-1.85 3.099-.638 9.2-2.488 13.315-4.824-5.35 2.125-33.264 7.436-41.035 7.862-5.904.323-9.999.074-22.928.925-10.243.673-23.701 1.862-36.716.8-7.539-.616-29.393 1.407-43.867.287-31.954-2.474-42.454-4.224-60.11-9.561-9.425-2.85-19.594-3.663-30.543-8.163z" opacity=".6"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#86E8D1" stroke-width="6" d="M239.73 472.258c2.47.385 7.77.242 12.555.034M308.005 469.72c5.948-.146 10.988-.555 17.273-1.047M151.856 457.104C158 459.75 164.75 462 173.081 463.44" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#0BBFD6" stroke-width="8" d="M396.055 312.941c27.882 2.824 48.354 16.588 63.261 33.043 8.438 9.314 28.209 47.774-10.33 79.349-43.128 35.335-125.434 51.675-219.173 46.28-93.739-5.395-150.688-45.795-161.174-83.219-9.159-32.69 11.451-44.789 17.722-48.851 9.256-5.995 24.165-12.132 53.459-16.014 75.681-10.03 202.126-16.067 256.235-10.588z" fill="none"/>
      <path fill="#FFF" d="M402.241 375.143c0 .983-1.672 1.779-3.734 1.779-2.062 0-3.733-.796-3.733-1.779 0-.983 1.671-1.78 3.733-1.78 2.062 0 3.734.797 3.734 1.78zM215.613 371.992c0 1.734-2.893 3.14-6.461 3.14-3.568 0-6.46-1.406-6.46-3.14 0-1.734 2.892-3.14 6.46-3.14s6.461 1.406 6.461 3.14zM197.45 370.212c0 .983-1.671 1.78-3.733 1.78-2.062 0-3.733-.797-3.733-1.78s1.671-1.78 3.733-1.78c2.062 0 3.733.797 3.733 1.78zM218.95 362.466c0 .571-1.671 1.034-3.733 1.034-2.062 0-3.733-.463-3.733-1.034s1.671-1.034 3.733-1.034c2.062 0 3.733.463 3.733 1.034zM365.373 384.492c0 .695-1.669 1.258-3.729 1.258s-3.73-.563-3.73-1.258c0-.695 1.67-1.258 3.73-1.258s3.729.563 3.729 1.258z"/>
    </g>
    <g style="display:block">
      <path fill="url(#c)" d="M-151.846 91.491c-11.745-11.824 14.437-47.679 69.736-66.673 55.299-18.994 150.27-27.253 210.556 0s67.186 59.597 58.561 72.104c-8.625 12.507-35.083.852-50.394.927-13.908.068-15.59 9.855-39.31 15.03-23.72 5.175-59.86-6.898-96.003-14.104-34.607-6.9-56.358-9.109-106.262-3.945-28.094 2.907-39.347 4.248-46.884-3.339z" transform="translate(256 261)"/>
      <path fill="#5D2B00" d="M244.906 311.589c6.932-17.848 25.415-8.071 40.823-15.409 18.878-8.99 46.735-11.115 67.812-3.378 18.27 6.707 37.926 9.551 50.985 4.257-10.235-9.529-64.824-41.177-185.26-22.67-10.564 1.623-23.049 9.965-4.931 14.14 18.118 4.175 25.299 36.633 30.571 23.06z" opacity=".3"/>
      <path fill="#5D2B00" d="M285.73 296.178c-14.968 7.587-33.41-2.913-40.82 15.41-2.662 6.583-9.033-1.338-10.12-4.36-1.087-3.022-3.999-6.965-1.548-9.678 9.372-10.373 37.534-15.502 63.648-17.497 19.011-1.452 41.901 1.653 41.548 5.359-.328 3.444-17.888 2.283-25.853 3.353-11.824 1.588-21.056 4.474-26.855 7.413z" opacity=".2"/>
      <path fill="#C46200" d="M443.009 357.919c-8.625 12.507-37.521 1.732-51.324 0-13.804-1.723-14.672 10.749-38.381 15.962-29.161 6.411-79.245-13.541-96.004-16.885 16.37 3.02 82.199 18.3 104.488 1.368 18.917-14.371 23.534-15.564 57.301-13.053 24.367 1.812 20.854-15.731 17.435-22.327 11.274 14.915 11.275 27.987 6.485 34.935z" opacity=".3"/>
    </g>
    <g style="display:block">
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#C29D5C" stroke-width="9" d="M134.902 359.505c3.303-3.502 10.915-2.545 10.301 2.33 4.377-1.373 12.108-2.627 9.189 2.797 4.762-.412 3.633-.79 2.98-.659-1.372.276-7.936.628-11.315 1.177-.62.662-2.932.1-3.928.162-4.191-1.25-10.691.437-12.191-.943.5-.12.062-.557.705-.989-.768-.943-1.807-1.01-1.972-1.932-.483-2.699 1.93-3.659 6.231-1.943z" fill="none"/>
      <path fill="#E3D39E" d="M134.902 359.505c3.303-3.502 10.915-2.545 10.301 2.33 4.377-1.373 12.108-2.627 9.189 2.797 4.762-.412 3.633-.79 2.98-.659-1.372.276-7.936.628-11.315 1.177-.62.662-2.932.1-3.928.162-4.191-1.25-10.691.437-12.191-.943.5-.12.062-.557.705-.989-.768-.943-1.807-1.01-1.972-1.932-.483-2.699 1.93-3.659 6.231-1.943z"/>
    </g>
    <g style="display:block">
      <path fill="#FFF" d="M380.5 362.25c-3.75 2-8 4.75-15.5 8.75s-23.5 4.25-28.25 4-2.48 16.02 4.375 16.375c16.875.875 24.75-6.25 29.25-9s7.5-8.875 20.125-11.625c-1-2.25-6.25-10.5-10-8.5zM168.227 351.6c-11.727.9-21.727 3.15-29.513 3.457-8.494.336-14.714 1.193-19.723 1.005-4.753-.177-14.001 13.967-7.193 14.848 11.327 1.465 23.194-.187 28.461-.436 4.741-.224 19.991-1.224 30.974-3.031 1.392-2.818 1.232-16.169-3.006-15.843z"/>
    </g>
    <g style="display:block">
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#E5A300" stroke-width="8" d="M104.154 352.491c-11.745-11.824 14.437-47.679 69.736-66.673 55.299-18.994 150.27-27.253 210.556 0s67.186 59.597 58.561 72.104c-8.625 12.507-35.083.852-50.394.927-13.908.068-15.59 9.855-39.31 15.03-23.72 5.175-59.86-6.898-96.003-14.104-34.607-6.9-56.358-9.109-106.262-3.945-28.094 2.907-39.347 4.248-46.884-3.339z" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#C46200" stroke-width="8" d="m173.793 285.851.097-.033c55.299-18.994 150.27-27.253 210.556 0s67.186 59.597 58.561 72.104c-8.625 12.507-35.083.852-50.394.927-13.783.067-15.559 9.68-38.678 14.89" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#965317" stroke-width="8" d="M211.231 275.908c54.555-10.968 124.985-11.893 173.215 9.91 5.652 2.555 10.835 5.154 15.58 7.778" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#0BBFD6" stroke-width="8" d="M441.192 330.169c6.477 11.864 5.819 21.946 1.815 27.753-8.625 12.507-35.083.852-50.394.927-13.908.068-15.59 9.855-39.31 15.03-23.72 5.175-59.86-6.898-96.003-14.104-34.607-6.9-56.358-9.109-106.262-3.945-28.094 2.907-39.347 4.248-46.884-3.339 0 0 0 0 0 0-4.472-4.502-3.446-12.487 2.593-21.7" fill="none" opacity=".2"/>
    </g>
    <g style="display:block">
      <path fill="#C46200" d="M244.625 310.625c-.75-5-20.375-2.5-19.5 3.125.84 5.402 20.231 1.753 19.5-3.125z"/>
      <path stroke="#C46200" stroke-width="4.5" d="M244.625 310.625c-.75-5-20.375-2.5-19.5 3.125.84 5.402 20.231 1.753 19.5-3.125z" fill="none"/>
    </g>
    <g style="display:block">
      <path fill="#C60" d="M243.053 310.662c-4.057 5.102-10.762 5.456-16.137 3.133-.625-3.325-37.685-194.619-38.569-198.678 4.061-.882 12.685-2.208 16.138-3.133 1.335 5.78 38.036 194.635 38.568 198.678z"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#FFF" stroke-width="8" d="m230.946 314.424-21.879-113.997m21.879 113.997-21.879-113.997" fill="none" opacity=".4"/>
      <path fill="#5D2B00" d="M229.272 239.667c-2.275-1.197-14.714-11.621-10.789 16.356-3.134-9.435-29.604-135.082-30.136-140.907 3.002-.528 12.686-2.558 16.138-3.131.982 3.662 23.923 123.309 24.787 127.682z" opacity=".4"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#9B4600" stroke-width="8" d="M243.053 310.662c-4.057 5.102-10.762 5.456-16.137 3.133-.625-3.325-37.685-194.619-38.569-198.678 4.061-.882 12.685-2.208 16.138-3.133 1.335 5.78 38.036 194.635 38.568 198.678z" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#5D2B00" stroke-width="8" d="M213.43 244.136c-10.911-56.293-24.551-126.576-25.083-129.019 4.061-.882 12.685-2.208 16.138-3.133.779 3.374 13.611 69.138 24.264 124.104" fill="none"/>
    </g>
    <g style="display:block">
      <path fill="url(#d)" d="M-72.961-208.296c-3.101 3.414-10.395 9.296-21.622 11.534-11.361-.12-43.596 4.35-67.906 39.27-11.22 8.609-41.808 31.433-53.389 76.67 11.11 1.587 33.933 10.763 49.062 32.712 28.165-6.184 59.459-16.537 122.907-3.474 24.317-15.651 61.964-38.004 115.468-40.633 1.437-4.783 4.614-36.195 34.203-50.054-14.295-24.259-42.765-42.376-73.589-50.611-21.412-19.294-52.941-23.059-81.412-13.412-9.176.941-18.117.235-23.722-2.002z" transform="translate(256 261)"/>
      <path fill="#9B8653" d="M361.762 118.729c-24.29 12.683-31.34 33.583-33.378 43.903-29.044-86.238-121.371-95.597-81.625-92.702 70.026 5.1 115.003 48.799 115.003 48.799z" opacity=".2"/>
      <path fill="#F41C1C" d="M183.261 67.962C170.526 74 104.879 107.177 89.184 212.89c-18.334-28.246-49.062-32.712-49.062-32.712 11.463-44.766 46.756-71.237 55.618-75.323 8.433-8.973 46.903-34.031 87.521-36.893zM327.559 168.783c-49.386 3.687-79.739 18.159-115.468 40.633-9.448-94.474-23.212-124.122-28.83-141.454 12.323 1.803 88.559-2.08 144.298 100.821z"/>
      <path fill="#F41C1C" d="M288.39 68.166c-6.806-1.107-44.158-11.262-105.129-.204 5.029-2.55 15.491-7.966 25.5-10.903 47.098-19.511 76.569 9.019 79.629 11.107z"/>
      <path fill="#F41C1C" d="M183.261 67.962c-3.853-.491-8.735-1.432-21.297-.119 7.974-5.313 19.679-11.725 23.852-13.011-1.879 2.462-3.232 6.05-2.555 13.13z"/>
      <path fill="#DD1A0B" d="M264.017 182.077c-25.726 10.864-42.315 21.1-51.926 27.339-5.319-61.125-14.389-91.299-21.669-122.463 5.162 18.106 57.221 104.639 73.595 95.124zM110.001 143.613c-8.995 18.565-16.519 41.373-20.817 69.277-6.3-9.709-14.063-16.611-21.548-21.484 11.006 5.596 31.767-28.551 42.365-47.793z"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#FFF" stroke-width="7" d="M67.635 191.406s-7.776-9.934-18.993-14.67c0 0 11.006-42.109 51.655-69.733 0 0 6.203-23.003 33.12-34.765" fill="none" opacity=".5"/>
      <path fill="#FFF" d="M268.864 60.675c2.792 12.258-32.116 39.207-78.664 49.81-46.548 10.603-87.11.843-89.902-11.415-2.792-12.258 32.68-30.789 79.228-41.392 46.548-10.603 86.546-9.261 89.338 2.997z" opacity=".15"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#FFF" stroke-width="7" d="M237 49.377s31.119 5.408 47.73 24.574c0 0 47.443 11.696 67.231 44.017 0 0-20.835 11.576-22.567 40.383" fill="none" opacity=".5"/>
    </g>
    <g style="display:block">
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#9B8653" stroke-width="8" d="M183.039 52.704c-3.101 3.414-10.395 9.296-21.622 11.534-11.361-.12-43.596 4.35-67.906 39.27-11.22 8.609-41.808 31.433-53.389 76.67 11.11 1.587 33.933 10.763 49.062 32.712 28.165-6.184 59.459-16.537 122.907-3.474 24.317-15.651 61.964-38.004 115.468-40.633 1.437-4.783 4.614-36.195 34.203-50.054-14.295-24.259-42.765-42.376-73.589-50.611-21.412-19.294-52.941-23.059-81.412-13.412-9.176.941-18.117.235-23.722-2.002z" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#B79E65" stroke-width="8" d="M228.737 49.994c-7.379.69-14.775 2.272-21.976 4.712-9.176.941-18.117.235-23.722-2.002 0 0 0 0 0 0-3.101 3.414-10.395 9.296-21.622 11.534-11.361-.12-43.596 4.35-67.906 39.27-6.972 5.349-21.421 16.187-34.142 34.479" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#AA0400" stroke-width="8" d="M92.99 103.907c-11.617 8.903-41.462 31.716-52.868 76.271 10.337 1.477 30.813 9.522 45.798 28.313" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#CE2828" stroke-width="8" d="M183.039 52.704c-3.094 3.406-10.362 9.269-21.546 11.519M281.197 62.612c-20.734-14.28-48.357-16.508-73.666-8.163" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#AA0400" stroke-width="8" d="M215.176 207.442c23.864-15.169 59.566-35.28 109.194-38.478" fill="none"/>
      <path fill="#8E4202" d="M192.889 65.936c.379 1.665-3.52 3.974-8.709 5.156-5.189 1.182-9.703.789-10.082-.876-.379-1.665 3.52-3.973 8.709-5.155 5.189-1.182 9.703-.79 10.082.875z"/>
      <path fill="#5B2700" d="M188.552 66.082c.147.644-2.103 1.706-5.025 2.372-2.922.665-5.409.682-5.556.038-.147-.644 2.103-1.706 5.025-2.371s5.409-.683 5.556-.039z"/>
    </g>
  </g>
</svg>
</file>

<file path="site/docs/public/icons/palette.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" style="width:100%;height:100%;transform:translate3d(0,0,0)">
  <defs>
    <linearGradient id="c" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="-226.606" y1="6.083" x2="157.736" y2="-2.757">
      <stop offset="0%" stop-color="#D39927"/>
      <stop offset="50%" stop-color="#DFA539"/>
      <stop offset="100%" stop-color="#EBB14A"/>
    </linearGradient>
    <linearGradient id="b" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="-159.597" y1="10.774" x2="195.214" y2="56.734">
      <stop offset="0%" stop-color="#AA6427"/>
      <stop offset="14%" stop-color="#AD6C30"/>
      <stop offset="28%" stop-color="#B1753A"/>
      <stop offset="36%" stop-color="#814F1E"/>
      <stop offset="57%" stop-color="#512802"/>
      <stop offset="72%" stop-color="#6D4621"/>
      <stop offset="100%" stop-color="#896441"/>
    </linearGradient>
    <clipPath id="a">
      <path d="M0 0h512v512H0z"/>
    </clipPath>
  </defs>
  <g clip-path="url(#a)">
    <g style="display:block">
      <path fill="url(#b)" d="M-3.31-128.333c-113.347 15.046-241.283 96.631-225.409 177.649 11.01 56.196 88.803 106.811 178.339 115.515 83.282 8.098 149.844-10.872 181.445-32.612 31.601-21.74 29.967-42.036 7.355-61.994-15.237-13.449-40.999-.884-40.09-12.47 1.139-14.665 28.297-27.695 64.305-29.831 40.546-2.392 100.62-6.678 88.448-74.974-12.342-69.25-135.059-97.114-254.393-81.283zm126.5 106.095c.826 13.151-14.679 24.814-34.616 26.058C68.631 5.056 51.8-4.586 50.98-17.73c-.818-13.158 14.686-24.82 34.623-26.064 19.937-1.244 36.775 8.406 37.587 21.556z" transform="rotate(40 -225.658 470.31) scale(.95)"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#381305" stroke-width="7.6" d="M325.473 159.667c-91.675-58.265-234.6-77.016-272.52-8.363-26.304 47.62-.599 131.959 59.245 192.968 55.663 56.75 115.687 83.59 151.96 87.066 36.273 3.476 47.478-12.292 43.21-40.625-2.877-19.091-29.298-25.679-21.561-33.555 9.784-9.977 37.505-2.876 65.013 17.558 30.968 23.019 77.304 56.584 110.15-.551 33.306-57.933-38.985-153.148-135.497-214.498zm27.273 154.457c-7.43 10.075-25.835 9.095-41.104-2.175-15.268-11.278-21.629-28.573-14.2-38.64 7.44-10.074 25.845-9.094 41.113 2.175 15.27 11.27 21.63 28.574 14.191 38.64z" fill="none"/>
      <path fill="#FFF" d="M303.67 411.342c-9.61 24.091-39.055 15.312-39.762 15.264l5.922-11.414c1.783.262 25.403-1.539 33.84-3.85zM441.648 391.664c-16.844 16.457-38.833 6.786-39.54 6.738l5.113-9.673c1.783.262 19.696 5.031 34.427 2.935z" opacity=".2"/>
    </g>
    <g style="display:block">
      <path fill="url(#c)" d="M-6.92-135.747c-113.347 15.046-227.09 94.728-225.991 176.178.989 73.329 88.558 109.629 178.094 118.333 83.282 8.098 154.156-13.511 185.757-35.251S143.409 82 125.001 77.569c-19.76-4.753-30.603-12.219-29.694-23.805 1.139-14.665 24.016-25.408 60.024-27.544 40.546-2.393 112.995-16.101 89.536-75.234-25.939-65.383-132.453-102.564-251.787-86.733zM119.579-29.652c.826 13.151-14.678 24.814-34.615 26.058C65.021-2.358 48.19-12 47.37-25.144c-.818-13.158 14.686-24.82 34.623-26.064 19.937-1.244 36.774 8.406 37.586 21.556z" transform="rotate(40 -205.952 476.967) scale(.95)"/>
      <g opacity=".65">
        <path fill="#E5A83C" d="M303.617 409.262C300.458 400.595 42.94 224.123 49.68 209.967c-.052 9.088 288.948 183.71 253.937 199.295z" opacity=".5"/>
        <path fill="#C58D2F" d="M48.576 170.81 228.52 318.558c-3.143-8.205-200.252-132.304-179.943-147.748z" opacity="1"/>
        <path fill="#CB9336" d="M374.705 371.78C354.64 351.31 158.297 225.844 172.25 188.038c.011-.01 202.455 183.742 202.455 183.742z" opacity=".6"/>
        <path fill="#DA9E33" d="M309.16 337.558c-62.07-5.377-197.306-149.59-257.23-181.078l11.86-23.776c46.968 58.574 183.022 161.738 245.37 204.854z" opacity="1"/>
        <path fill="#C58B2D" d="M319.285 249.008C311.814 270.48 74.333 76.652 141.409 93.298c62.017 31.614 110.757 113.685 177.876 155.71z" opacity=".6"/>
        <path fill="#CB9336" d="M464.007 365.302c.319 36.594-114.578-41.533-97.397-78.355 33.55 26.601 66.67 52.59 97.397 78.355z" opacity=".6"/>
        <path fill="#DDA033" d="M358.687 265.697c-9.342-8.922-15.228-14.95-35.169-17.12-57.667-50.406-122.382-108.5-182.095-155.297 32.194-15.494 63.05 42.854 78.772 55.062 6.045 9.138 139.388 99.396 138.492 117.355z" opacity="1"/>
        <path fill="#CB9336" d="M292.09 414.443c-20.208 13.253-215.33-146.057-223.977-157.91-8.475-15.326 225.036 161.553 223.977 157.91z" opacity=".5"/>
        <path fill="#CB9336" d="M404.606 288.818C390.66 275.109 242.7 157.424 242.583 139.288c-11.535-4.364 234.962 191.948 162.023 149.53z" opacity="1"/>
        <path fill="#C38B2F" d="m78.24 124.76 95.403 77.55c-6.898-.955-87.3-98.486-95.403-77.55z" opacity="1"/>
        <path fill="#CB9336" d="M469.64 312.472c-58.983-32.068-207.72-182.66-263.277-217.953 13.786-5.229 267.522 200.495 263.278 217.953z" opacity=".6"/>
        <path fill="#D49A3A" d="M437.216 389.149c-93.264-29.75-252.286-233.643-336.54-285.323 98.183 46.653 237.537 212.371 336.54 285.323z" opacity="1"/>
      </g>
      <path fill="#FCC344" d="M370.407 294.064c-4.56 6.175-8.718 6.216-6.872 1.35 13.829-36.46-36.144-58.133-55.303-40.814-5.06 4.575-7.772 1.036-2.142-6.598 8.898-12.048 30.923-13.633 49.183-.157 18.26 13.484 24.032 34.17 15.134 46.219z" opacity=".5"/>
      <path fill="#FFC85A" d="M466.535 357.83c-8.215 24.757-24.263 32.446-42.346 31.338 12.035-2.79 22.19-11.405 28.116-29.17 20.334-60.96-32.62-149.488-125.855-208.457-88.574-56.005-220.842-68.427-262.825-9.404-10.218 14.38-15.237 30.08-16.018 46.5-.826-20.37 4.167-39.886 16.61-57.468 43.46-61.4 180.37-48.477 272.046 9.789 96.511 61.35 151.322 153.45 130.272 216.872z" opacity=".5"/>
      <path fill="#FEDB79" d="M299.246 377.666c10.69 14.466 15.3 39.626-20.973 36.15-36.273-3.476-101.047-31.03-156.71-87.778-12.992-13.25-24.943-27.25-35.275-41.632 1.568 1.605 89.75 98.949 175.333 116.068 52.822 10.566 43.104-12.43 37.625-22.808zM470.372 340.316c-.697 6.03-1.972 11.892-3.837 17.514-19.037 57.36-80.132 23.094-111.1.076-17.168-12.746-44.261-23.882-44.261-23.882s12.508-5.585 53.436 21.03c40.685 26.457 93.452 43.9 105.762-14.738z"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#915206" stroke-width="8" d="M-6.92-135.747c-113.347 15.046-227.09 94.728-225.991 176.178.989 73.329 88.558 109.629 178.094 118.333 83.282 8.098 154.156-13.511 185.757-35.251S143.409 82 125.001 77.569c-19.76-4.753-30.603-12.219-29.694-23.805 1.139-14.665 24.016-25.408 60.024-27.544 40.546-2.393 112.995-16.101 89.536-75.234-25.939-65.383-132.453-102.564-251.787-86.733zM119.579-29.652c.826 13.151-14.678 24.814-34.615 26.058C65.021-2.358 48.19-12 47.37-25.144c-.818-13.158 14.686-24.82 34.623-26.064 19.937-1.244 36.774 8.406 37.586 21.556z" fill="none" transform="rotate(40 -205.95 476.97) scale(.94799 .95)"/>
    </g>
    <g style="display:block">
      <path fill="#5B001C" d="M390.694 263.024c-11.945 2.496-13.312 14.153-.955 28.824 6.303 7.483 1.402 19.279 8.26 30.66 9.185 15.246 62.165 29.747 63.634 6.334 1.699-27.065-46.797-70.863-70.939-65.818z" opacity=".2"/>
      <path fill="#FF2E2E" d="M395.74 264.935c-9.465.468-10.788 8.576 1.569 23.248 6.302 7.482 1.945 17.66 9.166 28.815 12.214 18.863 27.115 13.282 32.152 14.961 5.038 1.679 26.688 6.492 21.81-14.531-2.854-12.303-11.74-24.796-22.908-34.511-12.812-11.145-28.628-18.634-41.789-17.982z"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#D3002E" stroke-width="7.6" d="M395.74 264.935c-9.465.468-10.788 8.576 1.569 23.248 6.302 7.482 1.945 17.66 9.166 28.815 12.214 18.863 27.115 13.282 32.152 14.961 5.038 1.679 26.688 6.492 21.81-14.531-2.854-12.303-11.74-24.796-22.908-34.511-12.812-11.145-28.628-18.634-41.789-17.982z" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#A3022C" stroke-width="7.6" d="M395.74 264.935c-9.465.468-10.788 8.576 1.569 23.248 6.302 7.482 1.945 17.66 9.166 28.815 12.214 18.863 27.115 13.282 32.152 14.961 3.033 1.011 12.085 3.156 17.747.119" fill="none"/>
      <path fill="#FF4D4D" d="M416.667 303.447c-4.93-20.584-16.911-25.582-13.843-31.575 3.068-5.993 37.609 9.376 51.576 39.15 2.901 7.997 1.051 12.128-10.185 9.567-11.237-2.56-25.396-8.154-27.548-17.142z"/>
      <path fill="#FFF" d="M422.62 280.81c-1.839-.036 3.216 4.978 5.643 20.128 1.535 9.586 17.459 11.319 20.842 10.073 3.384-1.245-7.708-4.674-13.348-12.36-6.089-8.298-8.573-17.755-13.138-17.841z" opacity=".3"/>
    </g>
    <g style="display:block">
      <path fill="#8E5400" d="M316.408 198.894c2.497-3.003-17.772-18.914-9.498-28.632 5.207-6.117 60.946 17.704 71.283 38.482 10.216 20.534-3.413 26.845-27.48 21.013-22.8-5.524-46.1-16.686-34.305-30.863z" opacity=".2"/>
      <path fill="#FFD522" d="M325.398 193.349c2.498-3.002-20.832-14.636-12.559-24.355 5.207-6.117 19.193-3.483 31.541 2.898 7.172 3.705 32.46 9.61 42.798 30.387 10.216 20.535-3.407 27.766-27.475 21.934-22.8-5.524-46.099-16.687-34.305-30.864z"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#F9C71F" stroke-width="7.6" d="M325.398 193.349c2.498-3.002-20.832-14.636-12.559-24.355 5.207-6.117 19.193-3.483 31.541 2.898 7.172 3.705 32.46 9.61 42.798 30.387 10.216 20.535-3.407 27.766-27.475 21.934-22.8-5.524-46.099-16.687-34.305-30.864z" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#E29205" stroke-width="7.6" d="M381.667 225.25c-5.382 1.5-12.939 1.15-21.964-1.037-22.8-5.524-46.099-16.687-34.305-30.864 2.498-3.002-20.832-14.636-12.559-24.355" fill="none"/>
      <path fill="#F7E839" d="M324.153 169.772c3.113-2.11 19.056 6.41 23.22 7.571 4.164 1.16 32.373 11.192 38.078 30.393 1.82 5.926.114 14.397-33.167 1.95-14.236-5.208-14.363-9.719-16.547-15.286-2.184-5.568-17.599-20.55-11.584-24.628z"/>
      <path fill="#FFF" d="M326.414 171.896c1.415 3.047 10.07 7.244 11.354 12.24 1.283 4.996-2.388 13.851 11.52 18.993 13.91 5.142-3.253-7.114-3.718-12.408-1.402-15.92-20.13-20.924-19.156-18.825z" opacity=".4"/>
    </g>
    <g style="display:block">
      <path fill="#194700" d="M185.767 138.785c2.252-6.338-16.755-37.372 13.377-32.272 15.389 2.605 75.192 51.867 49.637 73.5-6.704 5.676-18.782 7.397-37.673.847-14.563-5.05-32.615-21.6-25.34-42.075z" opacity=".2"/>
      <path fill="#3AC114" d="M193.834 135.46c2.252-6.336-7.562-14.38-2.14-22.288 6.474-9.442 23.586-4.43 35.482 2.827 13.323 8.13 26.799 8.489 37.986 19.083 8.088 7.66 10.313 20.145-1.513 26.438-4.252 2.263-4.803 7.647-10.762 11.89-8.275 5.89-22.245 5.922-34.441 1.13-14.347-5.635-31.886-18.604-24.612-39.08z"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#319618" stroke-width="7.6" d="M193.834 135.46c2.252-6.336-7.562-14.38-2.14-22.288 6.474-9.442 23.586-4.43 35.482 2.827 13.323 8.13 26.799 8.489 37.986 19.083 8.088 7.66 10.313 20.145-1.513 26.438-4.252 2.263-4.803 7.647-10.762 11.89-8.275 5.89-22.245 5.922-34.441 1.13-14.347-5.635-31.886-18.604-24.612-39.08z" fill="none"/>
      <path fill="#4BD629" d="M213.01 113.807c-16.151-3.487-15.093 3.914-7.677 13.04 5.446 6.7-5.046 12.269 8.953 23.95 10.103 8.43 28.724 14.097 36.243 6.787 8.174-7.945 17.925-3.838 14.036-16.653-3.609-7.299-18.413-11.666-30.034-16.971-10.047-4.587-18.323-9.463-21.52-10.153z"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#2B6D08" stroke-width="7.6" d="M263.649 161.52c-4.252 2.263-4.803 7.647-10.762 11.89-8.275 5.89-22.245 5.922-34.441 1.13-14.347-5.635-31.886-18.604-24.612-39.08 2.252-6.336-7.562-14.38-2.14-22.288" fill="none"/>
      <path fill="#FFF" d="M220.286 119.47c4.932 3.242-.423 9.364 7.802 12.184 8.89 3.047 16.738 3.898 16.216 7.357-.523 3.46-24.48 2.86-26.885-3.309-2.405-6.169-.128-12.631-2.862-14.259-4.671-2.781.796-5.216 5.729-1.974z" opacity=".3"/>
    </g>
    <g style="display:block">
      <path fill="#002877" d="M102.916 147.291c-14.607.13-18.776 12.924-12.38 28.646 3.09 7.598-11.645 16.767 3.788 36.76 8.472 10.974 21.79 15.725 46.985 22.926 24.851 7.102 54.774-1.079 52.002-24.646-3.317-28.217-68.946-63.876-90.395-63.686z" opacity=".2"/>
      <path fill="#16B2DB" d="M107.365 146.833c-14.923.131-14.596 13.413-8.655 26.556 3.388 7.496-10.372 11.557 4.436 32.263 11.398 15.938 28.305 17.717 48.528 26.682 14.913 6.612 28.385 7.472 29.775-9 .357-4.23 19.794-4.035 5.846-24.374-8.455-12.33-24.071-26.167-40.163-36.484-14.498-9.295-29.383-15.735-39.767-15.643z"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#0C7DC1" stroke-width="7.6" d="M107.365 146.833c-14.923.131-14.596 13.413-8.655 26.556 3.388 7.496-10.372 11.557 4.436 32.263 11.398 15.938 28.305 17.717 48.528 26.682 14.913 6.612 28.385 7.472 29.775-9 .357-4.23 19.794-4.035 5.846-24.374-8.455-12.33-24.071-26.167-40.163-36.484-14.498-9.295-29.383-15.735-39.767-15.643z" fill="none"/>
      <path fill="#24D1E3" d="M113.29 173.606c7.328 13.975-6.694 18.773 20.35 33.736 21.548 11.922 36.989 20.134 36.88 3.347-.048-7.204 9.844-3.554 13.895-9.43-7.551-10.932-20.851-22.916-35.078-32.585-10.91-7.415-22.365-13.469-32.19-16.645-6.706 3.606-9.508 10.81-3.856 21.577z"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#095094" stroke-width="7.6" d="M107.365 146.833c-14.923.131-14.596 13.413-8.655 26.556 3.388 7.496-10.372 11.557 4.436 32.263 11.398 15.938 28.305 17.717 48.528 26.682 14.913 6.612 28.385 7.472 29.775-9" fill="none"/>
      <path fill="#FFF" d="M128.93 166.77c-1.312 2.494 10.033 8.061 18.657 15.354 14.044 11.875 19.89 16.95 21.045 12.82 1.466-5.235-36.432-34.394-39.703-28.174z" opacity=".33"/>
    </g>
    <g style="display:block">
      <path fill="#260468" d="M270.8 358.528c9.12-21.788-67.146-83.931-88.621-81.885-26.928 2.567-31.2 47.54-16.748 65.47 14.71 18.25 37.208 25.677 49.799 22.083 10.614-3.03 11.834-4.474 30.576-.815 13.516 2.638 22.343 1.477 24.993-4.853z" opacity=".2"/>
      <path fill="#9D20EF" d="M271.59 349.744c5.316-10.638-4.742-12.92-11.712-28.859-7.434-17-23.02-25.053-37.535-28.693-12.44-3.12-16.155-16.662-37.63-14.615-26.928 2.567-16.661 23.567-16.243 27.866.418 4.298-12.046 11.808 2.925 29.306s37.216 26.596 49.807 23.002c10.614-3.03 6.653-6.812 25.394-3.154 13.516 2.639 21.926 1.284 24.993-4.853z"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#5E18A8" stroke-width="7.6" d="M271.59 349.744c5.316-10.638-4.742-12.92-11.712-28.859-7.434-17-23.02-25.053-37.535-28.693-12.44-3.12-16.155-16.662-37.63-14.615-26.928 2.567-16.661 23.567-16.243 27.866.418 4.298-12.046 11.808 2.925 29.306s37.216 26.596 49.807 23.002c10.614-3.03 6.653-6.812 25.394-3.154 13.516 2.639 21.926 1.284 24.993-4.853z" fill="none"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#350482" stroke-width="7.6" d="M184.713 277.577c-26.928 2.567-16.661 23.567-16.243 27.866.418 4.298-12.046 11.808 2.925 29.306s37.216 26.596 49.807 23.002c10.614-3.03 6.653-6.812 25.394-3.154 13.516 2.639 21.926 1.284 24.993-4.853" fill="none"/>
      <path fill="#B443E8" d="M213.27 338.111c23.748-.414 18.84-6.24 40.702 1.536 12.14 1.176 1.095-26.767-12.416-34.913-13.511-8.147-21.114-8.4-28.272-13.507-7.159-5.107-45.222-15.491-31.484 13.844 4.506 9.62 7.722 33.454 31.47 33.04z"/>
      <path fill="#FFF" d="M220.835 303.642c-3.686-3.56-10.963-3.85-16.312-10.577-5.35-6.727-19.426-6.253-22.857-3.028-4.666 4.387 13.234 3.037 31.99 15.444 6.116 4.045 9.816.708 7.179-1.84z" opacity=".3"/>
    </g>
  </g>
</svg>
</file>

<file path="site/docs/public/icons/rocket.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" style="width:100%;height:100%;transform:translate3d(0,0,0)">
  <defs>
    <linearGradient id="P" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="-21.702" y1="-20.606" x2="11.96" y2="7.871">
      <stop offset="0%" stop-color="#525D66"/>
      <stop offset="45%" stop-color="#292E34"/>
      <stop offset="93%" stop-color="#000002"/>
    </linearGradient>
    <linearGradient id="O" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="M" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="N" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="L" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="J" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="K" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="I" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="H" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="G" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="E" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="F" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="D" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="B" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="C" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="A" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="y" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="z" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="x" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="w" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="v" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="-7.5" y1="52.5" x2="-1.5" y2="19.5">
      <stop offset="41%" stop-color="#7F0012"/>
      <stop offset="70%" stop-color="#7F0012"/>
      <stop offset="100%" stop-color="#7F0012"/>
    </linearGradient>
    <linearGradient id="u" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="-.75" y1="105.5" x2="3" y2="-11.25">
      <stop offset="41%" stop-color="#FFF652"/>
      <stop offset="70%" stop-color="#FBA929"/>
      <stop offset="100%" stop-color="#F75C00"/>
    </linearGradient>
    <linearGradient id="s" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="-83.37" y1="11.247" x2="83.835" y2="14.51">
      <stop offset="25%" stop-color="#3A93E8"/>
      <stop offset="36%" stop-color="#60ACE3"/>
      <stop offset="52%" stop-color="#85C5DF"/>
      <stop offset="73%" stop-color="#4387C2"/>
      <stop offset="93%" stop-color="#004AA4"/>
    </linearGradient>
    <linearGradient id="t" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="-84.374" y1=".477" x2="81.834" y2="3.24">
      <stop offset="4%" stop-color="#95A9B6"/>
      <stop offset="26%" stop-color="#C0CDD0"/>
      <stop offset="53%" stop-color="#EAF0EA"/>
      <stop offset="72%" stop-color="#919896"/>
      <stop offset="93%" stop-color="#374043"/>
    </linearGradient>
    <linearGradient id="o" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="-23.703" y1="51.655" x2="5.5" y2="9.714">
      <stop offset="41%" stop-color="#FFF652"/>
      <stop offset="70%" stop-color="#FBA929"/>
      <stop offset="100%" stop-color="#F75C00"/>
    </linearGradient>
    <linearGradient id="n" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="0" y1="0" x2="100" y2="0">
      <stop offset="41%" stop-color="#FFF652"/>
      <stop offset="70%" stop-color="#FBA929"/>
      <stop offset="100%" stop-color="#F75C00"/>
    </linearGradient>
    <linearGradient id="m" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="l" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="k" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="-26" y1="37" x2="-1.5" y2="4.5">
      <stop offset="41%" stop-color="#FFEB16"/>
      <stop offset="70%" stop-color="#FBA30B"/>
      <stop offset="100%" stop-color="#F75C00"/>
    </linearGradient>
    <linearGradient id="j" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="0" y1="0" x2="100" y2="0">
      <stop offset="41%" stop-color="#FFF652"/>
      <stop offset="70%" stop-color="#FBA929"/>
      <stop offset="100%" stop-color="#F75C00"/>
    </linearGradient>
    <linearGradient id="i" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="h" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="g" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="-23.703" y1="51.655" x2="5.5" y2="9.714">
      <stop offset="41%" stop-color="#FFF652"/>
      <stop offset="70%" stop-color="#FBA929"/>
      <stop offset="100%" stop-color="#F75C00"/>
    </linearGradient>
    <linearGradient id="e" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="0" y1="0" x2="100" y2="0">
      <stop offset="41%" stop-color="#FFF652"/>
      <stop offset="70%" stop-color="#FBA929"/>
      <stop offset="100%" stop-color="#F75C00"/>
    </linearGradient>
    <linearGradient id="f" spreadMethod="pad" gradientUnits="userSpaceOnUse" x1="-.75" y1="105.5" x2="3" y2="-11.25">
      <stop offset="41%" stop-color="#FFEB16"/>
      <stop offset="70%" stop-color="#FBA30B"/>
      <stop offset="100%" stop-color="#F75C00"/>
    </linearGradient>
    <linearGradient id="d" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <linearGradient id="c" spreadMethod="pad" gradientUnits="userSpaceOnUse">
      <stop/>
      <stop/>
      <stop/>
    </linearGradient>
    <clipPath id="a">
      <path d="M0 0h512v512H0z"/>
    </clipPath>
    <clipPath id="b">
      <path d="M0 0h512v728H0z"/>
    </clipPath>
    <clipPath id="R">
      <path d="M0 0h512v512H0z"/>
    </clipPath>
    <clipPath id="Q">
      <path d="M0 0h512v512H0z"/>
    </clipPath>
    <clipPath id="r">
      <path d="M0 0h512v512H0z"/>
    </clipPath>
    <clipPath id="q">
      <path d="M0 0h512v512H0z"/>
    </clipPath>
    <radialGradient id="p" spreadMethod="pad" gradientUnits="userSpaceOnUse" cx="-3.536" cy="-44.601" r="129.885" fx="-3.865" fy="-44.821">
      <stop offset="41%" stop-color="#FFF652"/>
      <stop offset="70%" stop-color="#FBA929"/>
      <stop offset="100%" stop-color="#F75C00"/>
    </radialGradient>
  </defs>
  <g clip-path="url(#a)">
    <g clip-path="url(#b)" style="display:block" transform="scale(1.01455) rotate(45 428.073 330.07)">
      <g style="display:block">
        <path fill="url(#f)" d="M6.637-21.854C-1.565-28.281-3.727-113.54-3.727-113.54l-14.18-.032s-1.559 91.813-5.708 98.76c.912.559 1.592 23.5 2.349 24.674-.169 2.161-.611 23.315-1.132 25.185 3.71 2.544 11.124 72.721 11.124 72.721l14.23-.262c2.054-6.653 3.413-93.259 3.619-97.651.05-1.057.073-10.435.081-11.187.016-1.41-.019-20.522-.019-20.522z" transform="matrix(-1 0 0 1 220.072 456.593)"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#7F0012" stroke-width="8" d="M213.435 434.739c8.202-6.427 10.364-91.686 10.364-91.686l14.18-.032s1.559 91.813 5.708 98.76c-.912.559-1.592 23.5-2.349 24.674.169 2.161.611 23.315 1.132 25.185-3.71 2.544-11.124 72.721-11.124 72.721l-14.23-.262c-2.054-6.653-3.413-93.259-3.619-97.651-.05-1.057-.073-10.435-.081-11.187-.016-1.41.019-20.522.019-20.522z" fill="none"/>
      </g>
      <g style="display:block">
        <path fill="url(#g)" d="M-10.977-113.785S-8.215-27.398-.344-21.952c0 0-.599 118.106-3.927 129.752 0 0-6.923-68.336-10.985-71.544 0 0 1.02-29.443 1.02-31.246l-2.65-19.209s4.089-86.855 5.909-99.586z" transform="matrix(-1 0 0 1 227.795 456.881)"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#7F0012" stroke-width="8" d="M238.772 343.096s-2.762 86.387-10.633 91.833c0 0 .599 118.106 3.927 129.752 0 0 6.923-68.336 10.985-71.544 0 0-1.02-29.443-1.02-31.246l2.65-19.209s-4.089-86.855-5.909-99.586z" fill="none"/>
      </g>
      <g style="display:block">
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#7F0012" stroke-width="8" d="M374.802 452.753C333 420 331.356 376.69 331.356 376.69h-.499s-8.857 62.559-30.005 97.963c4.648 2.846 11.647 6.096 15.508 12.082-.861 11.014-3.111 23.514-5.768 33.047 18.907 12.967 49.196 49.822 49.196 49.822l-.25-1c10.471-33.907 13.897-68.213 14.947-90.596.253-5.385.368-10.081.411-13.914.08-7.184-.094-11.341-.094-11.341z" fill="none"/>
      </g>
      <g style="display:block">
        <path fill="url(#k)" d="M-21.98-.19s-5.85-7.2-17.74-13.87c8.31-16.16 24.4-51.21 33.83-96.25-.12 1.41-.6 14.12 7.37 31.11v.01c.03.58 1.11 22.32-23.46 79zm44.46 83.04s-2.51-3.35-6.86-8.65v-.01C32.19 6.08 28.09-31.95 28.09-31.95-5.86-55.52-12.74-86.2-12.85-86.66c2.35-8.25 4.54-16.99 6.46-26.15-.21 2.51-1.58 40.8 45.61 75.36 0 0 3.25 54.33-16.74 120.3zM36.68-36.8S17.91 37.48-.03 55.3m-6.206-166.632S4.408-57.773 40.21-36.019c0 0-.303 59.247-17.264 118.601 0 0-31.038-35.354-51.739-51.702 0 0 6.198-24.715 6.198-33.903l-16.502-9.479s23.586-33.946 32.861-98.83z" transform="translate(336.593 488.022)"/>
        <path fill="#7F0012" d="M314.613 487.832s-5.85-7.2-17.74-13.87c8.31-16.16 24.4-51.21 33.83-96.25-.12 1.41-.6 14.12 7.37 31.11v.01c.03.58 1.11 22.32-23.46 79z" opacity=".4"/>
        <path fill="#FFF89C" d="M359.073 570.872s-2.51-3.35-6.86-8.65v-.01c16.574-68.112 12.47-106.14 12.47-106.14-33.95-23.57-40.83-54.25-40.94-54.71 2.35-8.25 4.54-16.99 6.46-26.15-.21 2.51-1.58 40.8 45.61 75.36 0 0 3.25 54.33-16.74 120.3z" opacity=".4"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#7F0012" stroke-width="6" d="M373.277 451.222s-18.777 74.278-36.714 92.1" fill="none" opacity=".1"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#7F0012" stroke-width="8" d="M330.357 376.69s10.644 53.559 46.446 75.313c0 0-.303 59.247-17.264 118.601 0 0-31.038-35.354-51.739-51.702 0 0 6.198-24.715 6.198-33.903l-16.502-9.479s23.586-33.946 32.861-98.83z" fill="none"/>
        <path stroke-linecap="round" stroke="#BC001B" stroke-width="8" d="M308 519.25s36.75 31.875 51.75 51.625" fill="none"/>
      </g>
      <g style="display:block">
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#7F0012" stroke-width="8" d="M120.992 457.503c41.802-32.753 52.821-87.063 52.821-87.063l-.501-.5s8.232 74.809 29.38 110.213c-4.648 2.846-8.397 7.096-12.258 13.082.861 11.014 3.111 21.014 5.768 30.547-18.907 12.967-56.696 62.072-56.696 62.072l.25-1c-10.471-33.907-17.397-79.712-18.447-102.095a391.012 391.012 0 0 1-.411-13.915c-.08-7.184.094-11.341.094-11.341z" fill="none"/>
      </g>
      <g style="display:block">
        <path fill="url(#o)" d="M-10.61-122.03s-.15 9.29 7.92 29.12c0 0-1.81 44.81-23.28 91.07-2.72-2.89-12.61-11.06-20.66-16C-39-34.72-15.06-69.21-10.61-122.03zm-.71-12s-.25 15.2 10.38 43.7C12.84-53.4 43.97-36.15 43.97-36.15s4.62 49.37-21 130.68c0 0-2.71-4.33-7.89-11.29C36.36 12.07 32.05-26.87 32.05-26.87c-46.36-34.71-48.38-69.73-48.58-79.12v-.01c2.04-8.86 3.81-18.22 5.21-28.03zm48 97.23S17.91 37.48-.03 55.3m-10.831-179.382S3.593-63.773 43.71-36.019c0 0-3.053 69.997-20.014 129.351 0 0-35.288-46.354-55.989-62.702 0 0 5.198-23.466 5.198-32.653l-19.252-18.479s26.211-38.696 35.486-103.58z" transform="matrix(-1 0 0 1 162.843 493.272)"/>
        <path fill="#7F0012" d="M173.45 371.246s.15 9.283-7.915 29.114c0 0 1.808 44.808 23.28 91.07 2.717-2.89 12.61-11.06 20.66-15.994-7.629-16.88-31.577-51.379-36.024-104.19z" opacity=".4"/>
        <path fill="#FFF89C" d="M174.162 359.237s.252 15.202-10.381 43.7c-13.779 36.93-44.91 54.19-44.91 54.19s-4.621 49.36 20.997 130.68c0 0 2.711-4.34 7.896-11.3-21.285-71.162-16.973-110.11-16.973-110.11 46.359-34.7 48.382-69.72 48.587-79.11v-.01a335.582 335.582 0 0 1-5.216-28.04z" opacity=".4"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#7F0012" stroke-width="6" d="M126.159 456.472s18.777 74.278 36.714 92.1" fill="none" opacity=".1"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#7F0012" stroke-width="8" d="M173.704 369.19s-14.454 60.309-54.571 88.063c0 0 3.053 69.997 20.014 129.351 0 0 35.288-46.354 55.989-62.702 0 0-5.198-23.466-5.198-32.653l19.252-18.479s-26.211-38.696-35.486-103.58z" fill="none"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#B80023" stroke-width="8" d="M119.277 460.021c.765 13.533 4.902 74.202 19.87 126.583 0 0 35.288-46.354 55.989-62.702 0 0-5.198-23.466-5.198-32.653l12.912-12.393" fill="none"/>
      </g>
      <path fill="url(#p)" d="M-89.985-80.563c-9.127 2.455-16.161 5.248-21.301 8.213-5.14 2.965-8.387 6.1-9.938 9.239-1.229 2.487-1.394 4.976-.594 7.384.8 2.408 2.565 4.734 5.197 6.895 0 0-8.056 4.773-11.801 10.762-3.745 5.988-3.179 13.192 14.065 18.054 0 0-3.984 3.15-4.68 7.215-.696 4.065 1.898 9.046 15.052 12.706 0 0-6.212 4.837-6.029 10.72.183 5.883 6.76 12.811 32.338 16.994 0 0-4.416 4.689-2.608 10.235 1.808 5.546 9.839 11.948 34.733 15.376-4.367 11.322 7.775 14.297 21.409 17.873 13.634 3.576 28.761 7.755 30.365 21.488.286-3.091-1.992-15.444 11.835-23.402 0 0 57.583-11.188 45.234-28.732 0 0 27.743-8.33 19.076-21.466 0 0 51.645-11.364 12.981-40.322 0 0 38.949-8.062 24.311-22.696 0 0 24.936-9.179 20.557-21.937-1.614-4.702-7.211-9.891-19.505-15.285-45.652-20.029-168.592-10.639-210.697.686z" transform="matrix(.35419 0 0 1 250.286 593.5)" style="display:block"/>
      <path fill="#FFF276" d="M-3.061-5.157C-8.547-1.441-.901 7.96 3.295 5.663 7.491 3.366 3.23-9.419-3.061-5.157z" transform="matrix(1 0 0 1.0367 217.354 562.388)" opacity=".5" style="display:block"/>
      <path fill="#FFF276" d="M-5.953-6.526C-9.955-1.609-3.341 10.917 4.485 8.283 12.311 5.649 1.15-15.252-5.953-6.526z" transform="matrix(1 0 0 1.0367 224.903 588.543)" opacity=".5" style="display:block"/>
      <path fill="#FFF276" d="M-8.607-1.148C-12.93 4.574-.129 9.815 8.73.222c4.298-4.654-11.174-9.527-17.337-1.37z" transform="matrix(1 0 0 1.0367 259.284 609.298)" opacity=".5" style="display:block"/>
      <path fill="#FFF276" d="M4.995-5.41c-9.321-8.183-19.684.608-11.973 9.943C.733 13.868 17.937 5.952 4.995-5.41z" transform="matrix(1 0 0 1.0367 231.923 613.67)" opacity=".5" style="display:block"/>
      <path fill="#FFF276" d="M-5.09-2.903C-9.684.377-.455 6.588 4.747 3.414 9.949.24 1.233-7.417-5.09-2.903z" transform="matrix(1 0 0 1.0367 245.334 628.399)" opacity=".5" style="display:block"/>
      <path fill="#FFF276" d="M6.624-6.338C1.348-11.614-12.833 2.012-6.255 6.541.323 11.07 11.9-1.062 6.624-6.338z" transform="matrix(1 0 0 1.0367 262.3 627.581)" opacity=".5" style="display:block"/>
      <path fill="#FFF276" d="M-6.457-5.616C-12.625-1.537-.302 11.435 6.362 4.727 13.026-1.982-.829-9.337-6.457-5.616z" transform="matrix(1 0 0 1.0367 234.513 638.408)" opacity=".5" style="display:block"/>
      <path fill="#FFF276" d="M5.525-4.246C1.453-7.839-8.386.166-5.602 4.518-3.649 7.57 8.873-1.292 5.525-4.246z" transform="matrix(1 0 0 1.0367 250.002 642.238)" opacity=".5" style="display:block"/>
      <path fill="#FFF276" d="M4.402-6.306C-2.184-8.14-10.975 2.632-5.651 5.975S13.17-3.864 4.402-6.306z" transform="matrix(1 0 0 1.0367 257.93 649.893)" opacity=".5" style="display:block"/>
      <path fill="#FFF276" d="M-2.852-3.11C-6.511.092-.639 5.916 3.242 2.985 6.07.849.368-5.928-2.852-3.11z" transform="matrix(1 0 0 1.0367 243.336 657.316)" opacity=".5" style="display:block"/>
      <g style="display:block">
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#F75C00" stroke-width="8" d="M216.727 512.937a33.023 33.023 0 0 0-2.959 2.505 30.415 30.415 0 0 0-2.283 2.43 28.287 28.287 0 0 0-1.967 2.635 27.023 27.023 0 0 0-2.004 3.608 25.855 25.855 0 0 0-1.963 6.273c-.879 4.974-.236 9.957 1.647 14.28 0 0-11.529 19.091.81 28.815 0 0-5.701 12.6 3.711 19.921 0 0-8.89 19.348 9.412 27.714 0 0-6.319 18.757 11.493 25.612-3.125 22.645 17.375 11.895 18.523 39.361.102-3.091-.713-15.444 4.234-23.402 0 0 20.602-11.189 16.184-28.733 0 0 9.925-8.33 6.824-21.466 0 0 18.477-11.364 4.644-40.322 0 0 13.935-8.062 8.698-22.696 0 0 8.921-9.179 7.354-21.937a25.695 25.695 0 0 0-1.202-5.195 28.668 28.668 0 0 0-1.497-3.557 32.194 32.194 0 0 0-1.349-2.424 37.658 37.658 0 0 0-2.93-4.108c-16.333-20.029-60.316-10.639-75.38.686z" fill="none"/>
      </g>
      <g style="display:block">
        <path fill="#FFEE4D" d="M193.866 603.675c-6.812-3.096-17.274 11.355-9.262 15.485 8.012 4.13 17.253-11.854 9.262-15.485z"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#F75C00" stroke-width="8" d="M193.866 603.675c-6.812-3.096-17.274 11.355-9.262 15.485 8.012 4.13 17.253-11.854 9.262-15.485z" fill="none"/>
      </g>
      <g style="display:block">
        <path fill="#FFEE4D" d="M301.818 629.997c-5.788 2.26-4.662 19.985 2.401 17.69 7.063-2.295 4.389-20.341-2.401-17.69z"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#F75C00" stroke-width="8" d="M301.818 629.997c-5.788 2.26-4.662 19.985 2.401 17.69 7.063-2.295 4.389-20.341-2.401-17.69z" fill="none"/>
      </g>
      <g style="display:block">
        <path fill="#FFEE4D" d="M200.104 633.115a1.365 1.365 0 1 1-1.932 1.932 1.365 1.365 0 1 1 1.932-1.932z"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#F75C00" stroke-width="8" d="M200.104 633.115a1.365 1.365 0 1 1-1.932 1.932 1.365 1.365 0 1 1 1.932-1.932z" fill="none"/>
      </g>
      <g style="display:block">
        <path fill="#FFEE4D" d="M280.638 632.081z"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#F75C00" stroke-width="0" d="M280.638 632.081s0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0z" fill="none"/>
      </g>
      <g style="display:block">
        <path fill="#FFEE4D" d="M260.638 656.831z"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#F75C00" stroke-width="0" d="M260.638 656.831s0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0z" fill="none"/>
      </g>
      <g clip-path="url(#q)" style="display:block" transform="translate(0 108)">
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(322.139 87.833)" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(322.139 85.892)" style="display:block"/>
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(188.468 87.771)" opacity=".3" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(188.468 85.83)" style="display:block"/>
      </g>
      <g clip-path="url(#r)" style="display:block" transform="matrix(1.29297 0 0 1.29297 -76.5 227)">
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(322.139 87.833)" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(322.139 85.892)" style="display:block"/>
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(188.468 87.771)" opacity=".3" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(188.468 85.83)" style="display:block"/>
      </g>
      <g style="display:block">
        <path fill="#282828" d="m207.579 487.969.707 22.275s11.661 6.673 44.052 6.673c32.223 0 45.759-6.828 45.759-6.828l1-21.552-7.525-7.7h-76.275l-7.718 7.132z"/>
        <path fill="#1D4861" d="M259.175 516.916V486.97l24.108-2.376v29.817l-24.108 2.505z"/>
        <path fill="#60673A" d="M283.283 486.428v27.983l-5.184.831v-28.049l5.184-.765z"/>
        <path fill="#2A5D77" d="M220.125 483.764v30.023l23.066 2.921V486.81l-23.066-3.046z"/>
        <path fill="#8E7949" d="M243.19 489.219v27.488h-4.828v-27.488h4.828z"/>
        <path fill="#60673A" d="M220.126 484.946v28.841l-3.398-.85v-28.696l3.398.705z"/>
        <path fill="#A0A0A0" d="M259.175 489.218v27.698l-15.984-.209v-27.489h15.984z"/>
        <path d="M207.579 487.969s12.877 7.766 46.292 7.766 45.226-7.198 45.226-7.198l-7.525-7.7h-76.275l-7.718 7.132z" opacity=".5"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#0F0F0F" stroke-width="8" d="m207.579 487.969.707 22.275s11.661 6.673 44.052 6.673c32.223 0 45.759-6.828 45.759-6.828l1-21.552-7.525-7.7h-76.275l-7.718 7.132z" fill="none"/>
        <path fill="url(#s)" d="M-33.028 176.827a13.853 13.853 0 0 1-8.814-6.596C-53.981 149.026-97.761 63.097-79.861-45.713c4.087-24.846 13.717-52.125 22.608-70.404 20.647-42.449 46.979-63.813 61.011-64.097 10.401-.21 35.568 17.999 56.945 64.497 9.717 21.135 17.7 49.938 21.501 83.031 11.08 96.465-29.446 180.58-41.386 202.868a13.862 13.862 0 0 1-9.785 7.101c-12.032 2.153-38.708 5.569-64.061-.456z" transform="translate(253.871 306.753)"/>
        <path fill="#000C66" d="M294.69 476.94a13.889 13.889 0 0 1-9.79 7.1c-12.03 2.15-38.7 5.57-64.06-.46a13.84 13.84 0 0 1-8.81-6.6c-7.99-13.94-26.65-55.87-35.45-113.9 0 0 .254.791.731 2.234.317.958.731 2.205 1.235 3.699 6.469 19.175 27.62 79.136 44.114 94.577 3.88 3.632 16.455 4.615 20.53 2.625 3.556-1.737 16.606-84.565 25.917-89.525 9.602-5.115 4.026 93.965 9.693 91.81 12.178-4.621 1.903-71.951 5.755-116.6.057-.667 32.116-1.344 32.165-2 4.305-57.139-3.057-115.892-17.637-159.354-.929-2.771-12.808-2.588-13.045-5.398-3.111-36.867-22.05-54.328-28.408-58.608 10.4-.21 35.57 18 56.94 64.5 9.72 21.13 17.7 49.93 21.51 83.03 11.08 96.46-29.45 180.58-41.39 202.87z" opacity=".3"/>
        <path fill="url(#t)" d="M81.486 79.977c-83.09 7.18-154.48.89-163.67.02-2.87-26.58-2.85-56.08 2.32-87.48 4.09-24.85 13.72-52.12 22.61-70.4 0 0 49.2-12.621 117.95.399 9.72 21.13 17.7 49.931 21.51 83.031 2.99 26.03 2.22 51.17-.72 74.43z" transform="translate(253.874 268.523)"/>
        <path fill="#101516" d="M335.36 348.5c-17.61 1.52-34.69 2.44-50.76 2.93 41.833-31.383 36.404-145.639-3.28-165 10.42.92 21.55 2.39 33.25 4.61 9.72 21.13 17.7 49.93 21.51 83.03 2.99 26.03 2.22 51.17-.72 74.43z" opacity=".1"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#FFF88F" stroke-width="8" d="M299.082 343.445a1003.872 1003.872 0 0 1-47.9 1.017" fill="none" opacity=".5"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#9FC6FF" stroke-width="8" d="M199.38 185.147s43.097-13.065 112.392 0" fill="none" opacity=".5"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#FFF" stroke-width="8" d="M291.058 151.586s-16.969-16.669-31.365-18.115c-14.396-1.446-40.343 28.106-52.371 52.735-7.025 14.384-26.916 48.326-30.035 130.949-1.089 28.846 3.205 79.901 3.205 79.901" fill="none" opacity=".45"/>
        <path stroke-miterlimit="10" stroke="#00479B" stroke-width="8" d="M220.843 483.58a13.853 13.853 0 0 1-8.814-6.596C199.89 455.779 156.11 369.85 174.01 261.04c4.087-24.846 13.717-52.125 22.608-70.404 20.647-42.449 46.979-63.813 61.011-64.097 10.401-.21 35.568 17.999 56.945 64.497 9.717 21.135 17.7 49.938 21.501 83.031 11.08 96.465-29.446 180.58-41.386 202.868a13.862 13.862 0 0 1-9.785 7.101c-12.032 2.153-38.708 5.569-64.061-.456z" fill="none"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#9FC6FF" stroke-width="8" d="M172.381 354.51c14.538 1.522 34.905 3.648 81.075 3.767 24.32.063 63.932-1.883 81.011-3.33" fill="none" opacity=".5"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#001147" stroke-width="8" d="M267.049 129.506c12.483 6.823 31.119 25.846 47.525 61.53 9.717 21.135 17.7 49.938 21.501 83.031 11.08 96.465-29.446 180.579-41.386 202.868a13.862 13.862 0 0 1-9.785 7.101c-12.032 2.153-38.708 5.569-64.061-.456a13.853 13.853 0 0 1-8.814-6.596C199.89 455.779 156.11 369.85 174.01 261.04" fill="none"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#5C626D" stroke-width="8" d="M335.36 348.5c-83.09 7.18-154.48.89-163.67.02-2.87-26.58-2.85-56.08 2.32-87.48 4.09-24.85 13.72-52.12 22.61-70.4 0 0 49.2-12.621 117.95.399 9.72 21.13 17.7 49.931 21.51 83.031 2.99 26.03 2.22 51.17-.72 74.43z" fill="none"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#20242D" stroke-width="8" d="m307.191 189.726 7.38 1.313c9.72 21.13 17.7 49.931 21.51 83.031 2.99 26.03 2.22 51.17-.72 74.43l-4.396.304" fill="none"/>
      </g>
      <g style="display:block">
        <path fill="url(#u)" d="m-8.25-59.5 5 25M5.25-23v11m7.53-6.519C-3.482-63.047-.416-111.332-.416-111.332h-12.999s-1.607 56.559-4.505 100.713c1.716 5.103 3.002 13.046 2.441 21.504-.631 9.519-3.451 19.557-2.701 24.376 7.157 45.967 11.446 80.321 11.446 80.321h13c5.491-37.34 6.115-80.162 6.526-105.46.099-6.087.128-11.405.123-15.753-.009-8.148-.135-12.888-.135-12.888z" transform="translate(282.522 488.022)"/>
        <path fill="#505459" d="m274.272 428.522 5 25"/>
        <path stroke="#F8643E" stroke-width="9" d="m274.272 428.522 5 25" fill="none"/>
        <path fill="#505459" d="M287.772 465.022v11"/>
        <path stroke="#FCB611" stroke-width="9" d="M287.772 465.022v11" fill="none"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#BC001B" stroke-width="8" d="M295.302 469.503c-16.262-44.528-13.196-92.813-13.196-92.813h-12.999s-1.607 56.559-4.505 100.713c1.716 5.103 3.002 13.046 2.441 21.504-.631 9.519-3.451 19.557-2.701 24.376 7.157 45.967 11.446 80.321 11.446 80.321h13c5.491-37.34 6.115-80.162 6.526-105.46.099-6.087.128-11.405.123-15.753-.009-8.148-.135-12.888-.135-12.888z" fill="none"/>
      </g>
      <g style="display:block">
        <path fill="url(#v)" d="M-15.23-9.94s14.9 1.8 3.01-4.87c8.31-16.16-1.98-46.96 7.45-92-.12 1.41.05-.21 1-.89 0 0-2.75 24.25-2.75 24.26.03.58-.84 14.17-8.71 73.5zM9.05-16.5S5.35 17.39-6.23 69.65m4.244-180.982S-5.552-63.047 10.71-18.519c0 0 2.774 66.69-6.514 129.851 0 0-7.748-34.992-13.989-73.702 0 0 1.448-21.715 1.448-30.903l-2.752-20.729s-.164-32.446 9.111-97.33z" transform="translate(271.093 488.022)"/>
        <path fill="#7F0012" d="M255.863 478.082s14.9 1.8 3.01-4.87c8.31-16.16-1.975-46.96 7.455-92-.12 1.41.047-.212.995-.89 0 0-2.75 24.25-2.75 24.26.03.58-.836 14.168-8.71 73.5z" opacity=".4"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#BC001B" stroke-width="6" d="M280.145 471.525s-3.704 33.891-15.286 86.148" fill="none" opacity=".4"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke="#510013" stroke-width="8" d="M269.107 376.69s-3.566 48.285 12.696 92.813c0 0 2.774 66.69-6.514 129.851 0 0-7.748-34.992-13.989-73.702 0 0 1.448-21.715 1.448-30.903l-2.752-20.729s-.164-32.446 9.111-97.33z" fill="none"/>
      </g>
      <path fill="#FF1A1A" d="M2.889-53.926c-21.028-.815-40.364 15.529-44.15 50.235C-44.95 30.126-29.77 53.955-4.929 53.955c27.843 0 45.585-27.322 46.693-55.829.963-24.775-12.794-51.041-38.875-52.052z" transform="translate(217.985 270.51)" style="display:block"/>
      <path fill="#FFF89C" d="M-11.191 1.188c2.815 12.848 24.116 9.765 21.653-4.662-2.463-14.427-24.468-8.186-21.653 4.662z" transform="translate(219.377 315.964)" opacity=".4" style="display:block"/>
      <path fill="#FFF89C" d="M-3.317-10.529c10.215-6.626 19.416 23.071 5.825 25.528-6.304 1.14-21.159-15.582-5.825-25.528z" transform="translate(247.901 247.208)" opacity=".4" style="display:block"/>
      <path fill="url(#P)" d="M1.957-39.122c-16.975 0-28.42 18.574-30.314 37.507-1.894 18.933 6.397 38.937 23.214 40.614 19.045 1.9 31.933-18.49 33.599-38.08 1.682-19.773-9.498-40.041-26.499-40.041z" transform="matrix(.95494 0 0 1 214.127 269.606)" style="display:block"/>
      <path fill="#FFF" d="M-25.385-6.081c-3.959 22.387 5.717 36.97 24.775 42.992 0 0-22.138-10.643-14.15-45.995 6.103-27.009 29.684-27.34 36.029-20.615-4.113-11.495-38.64-21.698-46.654 23.618z" transform="translate(212.344 271.694)" opacity=".2" style="display:block"/>
      <path stroke-miterlimit="10" stroke="#000" stroke-width="8" d="M1.957-39.122c-16.975 0-28.42 18.574-30.314 37.507-1.894 18.933 6.397 38.937 23.214 40.614 19.045 1.9 31.933-18.49 33.599-38.08 1.682-19.773-9.498-40.041-26.499-40.041z" fill="none" transform="translate(214.127 269.606)" style="display:block"/>
      <path stroke-miterlimit="10" stroke="#AF0022" stroke-width="8" d="M2.889-53.926c-21.028-.815-40.364 15.529-44.15 50.235C-44.95 30.126-29.77 53.955-4.929 53.955c27.843 0 45.585-27.322 46.693-55.829.963-24.775-12.794-51.041-38.875-52.052z" fill="none" transform="translate(217.985 270.51)" style="display:block"/>
      <path stroke-linecap="round" stroke-linejoin="round" stroke="#7F0012" stroke-width="8" d="M-35.723-28.823C-39.412 4.994-24.232 28.823.609 28.823c15.299 0 27.548-8.249 35.664-20.411" fill="none" transform="translate(212.447 295.642)" style="display:block"/>
      <g clip-path="url(#Q)" style="display:block" transform="translate(0 108)">
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(259.076 87.521)" opacity=".3" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(259.076 85.58)" style="display:block"/>
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(218.694 87.896)" opacity=".3" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(218.694 85.955)" style="display:block"/>
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(300.33 87.833)" opacity=".5" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(300.33 85.892)" style="display:block"/>
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(190.531 87.833)" opacity=".3" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(190.531 85.892)" style="display:block"/>
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(322.139 87.833)" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(322.139 85.892)" style="display:block"/>
      </g>
      <g clip-path="url(#R)" style="display:block" transform="matrix(1.29297 0 0 1.29297 -76.5 227)">
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(259.076 87.521)" opacity=".3" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(259.076 85.58)" style="display:block"/>
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(218.694 87.896)" opacity=".3" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(218.694 85.955)" style="display:block"/>
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(300.33 87.833)" opacity=".5" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(300.33 85.892)" style="display:block"/>
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(190.531 87.833)" opacity=".3" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(190.531 85.892)" style="display:block"/>
        <path fill="#101516" d="M5.429 0A5.428 5.428 0 0 1 0 5.429 5.428 5.428 0 0 1-5.429 0 5.428 5.428 0 0 1 0-5.429 5.428 5.428 0 0 1 5.429 0z" transform="translate(322.139 87.833)" style="display:block"/>
        <path fill="#E1EDF0" d="M3.489 0a3.489 3.489 0 1 1-6.978 0A3.489 3.489 0 0 1 3.49 0z" transform="translate(322.139 85.892)" style="display:block"/>
      </g>
    </g>
  </g>
</svg>
</file>

<file path="site/docs/public/images/grammY.svg">
<?xml version="1.0" encoding="UTF-8"?><svg width="1080" height="auto" id="Layer_2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 423.61 156.32"><defs><style>.cls-1{fill:url(#linear-gradient);}.cls-2{fill:#7acbe3;}</style><linearGradient id="linear-gradient" x1="-372.73" y1="737.41" x2="-348.01" y2="770.16" gradientTransform="translate(1408.47 2170.42) scale(2.83 -2.83)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#009dca"/><stop offset="1" stop-color="#fff"/></linearGradient></defs><g id="svg8"><path id="path965" class="cls-2" d="m56.8,80.12h-7.4v9.7c-5.5-7.6-12.2-11-21.5-11-16,0-27.9,12.4-27.9,28.9s12.4,28.4,28.5,28.4c9.9,0,16.6-4,20.9-12.4v3.7c0,5.4-.6,8.8-2.2,12.2-2.9,6.3-9.4,9.9-17.9,9.9-6.1,0-10.8-1.8-14.7-5.5-1.9-1.7-3.1-3.4-5.4-7.5H2c4,12.8,13.7,19.8,27.5,19.8,9.5,0,17.5-3.6,22.2-9.8,3.7-5,5.1-10.8,5.1-21.5v-44.9Zm-28.4,5.5c11.8,0,21,9.3,21,21.2,0,12.8-9,22.5-20.9,22.5s-21-9.5-21-22.2,8.8-21.5,20.9-21.5Z"/><path id="path967" class="cls-2" d="m69.9,134.82h7.4v-31.9c-.1-9.9,5.4-16,15.5-16.8v-7.3c-7.9.4-12.6,3.1-15.5,9.1v-7.8h-7.4v54.7Z"/><path id="path969" class="cls-2" d="m155.4,80.12h-7.4v9.7c-5.5-7.6-12.1-11-21.6-11-16.4,0-28.8,12.4-28.8,28.8s12.5,28.5,29.4,28.5c9.3,0,15.1-3,21-10.9v9.6h7.4v-54.7Zm-28.8,5.5c12.1,0,21.4,9.4,21.4,21.6s-9.2,22.1-21,22.1c-12.4,0-21.9-9.7-21.9-22.2s9.6-21.5,21.5-21.5h0Z"/><path id="path971" class="cls-2" d="m168,134.82h7.4v-31.9c0-10.9,5.5-17.3,14.7-17.3,4.5,0,8.7,1.8,11.4,5,2.4,2.8,3.4,6.6,3.4,12.3v31.9h7.4v-31.7c0-5.3.8-8.6,2.6-11.3,2.6-3.9,7.2-6.2,12.4-6.2,4.8,0,9,1.9,11.5,5.2,2,2.7,3,6.8,3,12.3v31.7h7.4v-32.5c0-7.2-1.3-11.8-4.4-15.8-3.8-4.9-10-7.7-17.1-7.7-8.5,0-14.4,3.2-19,10.5-4.3-7.4-9.6-10.5-17.9-10.5-6.9,0-11.1,2.1-15.4,7.6v-6.3h-7.4v54.7Z"/><path id="path973" class="cls-2" d="m261.8,134.82h7.4v-31.9c0-10.9,5.5-17.3,14.7-17.3,4.5,0,8.7,1.8,11.4,5,2.4,2.8,3.4,6.6,3.4,12.3v31.9h7.4v-31.7c0-5.3.8-8.6,2.6-11.3,2.6-3.9,7.2-6.2,12.4-6.2,4.8,0,9,1.9,11.5,5.2,2,2.7,3,6.8,3,12.3v31.7h7.4v-32.5c0-7.2-1.3-11.8-4.4-15.8-3.8-4.9-10-7.7-17.1-7.7-8.5,0-14.4,3.2-19,10.5-4.3-7.4-9.6-10.5-17.9-10.5-6.9,0-11.1,2.1-15.4,7.6v-6.3h-7.4v54.7Z"/><path id="path895" class="cls-1" d="m323.33,38.7h15.89l23.94,31.74L411.11,6.32l12.5-6.32-2.28,12.84-50.84,69.9v52.08h-14.87v-52.08l-32.29-44.04Z"/></g></svg>
</file>

<file path="site/docs/public/images/Y.svg">
<?xml version="1.0" encoding="UTF-8"?><svg width="1080" height="1080" id="Layer_2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 320 320"><defs><style>.cls-1{fill:none;}.cls-2{fill:url(#linear-gradient);}</style><linearGradient id="linear-gradient" x1="-483.3" y1="830.09" x2="-424.63" y2="907.83" gradientTransform="translate(1503.28 2543.19) scale(2.83 -2.83)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#009dca"/><stop offset="1" stop-color="#fff"/></linearGradient></defs><g id="Y"><rect class="cls-1" width="160" height="320"/><rect class="cls-1" x="160" width="160" height="320"/><path id="path895" class="cls-2" d="m65.44,91.86h37.72l56.84,75.33L273.8,15.01l29.66-15.01-5.41,30.48-120.66,165.91v123.6h-35.29v-123.6l-76.65-104.53Z"/></g></svg>
</file>

<file path="site/docs/resources/about.md">
---
next:
  text: FAQ
  link: ./faq
---

# About grammY

## What is grammY?

grammY is a piece of software that you can use when you want to program your own [chat bot](https://core.telegram.org/bots) for the [Telegram Messenger](https://telegram.org).
When you make bots, you will notice that some parts of this process are tedious and always the same.
grammY does the heavy lifting for you and makes it super simple to create a bot.

## When was grammY created?

The first publish of grammY code was in late March, 2021.
It reached its first stable version a few weeks later.

## Who develops grammY?

grammY is developed by a team of volunteers who work on the core library, the docs, and the remaining ecosystem in their free time.
You can find a list of all our contributors in the [README](https://github.com/grammyjs/grammY#contributors-) of our repository.

Feel free to make contact in the [group chat](https://t.me/grammyjs)!
If you speak Russian, you can also join us [here](https://t.me/grammyjs_ru)!

## How is grammY developed?

grammY is completely free and open-source software.
Its code is available on [GitHub](https://github.com/grammyjs/grammY).

We welcome all contributions.
All code changes are reviewed by several pairs of eyes, optimized iteratively and tested extensively, often using production code of various projects and people.

## What programming language does grammY use?

grammY is written from the ground up in TypeScript---a superset of JavaScript.
Therefore, it runs on Node.js.

However, grammY can also run on Deno, which positions itself as the successor of Node.js.
(Technically, you can even run grammY on modern browsers, though this will rarely be useful.)

## How does grammY compare to its competitors?

If you're coming from a different programming language or framework, you can check out our [detailed comparison between frameworks](./comparison).

## How can I support you?

There are a number of great ways to support this project!

- Contribute code via a [pull request](https://github.com/grammyjs/grammY/pulls).
- [File an issue](https://github.com/grammyjs/grammY/issues/new) about a bug you discovered, a feature you'd like to have, or anything else.
- Help out with the [Documentation](https://github.com/grammyjs/website).
- Assist people in the community chats in [English](https://t.me/grammyjs) or [Russian](https://t.me/grammyjs_ru).
- Or just come tell us what you think!
  Leaving a few words about your favorite feature helps us determine the direction of the project.

Currently, we do not take any donations or other financial support.
</file>

<file path="site/docs/resources/comparison.md">
---
next: false
---

# How grammY Compares to Other Bot Frameworks

While grammY uses some concepts known from other bot frameworks (and web frameworks), it was written from scratch for optimal readability and performance.

> Please assume that this comparison is biased, even though we're trying to provide you with an objective description of the advantages and disadvantages of using grammY over using other libraries.
> We are trying to keep things in this article up-to-date.
> If you notice that anything is outdated, please edit this page using the link at the bottom.

## Comparison With Other JavaScript Frameworks

::: tip Choose Your Programming Language First
Given that you're reading the docs of a framework within the JavaScript ecosystem, you are likely looking for something to run on Node.js or Deno.
However, if that's not you, [scroll down](#comparison-with-frameworks-in-other-programming-languages) for a comparison of what programming languages are suited for bot development.
Naturally, you will also find a brief comparison against frameworks of other languages (mainly Python).
:::

There are two main projects that grammY takes inspiration from, namely [Telegraf](https://github.com/telegraf/telegraf) and [NTBA](https://github.com/yagop/node-telegram-bot-api).
We will focus on them for now, but we (or you?) may add other comparisons in the future.

### Telegraf

grammY has its roots in Telegraf, so here is a brief summary of how these frameworks relate historically.

When grammY was created, Telegraf was an amazing library, and grammY would not be where it is without it.
However, Telegraf used to be written in JavaScript (in v3).
The rare type annotations were manually added and poorly maintained, so they were incomplete, incorrect, and outdated.
Strong type annotations are a crucial aspect of any serious library for the tooling support they enable, and because it allows you to iterate significantly faster on your code base.
Many people prefer to have type safety when developing a complex bot, and for some it's a deal-breaker not to offer it.

Telegraf v4 attempted to fix this by migrating the entire code base to TypeScript.
Unfortunately, many of the resulting types were so complex that they were too hard to understand (but correct).
Moreover, the migration revealed countless oddities ([example](https://github.com/telegraf/telegraf/issues/1076)) in the code base that made it painful to even find correct typings for the existing code at all.

As a result, even though version 4.0 tried to _improve_ correctness and tooling support, it ended up making Telegraf substantially _harder to use_ than its untyped predecessor.
Understandably, many existing users of Telegraf 3 were unwilling to upgrade.
It also got harder for new users to get started.

**grammY takes a step back and rethinks a type-safe bot framework with approachability first.**
This allowed to skip a lot of the frustrating discussions around how to cope with strange internal typings.
It enabled the project to have clean, consistent, compiling code that provides users with excellent types (=editor support).
Type safety in turn permits more advanced features that fundamentally change how we think about bot development, such as [API transformers](../advanced/transformers).

Even though Telegraf 3 is still used by many active bots, the library is widely outdated.
Furthermore, the plugin ecosystem of Telegraf has moved on to Telegraf 4 (at least those that were not migrated to grammY).

This comparison only compares grammY to Telegraf 4.

Here is a list of reasons why you should use grammY instead of Telegraf.

- grammY always supports the latest version of the Bot API.
  Telegraf often lags behind by a few versions.
- grammY has a [documentation](../).
  Telegraf does not---it was replaced by a generated API reference that lacks explanations, and the few guides that exist are incomplete and hard to find.
- grammY embraces TypeScript, the types _just work_ and they will follow your code.
  In Telegraf, you will often need to write your code a certain way, otherwise it does not compile (even though it would actually run fine).
- grammY integrates hints from the [official Bot API reference](https://core.telegram.org/bots/api) inline that help you while you're coding.
  Telegraf does not give you any explanations on your code.
- Many more things like better performance, a large plugin ecosystem, documentation that is translated for billions of people, better integration with databases and web frameworks, better runtime compatibility, a [VS Code extension](https://marketplace.visualstudio.com/items?itemName=grammyjs.grammyjs), and a number of other things that you will discover as you go.

Here is a list of reasons why you should use Telegraf instead of grammY.

- You already have a large bot written in Telegraf and you no longer really work on it.
  In that case, migrating to grammY may take more time than you will save in the long run, no matter how smooth the migration is.
- You know Telegraf like the back of your hand and you do not care about changing your skill set.
  grammY introduces a number of novel concepts that can be unfamiliar if you have used Telegraf only, and using grammY means that you will be exposed to new things.
- There are a few details where Telegraf and grammY use different syntax to achieve the same thing, and you just happen to prefer one style over the other.
  For instance, Telegraf uses `bot.on(message("text"))` and grammY uses `bot.on("message:text")` to listen for text messages.

### NTBA

The `node-telegram-bot-api` package is the second big project that impacted the development of grammY.
Its main advantage over other frameworks is that it just is dead simple.
Its architecture can be described in a single sentence, while grammY needs a [guide](../guide/) on its documentation website to do the same.
We believe that all these explanations on the grammY website help people to get started easily, but it is tempting to have a library which does not need any explanations in the first place.

On the downside, this is only good in the short-term perspective.
The idea of putting everything in a gigantic file, and using a primitive `EventEmitter` to process streams of complex objects (aka. web requests) has brought a lot of pain to the world of Telegram bots, and it certainly prevented a number of good ideas from being implemented.

Bots always start small, but a responsible framework must provide them a clear path to grow, and to scale up.
Unfortunately, NTBA fails horribly at doing that.
Any code base with more than 50 lines that uses NTBA ends up being a terrible mess of spaghetti-like cross-references.
You don't want that.

### Other Frameworks

There currently are no other TypeScript libraries that are worth using for building bots.
Everything except grammY, Telegraf, and NTBA is largely unmaintained and thus horribly out of date.

Did you just create a new awesome library and we are not aware of it yet?
Feel free to edit this page and add a comparison---or tell us what you think in the [group chat](https://t.me/grammyjs)!

## Comparison With Frameworks in Other Programming Languages

There are reasons to favor a different programming language over TypeScript.
The most important thing is that you like working with your tools and languages.
If you are determined to stick with a different language, then you can stop reading here.

Given that you're still reading, you may want to know why grammY is written in TypeScript, and why you should maybe consider picking this language for your bot, too.

This section will outline how TypeScript has a few advantages over other languages when it comes to developing Telegram bots.
This comparison will be limited to Python, Go, and Rust.
Feel free to add more sections if you want to contrast TypeScript with another language.

Some of the following points are partially based on personal opinions.
People have different taste, so take this section with a grain of salt.

### Frameworks Written in Python

A clear case can be made when comparing TypeScript to Python.
Pick TypeScript and you will enjoy:

1. **Better editor tooling.**
   The type annotations of grammY are outstanding.
   While Python did introduce types in its 3.5 release, they are not used as commonly in the ecosystem as it is the case with JavaScript/TypeScript.
   Hence, they cannot compare to what you get out of the box with grammY and its accompanying libraries.
   With the types come auto-completion at every step of development, as well as helpful tooltips with explanations and links.

2. **Easier to scale up code base.**
   The type system has a second advantage---it lets you scale the code base of your bot.
   This is much harder to do for projects written in a language with worse type safety.

3. **Easier to scale up load.**
   If your bot actually starts to get popular, it is significantly easier to scale bots written in JS rather than in Python.

4. **Higher responsiveness of your bot.**
   Right now, V8 and its competitors make JavaScript the world's fastest scripting language.
   If you like your bot to be as fast as possible while still enjoying a dynamic language, then grammY is your best bet.

As always, programming languages excel at certain tasks and should be avoided for others.
This is no exception.

For example, with the current state of the ecosystems, anything related to machine learning should not be done in JavaScript.
However, when it comes to web servers, TypeScript tends to be a much better choice.

### Frameworks Written in Go

If you are proficient in both TypeScript and Go, then a reasonable metric for deciding on a language for your bot is the balance between development speed and execution speed.

Pick grammY if you are not completely sure what you are building.
TypeScript lets you iterate on your code base at incredible speeds.
It is great for rapid prototyping, trying out new things, getting to know bots, and getting things done quickly.
As a rule of thumb, processing ~100,000,000 updates per day can be done easily with TypeScript, but going beyond that will require extra work, such as using one more grammY plugin.

Pick a library written in Go if you already know fairly well what you will be building (you don't expect to need much assistance), and you already know that your bot will process a very large number of updates.
As a natively compiled language, Go outperforms TypeScript at raw CPU speed by several orders of magnitude.
This is much less relevant when you write a bot because most of the time is spent waiting for the network, but eventually, it will start to matter how fast your bot can parse JSON.
Go can be a better choice in these cases.

Another metric is developer experience (DX).
In general, Go and TypeScript are both known to have extremely good tooling and editor support.
However, for the Bot API in particular, grammY is significantly better than any library written in Go.
This is mainly due to TypeScript's advanced type system which grammY leverages in sophisticated ways.
As a result, you can explore the Bot API interactively right from inside your editor.
This is not possible to the same extent using any library written in Go.
If you want the best DX, use grammY.

### Frameworks Written in Rust

A similar point can be made [as with Go](#frameworks-written-in-go), but it is even stronger with Rust.
In a way, it will take you even more time to write Rust, but your bot will be even faster, too.

Also, please note that using Rust is fun but rarely necessary for bots.
If you want to use Rust, then do it, but consider saying that you love Rust and not that it is the right tool for the job.

## How to Disagree With This Comparison

If you think that something is wrong on this page, don't despair!
Please let us know in the [group chat](https://t.me/grammyjs)!
We'd love for you to educate us about your perspective.
Naturally, you can also just edit this page on GitHub, or file an issue there to point out mistakes or suggest other things.
This page will always have room to be more objective, and more fair.
</file>

<file path="site/docs/resources/faq.md">
---
prev:
  text: About grammY
  link: ./about
---

# FAQ

Here is a collection of frequently asked questions that did not fit anywhere else.
Questions regarding [common errors](#why-am-i-getting-this-error) and [Deno things](#questions-about-deno) were grouped in the two dedicated sections.

If this FAQ does not answer your question, you should also have a look at the [Bot FAQ](https://core.telegram.org/bots/faq) written by the Telegram team.

## Where Can I Find Docs About a Method?

In the API reference.
You probably want to understand [this](../guide/) better.

## A Method Is Missing a Parameter!

No, it's not.

1. Make sure you have the latest grammY version installed.
2. Check [here](https://core.telegram.org/bots/api) if the parameter is optional.
   If it is, then grammY will collect it in the options object called `other`.
   Pass `{ parameter_name: value }` in that place and it'll work.
   As always, TypeScript will auto-complete the parameter names for you.
3. Perhaps double-check the method signature for [actions](../guide/context#available-actions) on `ctx` [here](/ref/core/context#methods), or for API methods (`ctx.api`, `bot.api`) [here](/ref/core/api#methods).

## How Can I Access the Chat History?

You can't.

Telegram does not store the messages for your bot.

Instead, you need to wait for new messages/channel posts to arrive, and store the messages in your database.
You can then load the chat history from your database.

This is what [conversations](../plugins/conversations) do internally for the relevant part of the message history.

## How Can I Handle Albums?

You can't ... at least not in the way you think.

An album only really exists in the UI of a Telegram client.
For a bot, handling a media group is the same thing as handling a series of individual messages.
The most practical advice is to ignore that media groups exist, and to simply write your bot with individual messages in mind.
Albums will then work automatically.
For example, you can ask the user to [click a button](../plugins/keyboard#inline-keyboards) or send `/done` when all files are uploaded to your bot's chat.

_But if a Telegram client can do it, then my bot should be able to do the same thing!_

Yes and no.
Technically, there is the `media_group_id` which lets you determine the messages that belong to the same album.
However,

- there is no way of knowing the number of messages in an album,
- there is no way of knowing when the last message in an album was received, and
- other messages such text messages, service messages, etc may be sent in between album messages.

So yes, in theory, you can know which messages belong together, but only regarding the messages you have received so far.
You cannot know if there will be more messages added to the album at a later point.
If you ever receive an album on a Telegram client while having _extremely_ bad internet connection, you can actually see how the client repeatedly regroups the album as new messages arrive.

## Why Am I Getting This Error?

### 400 Bad Request: Cannot parse entities

You are sending a message with formatting, i.e. you're setting `parse_mode` when sending a message.
However, your formatting is broken, so Telegram does not know how to parse it.
You should re-read the [section about formatting](https://core.telegram.org/bots/api#formatting-options) in the Telegram docs.
The byte offset that is mentioned in the error message will tell you where exactly the error is in your string.

::: tip Passing entities instead of formatting
You can pre-parse the entities for Telegram if you want, and specify `entities` when sending your message.
Your message text could then be a regular string.
That way, you don't have to worry about escaping weird characters.
This may look like it needs more code, but in fact it is the far more reliable and fool-proof solution to this problem.
Most importantly, this is greatly simplified by our [parse-mode plugin](../plugins/parse-mode).
:::

### 401 Unauthorized

Your bot token is wrong.
Maybe you think it's right.
It is not.
Talk to [@BotFather](https://t.me/BotFather) to see what your token is.

### 403 Forbidden: bot was blocked by the user

You probably tried to send a message to a user and then you ran into this issue.

When a user blocks your bot, you are not able to send messages to them or interact with them in any other way (except if your bot was invited to a group chat where the user is a member).
Telegram does this to protect their users.
You cannot do anything about it.

You can either:

- Handle the error and for example delete the user's data from your database.
- Ignore the error.
- Listen for `my_chat_member` updates via `bot.on("my_chat_member")` in order to be notified when the user blocks your bot.
  Hint: Compare the `status` fields of the old and the new chat member.

### 404 Not found

If this happens while starting your bot, then your bot token is wrong.
Talk to [@BotFather](https://t.me/BotFather) to see what your token is.

If your bot works fine most of the time, but then suddenly you're getting a 404, then you're doing something very funky.
You can come ask us in the [group chat](https://t.me/grammyjs) (or the [Russian-speaking group chat](https://t.me/grammyjs_ru)).

### 409 Conflict: terminated by other getUpdates request

You are accidentally running your bot twice on long polling.
You can only run one instance of your bot.

If you think that you only run your bot once, you can just revoke the bot token.
That will stop all other instances.
Talk to [@BotFather](https://t.me/BotFather) to do this.

### 429: Too Many Requests: retry after X

Congratulations!
You ran into an error that is among the most difficult ones to fix.

There are two possible scenarios:

**One:** Your bot does not have many users.
In that case, you are just spamming the Telegram servers by sending too many requests.
Solution: don't do that!
You should seriously think about how to reduce the number of API calls substantially.

**Two:** Your bot is getting very popular and it has a lot of users (hundreds of thousands).
You have already made sure to use the minimum number of API calls for the most common operations of your bot, and _still_ you're running into these errors (called flood wait).

There are a few things you can do:

1. Read this [article](../advanced/flood) in the docs to gain a basic understanding of the situation.
2. Use the [`auto-retry` plugin](../plugins/auto-retry).
3. Come ask us in the [group chat](https://t.me/grammyjs) for help.
   We have experienced people there.
4. It is possible to ask Telegram to increase the limits, but this is very unlikely to happen if you did not do steps 1-3 first.

### Cannot find type definition file for 'node-fetch'

This is the result of some missing type declarations.

The recommended way to fix this is to set `skipLibCheck` to `true` in your TypeScript compile options.

If you are sure that you need this option to be kept to `false`, you can instead install the missing type definitions by running `npm i -D @types/node-fetch@2`.

## Questions About Deno

### Why do you support Deno?

Some important reasons why we like Deno more than Node.js:

- It's simpler and faster to get started.
- The tooling is substantially better.
- It natively executes TypeScript.
- No need to maintain `package.json` or `node_modules`.
- It has a reviewed standard library.

> Deno was founded by Ryan Dahl---the same person that invented Node.js.
> He summarized his 10 regrets about Node.js in this [video](https://youtu.be/M3BM9TB-8yA).

grammY itself is Deno-first, and it is backported to support Node.js equally well.
</file>

<file path="site/docs/404.md">
---
layout: page
---

<!-- markdownlint-disable first-line-heading no-inline-html single-trailing-newline-->
<NotFound />
</file>

<file path="site/docs/README.md">
---
layout: home
titleTemplate: false

hero:
  name: grammY
  text: The Telegram Bot Framework.
  taglines:
    - think of the whY.
    - a new era of bot development.
    - runs faster than you.
    - have fun making bots.
    - one update ahead.
    - can do anything except dishes.
    - easy peasy lemon squeezY.
    - billions and billions served.
    - powered by obsession.
  image:
    src: /images/Y.svg
    alt: grammY logo
  actions:
    - theme: brand
      text: Get Started
      link: ./guide/getting-started
    - theme: alt
      text: Documentation
      link: ./guide/

features:
  - icon: <lazy-tgs-player class="VPImage" src="/icons/beach-animation.tgs"><img src="/icons/beach.svg" alt="beach animation"></lazy-tgs-player>
    title: Easy-to-use
    details: grammY makes creating Telegram bots so simple you already know how to do it.
  - icon: <lazy-tgs-player class="VPImage" src="/icons/palette-animation.tgs"><img src="/icons/palette.svg" alt="palette animation"></lazy-tgs-player>
    title: Flexible
    details: grammY is open and can be extended by plugins to make it fit exactly your needs.
  - icon: <lazy-tgs-player class="VPImage" src="/icons/rocket-animation.tgs"><img src="/icons/rocket.svg" alt="rocket animation"></lazy-tgs-player>
    title: Scalable
    details: grammY has you covered when your bot gets popular and the traffic increases.
---

<!-- markdownlint-disable no-inline-html -->

## Quickstart

Bots are written in [TypeScript](https://www.typescriptlang.org) (or JavaScript) and run on various platforms, including [Node.js](https://nodejs.org).

`npm install grammy` and paste the following code:

::: code-group

```ts [TypeScript]
import { Bot } from "grammy";

const bot = new Bot(""); // <-- put your bot token between the "" (https://t.me/BotFather)

// Reply to any message with "Hi there!".
bot.on("message", (ctx) => ctx.reply("Hi there!"));

bot.start();
```

```js [JavaScript]
const { Bot } = require("grammy");

const bot = new Bot(""); // <-- put your bot token between the "" (https://t.me/BotFather)

// Reply to any message with "Hi there!".
bot.on("message", (ctx) => ctx.reply("Hi there!"));

bot.start();
```

```ts [Deno]
import { Bot } from "https://deno.land/x/grammy/mod.ts";

const bot = new Bot(""); // <-- put your bot token between the "" (https://t.me/BotFather)

// Reply to any message with "Hi there!".
bot.on("message", (ctx) => ctx.reply("Hi there!"));

bot.start();
```

:::

Works! :tada:

<footer id="home-footer">

---

<ClientOnly>
  <ThankYou :s="[
    'Thank you, ',
    '{name}',
    ', for being a contributor to grammY.',
    ', for creating grammY.'
  ]" />
</ClientOnly>

<div style="font-size: 0.75rem; display: flex; justify-content: center;">

© 2021-2025 &middot; grammY supports Telegram Bot API 9.0 which was [released](https://core.telegram.org/bots/api#april-11-2025) on April 11, 2025.
(Last highlight: Business Account and Gift Improvements)

</div>
</footer>
<ClientOnly>
  <LanguagePopup />
</ClientOnly>
</file>

</files>
